<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="[TOC] Go 常量  定义格式 const Name [Type] &#x3D; Value   变量  定义格式 var Name [Type] 系统自动赋予初值 全局变量希望能被外部包所使用，则需要将变量首字母大写 函数体内定义的变量为局部变量，否则为全局变量 可以省去Type，变量在被赋值时编辑器会在编译阶段做类型推断 当你在函数体内声明局部变量时，应使用简短声明语法 :&#x3D; 值类型和引用类型 值类">
<meta property="og:type" content="article">
<meta property="og:title" content="Programming language GO &amp; RUST">
<meta property="og:url" content="http://example.com/2022/01/04/Programming-language-GO-RUST/index.html">
<meta property="og:site_name" content="Mars">
<meta property="og:description" content="[TOC] Go 常量  定义格式 const Name [Type] &#x3D; Value   变量  定义格式 var Name [Type] 系统自动赋予初值 全局变量希望能被外部包所使用，则需要将变量首字母大写 函数体内定义的变量为局部变量，否则为全局变量 可以省去Type，变量在被赋值时编辑器会在编译阶段做类型推断 当你在函数体内声明局部变量时，应使用简短声明语法 :&#x3D; 值类型和引用类型 值类">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-01-04T02:41:13.000Z">
<meta property="article:modified_time" content="2022-01-04T02:41:30.446Z">
<meta property="article:author" content="Javie Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/01/04/Programming-language-GO-RUST/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Programming language GO & RUST | Mars</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mars</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Make the world better place.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/Programming-language-GO-RUST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mars">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Programming language GO & RUST
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-04 10:41:13 / Modified: 10:41:30" itemprop="dateCreated datePublished" datetime="2022-01-04T10:41:13+08:00">2022-01-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><ol>
<li><p>常量</p>
<ol>
<li>定义格式 const Name [Type] = Value</li>
</ol>
</li>
<li><p>变量</p>
<ol>
<li>定义格式 var Name [Type]</li>
<li>系统自动赋予初值</li>
<li>全局变量希望能被外部包所使用，则需要将变量首字母大写</li>
<li>函数体内定义的变量为局部变量，否则为全局变量</li>
<li>可以省去Type，变量在被赋值时编辑器会在编译阶段做类型推断</li>
<li>当你在函数体内声明局部变量时，应使用简短声明语法 <code>:=</code></li>
<li>值类型和引用类型<ol>
<li>值类型用等号赋值的时候，实际上是在内存中做了值拷贝<ol>
<li>int float bool string 数组 struct</li>
<li>存储在栈内</li>
</ol>
</li>
<li>引用类型变量存储的是值所在的内存地址<ol>
<li>指针 slices maps channel</li>
<li>存储在堆中</li>
<li>局部变量的简短化创建形式a := 50</li>
<li>局部变量不可以声明了但却不使用，全局变量可以</li>
</ol>
</li>
<li>init函数<ol>
<li>变量可以在init函数中被初始化，init函数在每个包完成初始化后自动执行，优先级比main高</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>基本类型和运算符</p>
<ol>
<li>bool 格式化输出时，可以用%t来表示要输出的类型为bool</li>
<li>数值类型：<ol>
<li>int和uint根据操作系统的位数，决定数值的长度（4位或者8位）</li>
<li>uintptr长度被设定为足够放一个指针即可</li>
<li>整数：<ol>
<li>int8（-128 -&gt; 127）</li>
<li>int16（-32768 -&gt; 32767）</li>
<li>int32（-2,147,483,648 -&gt; 2,147,483,647）</li>
<li>int64（-9,223,372,036,854,775,808 -&gt; 9,223,372,036,854,775,807）</li>
</ol>
</li>
<li>无符号整数：<ol>
<li>uint8（0 -&gt; 255）</li>
<li>uint16（0 -&gt; 65,535）</li>
<li>uint32（0 -&gt; 4,294,967,295）</li>
<li>uint64（0 -&gt; 18,446,744,073,709,551,615）</li>
</ol>
</li>
<li>浮点数：<ol>
<li>float32（+- 1e-45 -&gt; +- 3.4 * 1e38）：小数点后7位</li>
<li>float64（+- 5 <em>1e-324 -&gt; 107</em> 1e308）：小数点后15位</li>
</ol>
</li>
<li>复数：<ol>
<li>complex64(32位实数和虚数)</li>
<li>Complex128(64位实数和虚数)</li>
</ol>
</li>
<li>随机数：<ol>
<li>rand包</li>
</ol>
</li>
<li>类型别名：<ol>
<li>type 别名 类型</li>
</ol>
</li>
<li>字符类型<ol>
<li>char</li>
<li>实际存储了整型</li>
</ol>
</li>
</ol>
</li>
<li>字符串<ol>
<li>字符串是字节的定长数组</li>
<li>解释字符串，用双引号括起来</li>
<li>非解释字符串，反引号括起来</li>
<li>字符串的二元运算符比较，逐个字节对比</li>
<li>获取字符串中某个字节的地址是非法的$str[i]</li>
<li>字符串使用+拼接</li>
</ol>
</li>
<li>strings和strconv包（String 库函数的使用）</li>
<li>指针：<ol>
<li>一个指针变量可以指向任何一个值得内存地址</li>
</ol>
</li>
</ol>
</li>
<li><p>控制结构（省去了condition两侧的括号，使得代码更加整洁,执行语句中的括号在任何情况下都不能被省略）</p>
<ol>
<li>if-else</li>
<li>if-else if-else</li>
<li>测试多返回值函数的错误<ol>
<li>方法可以返回多个返回值，第二个返回值可以是错误的详细信息，如果第二个返回值不为Nil，则代表发生了错误。</li>
</ol>
</li>
<li>switch case：<ol>
<li>不需要写break</li>
<li>如果希望匹配到之后还继续执行后面的分支，用“fallthrough”关键字</li>
<li>switch 语句的第二种形式是不提供任何被判断的值（实际上默认为判断是否为 true），然后在每个 case 分支中进行测试不同的条件。当任一分支的测试结果为 true 时，该分支的代码会被执行。这看起来非常像链式的 if-else 语句，但是在测试条件非常多的情况下，提供了可读性更好的书写方式。</li>
<li>switch的第三种形式是condition中可以对两个变量进行计算赋值。随后在case分支中根据变量的值进行具体的行为</li>
</ol>
</li>
<li>循环：for结构<ol>
<li>基本形式：for 初始化语句;条件语句;修饰语句{}</li>
<li>第二种形式，类似于while循环。没有初始化语句和index更新语句</li>
<li>第三种形式，无限循环。for {}</li>
<li>for-range结构：<code>for ix, val := range coll &#123; &#125;</code></li>
</ol>
</li>
<li>Break 和 continue</li>
<li>label和goto（不推荐使用，没看）</li>
</ol>
</li>
<li><p>函数</p>
<ol>
<li><p>分类：普通的带有名字的函数、匿名函数、方法</p>
</li>
<li><p>go里面函数重载是不允许的，没有泛型，为了效率</p>
</li>
<li><p>函数的一般定义：<code>func f(name1 type1,name 2type2) 返回值类型</code>,参数可以没有参数名。</p>
</li>
<li><p>函数都是按照值传递的</p>
</li>
<li><p>带命名的返回值，只需要在函数尾部直接return</p>
</li>
<li><p>不带命名的返回值，需要用（）装起来写在return后面</p>
</li>
<li><p>空白符<code>_</code>匹配一些不需要的值，然后丢掉</p>
</li>
<li><p>通过传递指针来改变函数外部变量的值</p>
</li>
<li><p>变长参数函数</p>
<ol>
<li><p>形式：<code>func myFunc(a,b,arg ...int)&#123;&#125;</code></p>
</li>
<li><p>如果一个变长参数的类型没有被指定，则可以使用默认的空接口 <code>interface&#123;&#125;</code>，这样就可以接受任何类型的参数</p>
<p>`func typecheck(..,..,values … interface{}) {</p>
<pre><code>for _, value := range values &#123;
    switch v := value.(type) &#123;
        case int: …
        case float: …
        case string: …
        case bool: …
        default: …
    &#125;
&#125;
</code></pre>
<p>}`</p>
</li>
</ol>
</li>
<li><p>defer和追踪</p>
<ol>
<li>defer作用：类似于finally，用于一些资源的释放</li>
<li>使用defer来记录函数的参数和返回值</li>
</ol>
</li>
<li><p>将函数作为参数</p>
<ol>
<li><code>func IndexFunc(s string, f func(c int) bool) int</code></li>
</ol>
</li>
<li><p>闭包</p>
<ol>
<li>匿名函数赋值给变量：<code>fplus := func(x, y int) int &#123; return x + y &#125;</code></li>
<li>直接调用匿名函数：<code>func(x, y int) int &#123; return x + y &#125; (3, 4)</code></li>
<li>匿名函数的调用，在匿名函数后加一对（）表示对其的调用</li>
</ol>
</li>
<li><p>应用闭包：将函数作为返回值</p>
<ol>
<li><p>闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。</p>
</li>
<li><p>在闭包中使用到的变量可以是在闭包函数体内声明的，也可以是在外部函数声明的：</p>
<p>`var g int<br>go func(i int) {</p>
<pre><code>s := 0
for j := 0; j &lt; i; j++ &#123; s += j &#125;
g = s
</code></pre>
<p>}(1000) // Passes argument 1000 to the function literal.`</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数组与切片</p>
<ol>
<li><p>数组</p>
<ol>
<li>声明语句：<code>var identifier [len]type</code></li>
<li>使用for循环遍历</li>
</ol>
<p>`for i:=0; i &lt; len(arr1); i++｛</p>
<pre><code>arr1[i] = ...
</code></pre>
<p>}`</p>
<ol start="3">
<li>使用for-range遍历</li>
</ol>
<p>`for i:=0; i &lt; len(arr1); i++｛</p>
<pre><code>arr1[i] = ...
</code></pre>
<p>}`</p>
<ol start="4">
<li>Go 语言中的数组是一种 <strong>值类型</strong>（不像 C/C++ 中是指向首元素的指针），所以可以通过 <code>new()</code> 来创建： <code>var arr1 = new([5]int)</code>。arr1的类型是*[5]int，把arr1赋值给另一个时，需要做一次数组内存的拷贝。</li>
<li>讲数组作为函数参数时，会做一次数组的拷贝，如果需要修改传入数组的值，需要用引用传递的方式</li>
<li>数组可以在声明时使用{}来初始化</li>
</ol>
</li>
<li><p>切片</p>
<ol>
<li><p>定义和相关特性</p>
<ol>
<li>切片（slice）是对数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以切片是一个引用类型</li>
<li>和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个 <strong>长度可变的数组</strong>。</li>
<li>多个切片如果表示同一个数组的片段，它们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。</li>
</ol>
</li>
<li><p>优点：</p>
<ol>
<li>因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go 代码中 切片比数组更常用。</li>
</ol>
</li>
<li><p>声明：<code>var identifier []type</code>（不需要说明长度）。</p>
</li>
<li><p>初始化：</p>
<ol>
<li><code>var slice1 []type = arr1[start:end]</code>头闭尾开区间</li>
<li>类似数组的初始化：<code>var x = []int&#123;2, 3, 5, 7, 11&#125;</code>。这样就创建了一个长度为 5 的数组并且创建了一个相关切片。</li>
</ol>
</li>
<li><p>长度：存储的值的个数</p>
</li>
<li><p>容量：<code>cap()</code> 可以测量切片最长可以达到多少：它等于切片从第一个元素开始，到相关数组末尾的元素个数</p>
</li>
<li><p>对于每个切片，以下状态总是成立：</p>
<p><code>s == s[:i] + s[i:] // i是一个整数且: 0 &lt;= i &lt;= len(s) len(s) &lt;= cap(s)</code></p>
</li>
<li><p>切片的存储类似结构体：</p>
<ol>
<li>指向相关数组的指针</li>
<li>长度</li>
<li>容量</li>
</ol>
</li>
<li><p>将切片传递给函数：</p>
<p>`func sum(a []int) int {</p>
<pre><code>s := 0
for i := 0; i &lt; len(a); i++ &#123;
    s += a[i]
&#125;
return s
</code></pre>
<p>}</p>
<p>func main() {</p>
<pre><code>var arr = [5]int&#123;0, 1, 2, 3, 4&#125;
sum(arr[:])
</code></pre>
<p>}`</p>
</li>
<li><p>使用make创造一个切片：</p>
<ol>
<li><code>var slice1 []type = make([]type, len)</code>。</li>
<li>简写为：<code>slice1 := make([]type, len)</code></li>
<li>make 的使用方式是：<code>func make([]T, len, cap)</code>，其中 cap 是可选参数。</li>
<li>以下两种创建切片的方法等效：<ol>
<li><code>make([]int, 50, 100)</code></li>
<li><code>new([100]int)[0:50]</code></li>
</ol>
</li>
</ol>
</li>
<li><p>make和new的区别</p>
<ol>
<li>看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。</li>
<li>new (T) 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型为 * T 的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体（参见第 10 章）；它相当于 &amp;T{}。</li>
<li>make(T) 返回一个类型为 T 的初始值，它只适用于 3 种内建的引用类型：切片、map 和 channel</li>
<li>换言之，new 函数分配内存，make 函数初始化</li>
</ol>
</li>
<li><p>bytes包Buffer（类似于java里面的StringBuilder）</p>
<ol>
<li>申明方式：<code>var buffer bytes.Buffer</code></li>
<li>获取指针：<code>var r *bytes.Buffer = new(bytes.Buffer)</code></li>
<li>或者通过函数：<code>func NewBuffer(buf []byte) *Buffer</code></li>
</ol>
</li>
<li><p>切片的for-range</p>
<ol>
<li><p>单维切片：</p>
<p>`for ix, value := range slice1 {</p>
<pre><code>...
</code></pre>
<p>}`</p>
</li>
<li><p>多维切片：</p>
<p>`for row := range screen {</p>
<pre><code>for column := range screen[row] &#123;
    screen[row][column] = 1
&#125;
</code></pre>
<p>}`</p>
</li>
</ol>
</li>
<li><p>切片重组（扩容）</p>
<ol>
<li>扩展一位：<code>sl = sl[0:len(sl)+1]</code></li>
</ol>
</li>
<li><p>切片的复制与增加</p>
<ol>
<li><p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原切片的内容都拷贝过来。</p>
</li>
<li><p>通过<code>func append(s[]T, x ...T) []T</code>在切片中追加内容</p>
<ol>
<li>例子<code>sl3 := []int&#123;1, 2, 3&#125;    sl3 = append(sl3, 4, 5, 6)</code></li>
</ol>
</li>
<li><p>通过拷贝讲切片复制到新的切片中<code>func copy(dst, src []T) int</code>,返回拷贝的元素的个数</p>
<ol>
<li><p>例子：<code>sl_from := []int&#123;1, 2, 3&#125;  </code></p>
<p>​            <code> sl_to := make([]int, 10)   </code>  </p>
<p>​            <code>n := copy(sl_to, sl_from)</code></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Map</p>
<ol>
<li><p>声明：<code>var map1 map[keytype]valuetype</code></p>
</li>
<li><p>赋值：<code>map1[key1] = val1</code></p>
</li>
<li><p>取值：<code>v := map1[key1]</code></p>
</li>
<li><p>获取长度:<code>len(map1)</code></p>
</li>
<li><p>初始化：<code>&#123;key1:val1, key2:val2&#125;</code></p>
</li>
<li><p>make初始化：<code>map1 := make(map[keytype]valuetype)</code> 相当于``mapCreated := map[string]float32{}`</p>
</li>
<li><p>切片作为map的值：</p>
<p><code>mp1 := make(map[int][]int)  mp2 := make(map[int]*[]int)</code></p>
</li>
<li><p>检验key是否存在：</p>
<p>`if _, ok := map1[key1]; ok {</p>
<pre><code>// ...
</code></pre>
<p>}`</p>
</li>
<li><p>删除kv： <code>delete(map1, key1)</code></p>
</li>
<li><p>for-range遍历：</p>
<ol>
<li><p>kv：</p>
<p>`for key, value := range map1 {</p>
<pre><code>...
</code></pre>
<p>}`</p>
</li>
<li><p>只关心value</p>
<p>`for _, value := range map1 {</p>
<pre><code>...
</code></pre>
<p>}`</p>
</li>
<li><p>只关心key</p>
<p>`for key := range map1 {</p>
<pre><code>fmt.Printf(&quot;key is: %d\n&quot;, key)
</code></pre>
<p>}`</p>
</li>
</ol>
</li>
<li><p>切片：</p>
<ol>
<li><p>两次make，第一次分配切片，第二次分配切片中每个map元素</p>
<p>`items := make([]map[int]int, 5)<br>for i:= range items {</p>
<pre><code>items[i] = make(map[int]int, 1)
items[i][1] = 2
</code></pre>
<p>}`</p>
</li>
</ol>
</li>
<li><p>map排序</p>
<ol>
<li>拷贝出key，对key排序，然后顺序遍历key取出value（会不会效率太低了？）</li>
</ol>
</li>
<li><p>将kv对调：</p>
<ol>
<li>拷贝一个新的大小相同的map，遍历原始map，复制数据到新的map</li>
</ol>
</li>
</ol>
</li>
<li><p>包</p>
<ol>
<li>标准库</li>
<li>regexp包</li>
<li>sync包</li>
<li>紧密计算big包</li>
<li>自定义包和可见性：<ol>
<li>Import with . :import . “./pack1”，当使用. 来做为包的别名时，可以不通过包名来使用其中的项目。例如：test := ReturnStr()。在当前的命名空间导入 pack1 包，一般是为了具有更好的测试效果。</li>
<li>Import with _ :import _ “./pack1”，pack1 包只导入其副作用，也就是说，只执行它的 init 函数并初始化其中的全局变量。</li>
<li>导入外部安装包：先通过go install安装</li>
</ol>
</li>
</ol>
</li>
<li><p>结构体和方法（struct &amp; method）</p>
<ol>
<li><p>结构体：</p>
<ol>
<li><p>定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> identifier <span class="keyword">struct</span> &#123;</span><br><span class="line">    field1 type1</span><br><span class="line">    field2 type2</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用new</p>
<p><code> t := new(T)</code></p>
</li>
<li><p>使用声明：</p>
<p><code>var t T</code>:分配内存并零值化内存</p>
</li>
<li><p>使用<code>.</code>选择器来访问结构体的属性，无论变量是结构体还是结构体类型的指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span> &#123; i <span class="keyword">int</span> &#125;</span><br><span class="line"><span class="keyword">var</span> v myStruct    <span class="comment">// v是结构体类型变量</span></span><br><span class="line"><span class="keyword">var</span> p *myStruct   <span class="comment">// p是指向一个结构体类型变量的指针</span></span><br><span class="line">v.i</span><br><span class="line">p.i</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>&#123;&#125;</code>初始化一个结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ms := &amp;struct1&#123;<span class="number">10</span>, <span class="number">15.5</span>, <span class="string">&quot;Chris&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 此时ms的类型是 *struct1</span></span><br></pre></td></tr></table></figure>

<p>表达式 <code>new(Type)</code> 和 <code>&amp;Type&#123;&#125;</code> 是等价的。</p>
<p>或者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ms struct1</span><br><span class="line">ms = struct1&#123;<span class="number">10</span>, <span class="number">15.5</span>, <span class="string">&quot;Chris&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>或者制定字段key来初始化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intr := Interval&#123;<span class="number">0</span>, <span class="number">3</span>&#125;            (A)</span><br><span class="line">intr := Interval&#123;end:<span class="number">5</span>, start:<span class="number">1</span>&#125;  (B)</span><br><span class="line">intr := Interval&#123;end:<span class="number">5</span>&#125;           (C)</span><br></pre></td></tr></table></figure></li>
<li><p>结构体的内存布局：结构体和它所包含的数据在内存中是以连续快的形式存在的。</p>
</li>
<li><p>递归结构体：可以用来定义链表的节点或者二叉树的节点</p>
</li>
<li><p>make不能用于struct</p>
</li>
<li><p>结构体可以带Tag，通过反射获取</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TagType <span class="keyword">struct</span> &#123; <span class="comment">// tags</span></span><br><span class="line">    field1 <span class="keyword">bool</span>   <span class="string">&quot;An important answer&quot;</span></span><br><span class="line">    field2 <span class="keyword">string</span> <span class="string">&quot;The name of the thing&quot;</span></span><br><span class="line">    field3 <span class="keyword">int</span>    <span class="string">&quot;How much there are&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tt := TagType&#123;<span class="literal">true</span>, <span class="string">&quot;Barak Obama&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        refTag(tt, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">refTag</span><span class="params">(tt TagType, ix <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ttType := reflect.TypeOf(tt)</span><br><span class="line">    ixField := ttType.Field(ix)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, ixField.Tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>匿名字段和内嵌结构体</p>
<ol>
<li>匿名字段：通过<code>结构体名字.字段类型</code>来访问匿名字段，没个结构体针对每一种数据类型只能有一个匿名字段</li>
<li>内嵌结构体:结构体可以通过<code>结构体名字.内嵌结构体字段</code>来访问内嵌匿名结构体的字段，类似于软件工程领域的组合设计模式</li>
<li>命名冲突：外层结构体的相同命名字段会覆盖内层结构体的相同命名字段，访问外层结构体的相同命名字段<code>A.b</code>，访问内层结构体的相同命名字段<code>A.B.b</code></li>
</ol>
</li>
</ol>
</li>
<li><p>方法：</p>
<ol>
<li><p>在 Go 语言中，结构体就像是类的一种简化形式，那么面向对象程序员可能会问：类的方法在哪里呢？在 Go 中有一个概念，它和方法有着同样的名字，并且大体上意思相同：Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。一个类型加上它的方法等价于面向对象中的一个类。一个重要的区别是：在 Go 中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的。</p>
</li>
<li><p>类型 T（或 *T）上的所有方法的集合叫做类型 T（或 *T）的方法集。</p>
<p>因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法。但是如果基于接收者类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收者类型上存在，比如在同一个包里这么做是允许的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *denseMatrix)</span> <span class="title">Add</span><span class="params">(b Matrix)</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *sparseMatrix)</span> <span class="title">Add</span><span class="params">(b Matrix)</span> <span class="title">Matrix</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>定义方法的格式</p>
<p><code>func (recv receiver_type) methodName(parameter_list) (return_value_list) &#123; ... &#125;</code></p>
</li>
<li><p>方法的调用方式：</p>
<p><code>recv.methodName()</code>,recv类似于面向对象语言中的this或者self</p>
</li>
<li><p>一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TwoInts <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    two1 := <span class="built_in">new</span>(TwoInts)</span><br><span class="line">    two1.a = <span class="number">12</span></span><br><span class="line">    two1.b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;The sum is: %d\n&quot;</span>, two1.AddThem())</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Add them to the param: %d\n&quot;</span>, two1.AddToParam(<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">    two2 := TwoInts&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;The sum is: %d\n&quot;</span>, two2.AddThem())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tn *TwoInts)</span> <span class="title">AddThem</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tn.a + tn.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tn *TwoInts)</span> <span class="title">AddToParam</span><span class="params">(param <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tn.a + tn.b + param</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数和方法的区别：</p>
<ol>
<li><p>函数将变量作为参数：<strong>Function1(recv)</strong></p>
<p>方法在变量上被调用：<strong>recv.Method1()</strong></p>
</li>
<li><p><strong>方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。</strong></p>
</li>
</ol>
</li>
<li><p>指针作为接受者：</p>
<ol>
<li>传入指针或者值都是合法的，go会自动解引用</li>
<li>指针方法和值方法都可以在指针或者非指针上被调用</li>
</ol>
</li>
<li><p>获取或者设置对象的值使用getter和setter</p>
</li>
<li><p>多重继承可以通过一个类型内嵌多个匿名类型来实现，匿名类型的方法会被提升为此父类型的方法</p>
</li>
<li><p>总结：</p>
<ol>
<li>在Go中，类型就是类</li>
<li>Go拥有类似面向对象语言的嘞继承的概念以实现代码复用和多态</li>
<li>go中代码复用通过组合和委托实现，多态用接口来实现。</li>
<li>类型可以覆写内嵌匿名类型的方法</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>接口与反射</p>
<ol>
<li><p>接口</p>
<ol>
<li><p>定义：接口提供了一种方式来说明对象的行为：如果谁能搞定这件事，它就可以用在这儿。</p>
</li>
<li><p>接口定义了一组方法，但是这些方法不包含实现，接口内也不能拥有变量</p>
</li>
<li><p>接口定义语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Namer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Method1(param_list) return_type</span><br><span class="line">    Method2(param_list) return_type</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。</p>
<p>实现某个接口的类型（除了实现接口方法外）可以有其他的方法。</p>
<p>一个类型可以实现多个接口。</p>
<p>接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。</p>
</li>
<li><p>例子（go中的多态？）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">    side <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sq1 := <span class="built_in">new</span>(Square)</span><br><span class="line">    sq1.side = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> areaIntf Shaper</span><br><span class="line">    areaIntf = sq1</span><br><span class="line">    <span class="comment">// shorter,without separate declaration:</span></span><br><span class="line">    <span class="comment">// areaIntf := Shaper(sq1)</span></span><br><span class="line">    <span class="comment">// or even:</span></span><br><span class="line">    <span class="comment">// areaIntf := sq1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;The square has area: %f\n&quot;</span>, areaIntf.Area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接口嵌套接口</p>
<ol>
<li><p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b Buffer) <span class="keyword">bool</span></span><br><span class="line">    Write(b Buffer) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>类型断言：如何监测和转换接口变量的类型？</p>
<ol>
<li><p>定义：一个接口类型的变量varI中可以包含任何类型的值，必须有一种方式来检测它的动态类型，即运行时在变量中存储的值的实际类型。在执行过程中动态类型可能会有所不同，但是它总是可以分配给接口变量本身的类型。通常我们可以使用类型断言来测试某个时刻varI是否包含类型T的值：</p>
<p><code>v := varI.(T)</code></p>
<p>varI必须是一个接口类型变量。类型断言可能是无效的，虽然编译器会尽力检查转换是否有效，但是它不可能预见所有的可能性。如果转换在程序运行时失败会导致错误发生。更安全的方式是使用以下形式来进行类型断言：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := varI.(T); ok &#123;  <span class="comment">// checked type assertion</span></span><br><span class="line">    Process(v)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// varI is not of type T</span></span><br></pre></td></tr></table></figure>

<p>如果转换合法，<code>v</code> 是 <code>varI</code> 转换到类型 <code>T</code> 的值，<code>ok</code> 会是 <code>true</code>；否则 <code>v</code> 是类型 <code>T</code> 的零值，<code>ok</code> 是 <code>false</code>，也没有运行时错误发生。</p>
<p>例子：(暂时还不能明白这个的用处2021/12/2)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">    side <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> areaIntf Shaper</span><br><span class="line">    sq1 := <span class="built_in">new</span>(Square)</span><br><span class="line">    sq1.side = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    areaIntf = sq1</span><br><span class="line">    <span class="comment">// Is Square the type of areaIntf?</span></span><br><span class="line">    <span class="keyword">if</span> t, ok := areaIntf.(*Square); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;The type of areaIntf is: %T\n&quot;</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> u, ok := areaIntf.(*Circle); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;The type of areaIntf is: %T\n&quot;</span>, u)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;areaIntf does not contain a variable of type Circle&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *Circle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ci.radius * ci.radius * math.Pi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>类型判断：type-switch</p>
<ol>
<li><p>接口变量的类型也可以使用type-switch结构来判断</p>
</li>
<li><p>接口类型变量可以代表任何类型，所以需要有类型判断</p>
</li>
<li><p>例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">classifier</span><span class="params">(items ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> items &#123;</span><br><span class="line">        <span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is a bool\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is a float64\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">int64</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is a int\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is a nil\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is a string\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is unknown\n&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以这样调用此方法：classifier(13, -14.3, “BELGIUM”, complex(1, 2), nil, false) 。</p>
<p>在处理来自于外部的、类型未知的数据时，比如解析诸如 JSON 或 XML 编码的数据，类型测试和转换会非常有用。</p>
</li>
</ol>
</li>
<li><p>测试一个值是否实现了某个接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sv, ok := v.(Stringer); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;v implements String(): %s\n&quot;</span>, sv.String()) <span class="comment">// note: sv, not v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质。</p>
</li>
<li><p>使用方法集与接口（这节有点晦涩）</p>
<ol>
<li><p>总结</p>
<p>在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 P 直接可以辨识的：</p>
<ol>
<li>指针方法可以通过指针调用</li>
<li>值方法可以通过值调用</li>
<li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li>
<li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li>
</ol>
</li>
<li><p>Go 语言规范定义了接口方法集的调用规则：</p>
<ol>
<li>类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集</li>
<li>类型 T 的可调用方法集包含接受者为 T 的所有方法</li>
<li>类型 T 的可调用方法集不包含接受者为 *T 的方法</li>
</ol>
</li>
</ol>
</li>
<li><p>空接口</p>
<ol>
<li><p>概念：不包含任何方法，它对实现不做任何要求（类似于Java中的Object对象）</p>
</li>
<li><p>可以给一个空接口类型的变量<code>var val interface &#123;&#125;</code>赋值任何类型的值</p>
</li>
<li><p>复制数据切片到空接口切片是不允许的，因为内存布局不一致，需要用for-range逐个复制</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSlice []myType = FuncReturnSlice()</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(dataSlice))</span><br><span class="line"><span class="keyword">for</span> i, d := <span class="keyword">range</span> dataSlice &#123;</span><br><span class="line">    interfaceSlice[i] = d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>一个接口的值可以赋值给另一个接口变量，只要底层类型实现了必要的方法</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>反射</p>
<ol>
<li><p>概念：反射是用程序检查气所拥有的的结构，尤其是类型的一种能力；这是元编程的一种形式，反射可以在运行时检查类型和变量，例如大小方法和动态的调用这些方法。</p>
</li>
<li><p>Go中反射包Type用来表示一个Go类型，反射包Value为Go值提供了发射接口</p>
</li>
<li><p>两个函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>通过反射修改或者设置值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    <span class="comment">// setting a value:</span></span><br><span class="line">    <span class="comment">// v.SetFloat(3.1415) // Error: will panic: reflect.Value.SetFloat using unaddressable value</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br><span class="line">    v = reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;type of v:&quot;</span>, v.Type())</span><br><span class="line">    fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br><span class="line">    v = v.Elem()</span><br><span class="line">    fmt.Println(<span class="string">&quot;The Elem of v is: &quot;</span>, v)</span><br><span class="line">    fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br><span class="line">    v.SetFloat(<span class="number">3.1415</span>) <span class="comment">// this works!</span></span><br><span class="line">    fmt.Println(v.Interface())</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">settability of v: <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> of v: *<span class="keyword">float64</span></span><br><span class="line">settability of v: <span class="literal">false</span></span><br><span class="line">The Elem of v is:  &lt;<span class="keyword">float64</span> Value&gt;</span><br><span class="line">settability of v: <span class="literal">true</span></span><br><span class="line"><span class="number">3.1415</span></span><br><span class="line">&lt;<span class="keyword">float64</span> Value&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>反射结构体：</p>
<ol>
<li>``NumField()<code> </code>方法返回结构体内的字段数量</li>
<li>通过for循环用索引取得每个字段的值<code>Field(i)</code></li>
<li>用签名在结构体上的方法，例如，使用索引 n 来调用：<code>Method(n).Call(nil)</code></li>
</ol>
</li>
<li><p>接口与动态类型：</p>
<ol>
<li><p>Go 中的接口跟 Java/C# 类似：都是必须提供一个指定方法集的实现。但是更加灵活通用：任何提供了接口方法实现代码的类型都隐式地实现了该接口，而不用显式地声明。</p>
<p>和其它语言相比，Go 是唯一结合了接口值，静态类型检查（是否该类型实现了某个接口），运行时动态转换的语言，并且不需要显式地声明类型是否满足某个接口。该特性允许我们在不改变已有的代码的情况下定义和使用新接口。</p>
<p>接收一个（或多个）接口类型作为参数的函数，其实参可以是任何实现了该接口的类型。 实现了某个接口的类型可以被传给任何以此接口为参数的函数 。</p>
</li>
<li><p>接口的继承：</p>
<ol>
<li><p>当一个类型包含（内嵌）另一个类型（实现了一个或多个接口）的指针时，这个类型就可以使用（另一个类型）所有的接口方法。类型可以通过继承多个接口来提供像 <code>多重继承</code> 一样的特性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    *io.Reader</span><br><span class="line">    *io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Go中的面相对象总结：</p>
<ol>
<li>Go 没有类，而是松耦合的类型、方法对接口的实现。</li>
<li>封装：<ol>
<li>包范围内的：通过标识符首字母小写，<code>对象</code> 只在它所在的包内可见</li>
<li>可导出的：通过标识符首字母大写，<code>对象</code> 对所在包以外也可见</li>
</ol>
</li>
<li>继承：<ol>
<li>用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现</li>
</ol>
</li>
<li>多态：<ol>
<li>用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。Go 接口不是 Java 和 C# 接口的变体，而且：接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>错误处理与测试：</p>
<ol>
<li><p>Go中预定义的error类型接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义错误：</p>
<p><code>err := errors.New(“math - square root of negative number”)</code></p>
</li>
<li><p>运行时异常和Panic</p>
<ol>
<li><p>当发生像数组下标越界或类型断言失败这样的运行错误时，Go 运行时会触发运行时 panic，伴随着程序的崩溃抛出一个 runtime.Error 接口类型的值。这个错误值有个 RuntimeError() 方法用于区别普通错误。</p>
<p>panic 可以直接从代码初始化：当错误条件（我们所测试的代码）很严苛且不可恢复，程序不能继续运行时，可以使用 panic 函数产生一个中止程序的运行时错误。panic 接收一个做任意类型的参数，通常是字符串，在程序死亡时被打印出来。Go 运行时负责中止程序并给出调试信息。</p>
</li>
<li><p>Panic的调用方式：</p>
<p>在多层嵌套的函数调用中调用 panic，可以马上中止当前函数的执行，所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者。这样向上冒泡直到最顶层，并执行（每层的） defer，在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况：这个终止过程就是 panicking。</p>
</li>
</ol>
</li>
<li><p>从Panic中恢复</p>
<ol>
<li>panic 会导致栈被展开直到 defer 修饰的 recover () 被调用或者程序中止。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="The-Cargo-Book"><a href="#The-Cargo-Book" class="headerlink" title="The Cargo Book"></a>The Cargo Book</h2><ol>
<li><p>Cargo Guide</p>
<ol>
<li><p>What is cargo？</p>
<p><em>Cargo</em> is the Rust package manager. It is a tool that allows Rust <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/appendix/glossary.html#package"><em>packages</em></a> to declare their various dependencies and ensure that you’ll always get a repeatable build.</p>
</li>
<li><p>Creating a new package</p>
<ol>
<li><code>cargo new hello_world --bin</code></li>
<li><code>cargo build</code></li>
<li><code>cargo run</code></li>
<li><code>cargo build --release</code></li>
</ol>
</li>
<li><p>Working on an existing package</p>
<ol>
<li><code>git clone</code></li>
<li><code>cargo build</code>: fetch dependencies and build them</li>
</ol>
</li>
<li><p>Package layout</p>
<ol>
<li><code>Cargo.toml</code> and <code>Cargo.lock</code> are stored in the root of your package</li>
<li><code>src</code> for source code</li>
<li><code>src/lib.rs</code> for default library files</li>
<li>Other executables can be placed in <code>src/bin/</code>.</li>
<li>Benchmarks go in the <code>benches</code> directory.</li>
<li>Examples go in the <code>examples</code> directory.</li>
<li>Integration tests go in the <code>tests</code> directory.</li>
</ol>
</li>
<li><p>toml and lock</p>
<ol>
<li><code>Cargo.toml</code> is about describing your dependencies in a broad sense, and is written by you.</li>
<li><code>Cargo.lock</code> contains exact information about your dependencies. It is maintained by Cargo and should not be manually edited.</li>
<li><code>cargo update</code> will update dependencites to newest version</li>
</ol>
</li>
<li><p>Tests</p>
<ol>
<li>Command <code>cargo test</code></li>
<li>run unit tests in /src/tests dir</li>
<li>run integration-style  tests in /tests dir</li>
</ol>
</li>
</ol>
</li>
<li><p>Cargo Reference</p>
<ol>
<li>Specifying Dependencies<ol>
<li>specifying dependencites from crates.io:default choice</li>
<li>Caret requirements:an update is allowed if the new version number does not modify the lefct-most non-zero digit in the major,minor,patch grouping</li>
<li>Tilde requirements:specify a minimal version with some ability to update(not specified part can be modified)</li>
<li>Wildcard requirements：allow for any version where the wildcard is positioned</li>
<li>comparison requirements: allow manually specifying a version range or an exiact version to depend on</li>
<li>multiple requirements:eperated with comma</li>
<li>specifying dependencies from other registries</li>
<li>specifying depemdencies from git repositories</li>
<li>specifying path dependencies</li>
<li>Mutiple locations</li>
<li>Platform specified dependencies</li>
</ol>
</li>
</ol>
</li>
<li><p>Cargo commands</p>
<ol>
<li>General Commands<ol>
<li>cargo</li>
<li>cargo help</li>
<li>cargo version</li>
</ol>
</li>
<li>Build Commands<ol>
<li><code>cargo bench</code>:execute benchmarks of a package</li>
<li><code>cargo build</code>：Compile the current package</li>
<li><code>cargo check</code>: check a local package and all of its dependencies for errors</li>
<li><code>cargo clean</code>:remove artifacts feom the target directory that Cargo has generated in the past</li>
<li><code>cargo doc</code>:build the documentation for the local pakage and all dependencies.the output is placed in target/doc</li>
<li><code>cargo fetch</code>:fetch dependencies of a pakage from the network</li>
<li><code>cargo fix</code>:automatically fix lint warnings reported by rustc</li>
<li><code>cargo run</code>:run binary or exaple if local package</li>
<li><code>cargo rustc</code>:copile the current package</li>
<li><code>cargo rustdoc</code>:build a pakage’s documentation</li>
<li><code>cargo test</code>: execute unit and integration test of package</li>
</ol>
</li>
<li>Manifest Commands<ol>
<li><code>cargo generate-lockfile</code>：create cargo.lock file for the curren package or workspace.if already exists, rebuild the lastest avaliable version of every package</li>
<li><code>cargo locate-project</code>: print a JSON object to stdout with the full path to the Cargo.toml manifest</li>
<li><code>cargo metadata</code>:output JSON to stdout containning info about the memebers and resolved deoendencies of the current package,–format-version is recommended</li>
<li><code>cargo pkgid</code>: print out the fully qualified package ID specifier  for a package or dependency in the curren workspace</li>
<li><code>cargo tree</code>:display a tree of dependencies to the terminal</li>
<li><code>cargo update</code>:update dependencies as recorded in the local lock file</li>
<li><code>cargo vendor</code>:vendor all crates.io and git dependencies for a project into the specified directory at <code>&lt;path&gt;</code>. After this command completes the vendor directory specified by <code>&lt;path&gt;</code> will contain all remote sources from dependencies specified.</li>
<li><code>cargo verify-project</code>:parse the local manifest and check it’s validity</li>
</ol>
</li>
<li>Package commands<ol>
<li><code>cargo init</code>：create a new cargo manifest in the current directory.</li>
<li><code>cargo install</code>:This command manages Cargo’s local set of installed binary crates. Only packages which have executable <code>[[bin]]</code> or <code>[[example]]</code> targets can be installed, and all executables are installed into the installation root’s <code>bin</code> folder.</li>
<li><code>cargo new</code>:create a new cargo package in the given directory.</li>
<li><code>cargo search</code>:this performs a textual search for crates on cargo repository.The matching crates will be displayed along with their descriptioin in TOML format suitable for copying into a Cargo.html manifest.</li>
<li><code>cargo uninstall</code>:by default all binaries are removed for a crate but –bin and –example flags can be used to only remove particular binaries.</li>
</ol>
</li>
<li>Publishing Commands<ol>
<li><code>cargo login</code>:This command will save the API token to disk so that commands that require authentication, such as <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/commands/cargo-publish.html">cargo-publish(1)</a>, will be automatically authenticated. The token is saved in <code>$CARGO_HOME/credentials.toml</code>. <code>CARGO_HOME</code> defaults to <code>.cargo</code> in your home directory.</li>
<li><code>cargo owner</code>:This command will modify the owners for a crate on the registry. Owners of a crate can upload new versions and yank old versions. Non-team owners can also modify the set of owners, so take care!</li>
<li><code>cargo package</code>:This command will create a distributable, compressed <code>.crate</code> file with the source code of the package in the current directory. The resulting file will be stored in the <code>target/package</code> directory. </li>
<li><code>cargo publish</code>:This command will create a distributable, compressed <code>.crate</code> file with the source code of the package in the current directory and upload it to a registry. </li>
<li><code>cargo yank</code>:The yank command removes a previously published crate’s version from the server’s index. This command does not delete any data, and the crate will still be available for download via the registry’s download link.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="The-Rust-Programming-Language"><a href="#The-Rust-Programming-Language" class="headerlink" title="The Rust Programming Language"></a>The Rust Programming Language</h2><ol>
<li><p>Programming a Guessing Game</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> secret_number = rand::thread_rng().gen_range(<span class="number">1</span>..<span class="number">101</span>);</span><br><span class="line"><span class="comment">//      println!(&quot;The secret number is: &#123;&#125;&quot;, secret_number);</span></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> guess = <span class="built_in">String</span>::new();</span><br><span class="line">                io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line">                <span class="keyword">let</span> guess: <span class="built_in">u32</span> = <span class="keyword">match</span> guess.trim().parse() &#123;</span><br><span class="line">                                                <span class="literal">Ok</span>(num) =&gt; num,</span><br><span class="line">                                                <span class="literal">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">                                        &#125;;</span><br><span class="line">                <span class="keyword">match</span> guess.cmp(&amp;secret_number) &#123;</span><br><span class="line">                 Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">                 Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">                 Ordering::Equal =&gt; &#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You guessed :&#123;&#125;&quot;</span>, guess);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Common Programming Concepts</p>
<ol>
<li><p>Variables and Mutablity</p>
<ol>
<li>by default variables are immutable</li>
<li>if want mutable, use keyword <code>mut</code> before name of viariance</li>
<li>Difference between variables and constants<ol>
<li><code>mut</code> can not be used with constants</li>
<li>declare constants using <code>const</code> instead of <code>let</code></li>
<li>constants can be declared in any scope</li>
<li>constants may be set only to a constant expression</li>
<li>constants naming convention:use all upercase with underscores between words</li>
</ol>
</li>
<li>Shadowing<ol>
<li>we can shadow a variable by using the same variable’s name and repeating the use of <code>let</code> keyword</li>
<li>shadowing allow us using the same name for different types</li>
</ol>
</li>
</ol>
</li>
<li><p>Data types</p>
<ol>
<li><p>Scalar Types</p>
<ol>
<li><p>Integer Types</p>
<table>
<thead>
<tr>
<th>Length</th>
<th>Signed</th>
<th>Unsigned</th>
</tr>
</thead>
<tbody><tr>
<td>8-bit</td>
<td><code>i8</code></td>
<td><code>u8</code></td>
</tr>
<tr>
<td>16-bit</td>
<td><code>i16</code></td>
<td><code>u16</code></td>
</tr>
<tr>
<td>32-bit</td>
<td><code>i32</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>64-bit</td>
<td><code>i64</code></td>
<td><code>u64</code></td>
</tr>
<tr>
<td>128-bit</td>
<td><code>i128</code></td>
<td><code>u128</code></td>
</tr>
<tr>
<td>arch</td>
<td><code>isize</code></td>
<td><code>usize</code></td>
</tr>
</tbody></table>
<p>Range caculation: -(2^n - 1^) to 2^n - 1^ - 1</p>
<p>e.g. 1_000 = 1000, 57u8 = u8 type of value 57</p>
<p>more examples:</p>
<table>
<thead>
<tr>
<th>Number literals</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>Decimal</td>
<td><code>98_222</code></td>
</tr>
<tr>
<td>Hex</td>
<td><code>0xff</code></td>
</tr>
<tr>
<td>Octal</td>
<td><code>0o77</code></td>
</tr>
<tr>
<td>Binary</td>
<td><code>0b1111_0000</code></td>
</tr>
<tr>
<td>Byte (<code>u8</code> only)</td>
<td><code>b&#39;A&#39;</code></td>
</tr>
</tbody></table>
</li>
<li><p>Floating-Point Types</p>
<ol>
<li>single-percision:<code>f32</code></li>
<li>double-percision:<code>f64</code></li>
</ol>
</li>
<li><p>Boolean type</p>
<ol>
<li><code>bool</code></li>
</ol>
</li>
<li><p>Character Type</p>
<ol>
<li>size:4 bytes</li>
<li>Unicode</li>
<li><code>char</code></li>
</ol>
</li>
</ol>
</li>
<li><p>Compound Types</p>
<ol>
<li><p>The Tuple Type</p>
<ol>
<li><p>group together a number of values with a variety of types into one compound type</p>
</li>
<li><p>fix length</p>
</li>
<li><p>e.g.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>visited by index</p>
</li>
</ol>
</li>
<li><p>The Array Type</p>
<ol>
<li><p>every element of an array muse have the same type</p>
</li>
<li><p>fix length</p>
</li>
<li><p>e.g</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">3</span>; <span class="number">5</span>]<span class="comment">// size 5 with initial value 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>visited  by index</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Functions</p>
<ol>
<li>Coding stype: snake case. All letters are lowercase and underscores separate words</li>
<li>start with <code>fn</code></li>
<li>Function Parameters<ol>
<li>type of each parameter must be declared</li>
<li>multiple parameters separated with commas</li>
</ol>
</li>
<li>Function bodies contain statements and expressions<ol>
<li>Expressions do not include ending semicolons, if have, expression turns to statement,which will not return a value</li>
</ol>
</li>
<li>Functions with return values<ol>
<li>Declare return vlaue types after a <code>-&gt;</code></li>
<li> the return value of the function is synonymous with the value of the final expression in the block of the body of a function. </li>
</ol>
</li>
</ol>
</li>
<li><p>Comments</p>
<ol>
<li><code>//</code></li>
</ol>
</li>
<li><p>Control Flow</p>
<ol>
<li><p>If Expressions（if-else if-else）</p>
</li>
<li><p>Loop(loop)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    loop &#123;</span><br><span class="line">        println!(&quot;again!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>break &amp; continue can use lable to apply to the labled loop </p>
</li>
<li><p>you can add the calue you want returned after the <code>break</code> expression</p>
</li>
<li><p>conditional loop with <code>while</code></p>
</li>
<li><p>For loop:<code>for element in collection</code></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Understanding Ownership</p>
<ol>
<li><p>What is ownership?</p>
<ol>
<li>Memory is managed through a system of ownership with a set of rules that the compiler checks at compile time.</li>
<li>Stack and Heap<ol>
<li>stack for known, fixed size data at compile time</li>
<li>heap is less organized, freee space must be serached</li>
<li>hense stack is more efficiency</li>
<li>when code calls a function ,value passed into function and variables get pushed onto the stack , when the function is over, those values get poped off the stack</li>
<li>heap is controlled by ownership</li>
</ol>
</li>
<li>Ownership rules<ol>
<li>Each value in Rust has variable that’s called its owner</li>
<li>There can only be one owner at a time </li>
<li>When the owner goes out of scope,the value will be dropped</li>
</ol>
</li>
<li>Variable Scope<ol>
<li>When varianle comes into scope, it is valid</li>
<li>it remains valid until it goes out of scope</li>
</ol>
</li>
<li>The String type<ol>
<li>string is immutable but String not</li>
</ol>
</li>
<li>Memory and Allocation</li>
<li>Ways Variables and Data interact:Move<ol>
<li>primitive types allocated on stack</li>
<li>Reference allocated on stack</li>
<li>Data allocated on heap</li>
<li>For ptimitive types: s1 = s2 means copy on stack</li>
<li>For non-primitive types: s1 = s2 means referece copied on stack and data on heap did not do anything</li>
</ol>
</li>
<li>Ways Varianles and Data interact:Clone<ol>
<li>if we do want to deeply copy the heap data of the String, not just the stack data, we can use a common method called <code>clone</code></li>
</ol>
</li>
<li>Stack-Only data:copy<ol>
<li>Types such as integers that have a known size at compile time are strored entirely on the stack ,so copies of the actual values are quick to make.</li>
<li>if a type implements the <code>copy</code> trait, an doler variable is still usable after assignment.</li>
</ol>
</li>
<li>Ownership and functions<ol>
<li>The semantics for passing a value to a function are similar to those for assigning a value to a variable.Passing a variable to a funtion will move or Copy.For ptimitive types, after funciton calling, variable is still valid, but for other(e.g. String) types, calling function means ownership moving ,which meams s will be invalid after function call.</li>
</ol>
</li>
<li>Return values and scope<ol>
<li>returning values can also transfer ownership</li>
<li>The ownership of a variable follows the same pattern every time: assigning a vlaue to another variable moves it.When a variable that includes data on the heap goes out of scope,the value will be cleaned by <code>drop</code> unless the data has been moved to be owned by another variable.</li>
</ol>
</li>
</ol>
</li>
<li><p>References and Borrowing</p>
<ol>
<li><p>reference allow you to refer to some value without taking ownership of it.</p>
</li>
<li><p>The <code>&amp;s1</code> syntax lets us create a reference that <em>refers</em> to the value of <code>s1</code> but does not own it. Because it does not own it, the value it points to will not be dropped when the reference stops being used.</p>
</li>
<li><p>When functions have rederences as parameters intead of the actual values, we won’t need to return the values in order to give back ownership, because we never had ownership.We call the action of creating a reference  <em>borrowing</em>.</p>
</li>
<li><p>Modifying something borrowed is not allowed, just as variables are immutable by default, so are references.</p>
</li>
<li><p>Mutable references, e.g.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mutable references have one big restiction:you can have only one mutable reference to a particular piece of data at a time.The restriction preventing multiple mutable references to the same data at the same time allows for mutation but in a very controlled fashion.Rust prevents data races  even in compile time.Samelly, combining mutable and immutable references is also no permitted.(considered it is same as RW lock mechanism).Note that a reference’s scope starts from where it is introduced and continues through the last time that references is used.</p>
</li>
<li><p>Dangling References</p>
<p>In languages with pointers, it’s easy to erroneously create a <em>dangling pointer</em>, a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</p>
</li>
<li><p>The rules of References</p>
<ol>
<li>At any given time, you can have either one mutable references or any number of immutable references.</li>
<li>Referebces must always be valid.</li>
</ol>
</li>
</ol>
</li>
<li><p>The Slice Type</p>
<ol>
<li>A String Slice is a reference to part of a String.</li>
<li>We can create slices using a range within brackets by specifying <code>[starting_index..ending_index]</code>, where <code>starting_index</code> is the first position in the slice and <code>ending_index</code> is one more than the last position in the slice.</li>
<li>if starting_index omitted, which means start from zero, if ending_index omitted, which means end to last byte, if all ommited, which means reference the total string</li>
<li>The type that signifies “string slice” is written as <code>&amp;str</code></li>
<li>The compiler will ensure the references into the String remain valid.</li>
<li>String literals are slices：<code>let s = &quot;Hello, World&quot;</code>， the type of <code>s</code> here is <code>&amp;s</code>, it is a slice poting to that specified piont of the binary, This is also why string literals are immutable, <code>&amp;str</code> is an immutable reference.</li>
</ol>
</li>
</ol>
</li>
<li><p>Using structs to structure  related data</p>
<ol>
<li><p>Defining an instantiating structs</p>
<ol>
<li>Structs are similar to tuples, but unlike with tuple, you will name each piece of data so it is clear what the values mean.Structs are more flexible than tuples:you don’t have to rely on the order of the data so specify or access the value of an instance.</li>
<li>kv pairs visited(read or write) by dot<code>.</code></li>
</ol>
</li>
<li><p>Creating instances from other instances with struct update syntax</p>
<ol>
<li><p>Using struct update syntax, we can achieve the same effect with less code, as shown in Listing 5-7. The syntax <code>..</code> specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Using Tuple Structs Without Named Fields to Create Different Types</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>Unit-Like Structs Without Any Fields</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AlwaysEqual</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subject = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Method Syntax</p>
<ol>
<li><p>Method are similar to functions, but methods are different from functions in that they’re defined within the context of a struct and their first parameter is always <code>self</code>, which represents the instance of the stuct the method is being called on.</p>
</li>
<li><p>Where is the <code>-&gt;</code> Operator?</p>
<ol>
<li>Rust has a featured called automatic referencing and dereferencing.</li>
</ol>
</li>
<li><p>Associated Functions</p>
<ol>
<li><p>All functions defined within an <code>impl</code> block are called associaterd functions because they’re associated with the type name after the <code>impl</code></p>
</li>
<li><p>Associated functions that aren’t methods are often used for constructors that will return a new instance of the struct.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> sq = Rectangle::square(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Multiple imlp Blocks</p>
<ol>
<li>It is valid to seperate methods into multiple impl blocks but not recomended.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Enums and Pattern Matching</p>
<ol>
<li><p>Defining an Enum</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> four = IpAddrKind::V4;</span><br><span class="line">    <span class="keyword">let</span> six = IpAddrKind::V6;</span><br><span class="line"></span><br><span class="line">    route(IpAddrKind::V4);</span><br><span class="line">    route(IpAddrKind::V6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">route</span></span>(ip_kind: IpAddrKind) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Enum Values</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span>&#123;</span><br><span class="line">  v4(<span class="built_in">String</span>),</span><br><span class="line">  v6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="built_in">String</span>::from(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>Any type can be values for Enums.</p>
</li>
<li><p>Enum Methods</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">        Quit,</span><br><span class="line">        Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">        Write(<span class="built_in">String</span>),</span><br><span class="line">        ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Message &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="comment">// method body would be defined here</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> m = Message::Write(<span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    m.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>The <code>Option</code>Enum and it’s advantages over Null values</p>
<ol>
<li>When we have <code>Some</code>value,we know that a value is present and the value is held within the Some</li>
<li>When we have a <code>None</code>value,in some sense, it means the same thing as null</li>
<li>In other words, you have to convert an <code>Option&lt;T&gt;</code> to a <code>T</code> before you can perform <code>T</code> operations with it.Generally, this helps catch one of the most common issues with null: assuming that something isn’t null when it actually is.</li>
<li><code>match</code> expression is a control flow construct that does just this when used with enums.</li>
</ol>
</li>
<li><p>The match control flow operator</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">      <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">      <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">let</span> six = plus_one(five);</span><br><span class="line">  <span class="keyword">let</span> none = plus_one(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Matches Are Exhaustive</p>
<ol>
<li>Matches in Rust are exhaustive, we must exhaust every last possibility in order for the code to be valid.Especially inthe case of <code>Option&lt;T&gt;</code>, when Rust prevent us from forgetting to explicitly handle None case.</li>
</ol>
</li>
<li><p>Catch-all Patterns and the _ Placeholder</p>
<ol>
<li><p>for match default arm, we can use <code>other</code> and <code>_</code>to handle this.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let dice_roll = 9;</span><br><span class="line">    match dice_roll &#123;</span><br><span class="line">        3 =&gt; add_fancy_hat(),</span><br><span class="line">        7 =&gt; remove_fancy_hat(),</span><br><span class="line">        other =&gt; move_player(other),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_fancy_hat() &#123;&#125;</span><br><span class="line">    fn remove_fancy_hat() &#123;&#125;</span><br><span class="line">    fn move_player(num_spaces: u8) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let dice_roll = 9;</span><br><span class="line">    match dice_roll &#123;</span><br><span class="line">        3 =&gt; add_fancy_hat(),</span><br><span class="line">        7 =&gt; remove_fancy_hat(),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_fancy_hat() &#123;&#125;</span><br><span class="line">    fn remove_fancy_hat() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Concise Control Flow with if let</p>
<ol>
<li><p>The <code>if let</code>syntax lets you combine if and let into a less verbose way to handle values that match one pattern while ignoring the rest.</p>
</li>
<li><p>In other words, you can think of <code>if let</code> as syntax sugar for a <code>match</code> that runs code when the value matches one pattern and then ignores all other values.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let config_max = Some(3u8);</span><br><span class="line">    match config_max &#123;</span><br><span class="line">        Some(max) =&gt; println!(&quot;The maximum is configured to be &#123;&#125;&quot;, max),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let config_max = Some(3u8);</span><br><span class="line">    if let Some(max) = config_max &#123;</span><br><span class="line">        println!(&quot;The maximum is configured to be &#123;&#125;&quot;, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> coin = Coin::Penny;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Quarter(state) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state),</span><br><span class="line">        _ =&gt; count += <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> coin = Coin::Penny;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> Coin::Quarter(state) = coin &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>Managing Growing projects with packages,Crates,and Modules</p>
<p>(haven’t read)</p>
</li>
<li><p>Common Collections</p>
<ol>
<li><p>Types:</p>
<ol>
<li>A vector allows you to store a variable number of values next to each other</li>
<li>A string is a collection of characters</li>
<li>A hash map allows you to associate a value with a particular key</li>
</ol>
</li>
<li><p>Storing Lists of Values with Vectors</p>
<ol>
<li><p>Creating a new vector</p>
<p><code>let v: Vec&lt;i32&gt; = Vec::new()</code></p>
<p>Simply</p>
<p><code>let v = vec![1,2,3]</code></p>
</li>
<li><p>Update a vector</p>
<p><code>v.push(1)</code></p>
</li>
<li><p>Drop a vector Drops its elements</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do stuff with v</span></span><br><span class="line">    &#125; <span class="comment">// &lt;- v goes out of scope and is freed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Read elements of vectors</p>
<p>with index syntax or the <code>get</code> method</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> third: &amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="literal">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Iterating over the values in a vector</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">        *i += <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Using am Emum to store multiple Types</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</span><br><span class="line">        Int(<span class="built_in">i32</span>),</span><br><span class="line">        Float(<span class="built_in">f64</span>),</span><br><span class="line">        Text(<span class="built_in">String</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">        SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">        SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">        SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Storing UTF-8 Encoded Text with Strings</p>
<ol>
<li><p>Create a new String</p>
<p><code>let data = &quot;initial contents&quot;.to_string()</code></p>
<p><code>let s = String::from(&quot;initial contents&quot;)</code></p>
</li>
<li><p>Update a String</p>
<p><code>s.push_str(&quot;bar&quot;)</code></p>
<p><code>s.push(&#39;l&#39;)</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = s1 + &amp;s2;</span><br><span class="line"><span class="comment">// + use fn add(self, s: &amp;str) -&gt; String &#123;</span></span><br></pre></td></tr></table></figure>

<p>use <code>format!</code> Macro is recomended</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">String</span>::from(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br></pre></td></tr></table></figure>

<p><code>format!</code> macro works in the same way as <code>ptintln!</code> but instead of printing the output to the screen,it returns a <code>String</code> with the contents. The code generated by the <code>format!</code> macro uses references so that this call doesn’t take ownership of any of its parameters.</p>
</li>
<li><p>Index into Strings</p>
<ol>
<li>index to a String is not valid.</li>
</ol>
</li>
<li><p>Slice Strings</p>
<p><code>s[start..end]</code></p>
</li>
<li><p>Methods for Iterating Over Strings</p>
<p><code>for c in &quot;abcde&quot;.chars()</code></p>
<p><code>for b in &quot;abcde&quot;.bytes()</code></p>
</li>
</ol>
</li>
<li><p>Storing keys with associated values in hash maps</p>
<ol>
<li><p>Creating a hash map</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.inert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.indert(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>),<span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>Another way with two vec</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> teams = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> initial_scores = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores: HashMap&lt;_, _&gt; = teams.into_iter().zip(initial_scores.into_iter()).collect();</span><br></pre></td></tr></table></figure></li>
<li><p>HashMaps and ownership</p>
<ol>
<li>For types that implement the <code>copy</code> trait, the values are copied into the hashmap.For owned values like <code>String</code>, the values will be moved and the hashmao will be the owner of those values.</li>
</ol>
</li>
<li><p>Accessing values in a hashmap</p>
<p><code>let team_name = String::from(&quot;Blue&quot;)</code></p>
<p><code>let score = scores.get(&amp;team_name)</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std:collections::Hashmap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(key, value) int &amp;scores &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Updating a hashmap</p>
<ol>
<li><p>overwitring a value</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">20</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>Only inserting a value if the key has no value</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>)).or_insert(<span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>The <code>or_insert</code> method on <code>Entry</code> is defined to return a mutable reference to the value for the corresponding <code>Entry</code> key if that key exists, and if not ,inserts the parameter as the new value for this key and returns a mutable reference to the new value.</p>
</li>
<li><p>Updating a value based on the old value</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text,split_whitespcae() &#123;</span><br><span class="line">  <span class="keyword">let</span> count = map.entry(word).or_intsert(<span class="number">0</span>);</span><br><span class="line">  *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>or_insert</code> method actually returns a mutable reference(<code>&amp;mut v</code>) to the value for this key.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Error Handling</p>
<ol>
<li><p>Unrecoverable Erros with panic!</p>
</li>
<li><p>Recoverable Errors with Result</p>
<ol>
<li><p>Resuit Enum</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">	<span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">		OK(file) =&gt; file,</span><br><span class="line">		<span class="literal">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Mathcing on different errors</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>).unwrap_or_else(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.kind() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::create(<span class="string">&quot;hello.txt&quot;</span>).unwrap_or_else(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Shortcuts for panic on error:unwrap and expect</p>
<ol>
<li><p><code>unwrap</code> is a shortcut method that is implemented just like the <code>match</code>expression.if the <code>Result</code> value is <code>Ok</code> variant,<code>unwrap</code> will return the value inside the <code>Ok</code>.If the <code>Result</code> is the <code>Err</code> variant,<code>unwrap</code> will call the <code>panic!</code>macro for us.</p>
<p><code>let f = File::open(&quot;hello.txt&quot;).unwrap()</code></p>
</li>
<li><p>We use <code>expect</code> in the same way as <code>unwrap</code>: to return the file handle or call the <code>panic!</code> macro. The error message used by <code>expect</code> in its call to <code>panic!</code> will be the parameter that we pass to <code>expect</code>, rather than the default <code>panic!</code> message that <code>unwrap</code> uses.</p>
<p><code>let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open&quot;)</code></p>
</li>
</ol>
</li>
<li><p>Propagating Errors</p>
<p>A shortcut for prapagating errors:<code>?</code> operator</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">  f.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">  <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the value of the <code>Result</code> is an <code>OK</code>,tge value inside<code>Ok</code> will get returned from this expression, and the program will continue.if the value is an <code>Err</code>, the <code>Err</code> will be returned from the whole function as if we had used return keyword so the error value gets propagated to the calling code.</p>
<p>The <code>?</code> operator can be used in functions that have type of <code>Result</code>.</p>
</li>
</ol>
</li>
<li><p>To panic! Or Not To panic!</p>
<p>So how do you decide when you should call <code>panic!</code> and when you should return <code>Result</code>? When code panics, there’s no way to recover. You could call <code>panic!</code> for any error situation, whether there’s a possible way to recover or not, but then you’re making the decision on behalf of the code calling your code that a situation is unrecoverable. When you choose to return a <code>Result</code> value, you give the calling code options rather than making the decision for it. The calling code could choose to attempt to recover in a way that’s appropriate for its situation, or it could decide that an <code>Err</code> value in this case is unrecoverable, so it can call <code>panic!</code> and turn your recoverable error into an unrecoverable one. Therefore, returning <code>Result</code> is a good default choice when you’re defining a function that might fail.</p>
</li>
</ol>
</li>
<li><p>Generic Types, Traits, and LifeTImes</p>
<ol>
<li><p>Generic Data Types</p>
<ol>
<li><p>In Function Definitions</p>
<p>Before we use a para,eter in the body of the function, we have to declare the parameter name in the signature so the compiller knows what that name means.</p>
<p><code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;...&#125;</code></p>
</li>
<li><p>In Struct Definitions</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">  X: T,</span><br><span class="line">  y: T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T, U&gt; &#123;</span><br><span class="line">  x: T,</span><br><span class="line">  y: U,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>In Enum Definitions</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="literal">Some</span>(T),</span><br><span class="line">  <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">  <span class="literal">Ok</span>(T),</span><br><span class="line">  <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>In Method Definitions</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">  x: T,</span><br><span class="line">  y: T,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">    &amp;<span class="keyword">self</span>.x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Traits:Definning Shared Behavior</p>
<ol>
<li><p>A <em>trait</em> tells the Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior.</p>
</li>
<li><p>Defining a trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Imlementing a trait  on a type</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> </span><br><span class="line">	<span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">	<span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">	<span class="keyword">pub</span> author: <span class="built_in">String</span>,	</span><br><span class="line">	<span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Default Implementations</p>
<p>traits can have default implementations</p>
</li>
<li><p>Traits as parameters</p>
</li>
<li><p>We have implemented the <code>Summary</code> trait on the <code>NewsArticle</code> and <code>Tweet</code> types.We can define a <code>notify</code> function that calls the  summarize method on its <code>item</code> parameter,which is of some type that implements the <code>Summary</code> trait.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item : &amp;<span class="keyword">impl</span> Summary) &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Trait Bound Syntax</p>
<p>Code in item6 is straightforward but it is actually a syntax sugar for a longer form called trait bound.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T : Summary&gt;(item : &amp;T) &#123;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Specifying Multiple Trait Bounds with + Syntax</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item :&amp;(<span class="keyword">impl</span> Summary + Display)) &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T : Summary + Display&gt; (item: &amp;T) &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Clearer Trait bounds with where clauses</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; <span class="built_in">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure></li>
<li><p>Returning types that implement traits</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_summarizable</span></span>() -&gt; <span class="keyword">impl</span> Summary &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>Attention, you can only use <code>impl Trait</code> if you‘re returning a sigle type.</p>
</li>
<li><p>Using Trait Bounds to Conditionally Implement Methods</p>
<p>We can also conditinally implement a trait for any type that implements another trait.Implementations of a trait on any type that satisfies the trait bounds are called <em>blanket implementations</em>.</p>
</li>
</ol>
</li>
<li><p>Validating references with lifetimes</p>
<ol>
<li><p>Preventing dangling references with lifetimes</p>
</li>
<li><p>The Borrow checker</p>
</li>
<li><p>Generic Lifetimes in functions</p>
</li>
<li><p>Lifetime Annotation Syntax</p>
</li>
<li><p>Lifetime Annotations in function signatures</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> longest&lt;’a&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,y: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> x,len() &gt; y.len() &#123;</span><br><span class="line">    x</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The function signature now tells Rust that for some lifetime <code>&#39;a</code>, the function takes two parameters, both of which are string slices that live at least as long as lifetime <code>&#39;a</code>. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime <code>&#39;a</code>. In practice, it means that the lifetime of the reference returned by the <code>longest</code> function is the same as the smaller of the lifetimes of the references passed in. These constraints are what we want Rust to enforce. Remember, when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. Rather, we’re specifying that the borrow checker should reject any values that don’t adhere to these constraints. Note that the <code>longest</code>function doesn’t need to know exactly how long <code>x</code> and <code>y</code> will live, only that some scope can be substituted for <code>&#39;a</code> that will satisfy this signature.</p>
</li>
<li><p>Thinking in terms of lifetimes</p>
</li>
<li><p>Lifetime annotations in struct dedinitions</p>
<p>We have only defined structs to hold owned types.It is possible for structs to hold references, but in that case we would need to add a lifetime annotation on every reference in the struct’s definition.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> novel = <span class="built_in">String</span>::from(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> first_sentence = novel.split(<span class="string">&#x27;.&#x27;</span>).next().expect(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> i = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This annotation means an instance of ImportantExcerpt can not outlive the reference it holds in its part field.</p>
</li>
<li><p>Lifetime Elision</p>
<p>Lifetimes on function or method parameters are called <em>input lifetimes</em>, and lifetimes on return values are called <em>output lifetimes</em>.</p>
<p>Three rules for lifetime:</p>
<ol>
<li>Each parameter that is a reference gets its own lifetime parameter</li>
<li>If there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters</li>
<li>There are multiple input lifetime parameters, but one of them is <code>&amp;selft</code> or <code>&amp;mut self</code> because this is a method, the lifetime of <code>self</code> is assigned to all output lifetime parameters.</li>
</ol>
</li>
<li><p>Lifetime Annotations in Method Definitions</p>
<p>Lifetime names for struct fields always need to be declared after the <code>impl</code> keyword and then used after the struct’s name, because those lifetimes are part of the struct’s type</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">level</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>The static lifetime</p>
<p>Static reference can live for the entire duration of the program</p>
<p><code>let s: &amp;&#39;static str = &quot;I have a static lifetime&quot;&#39;</code></p>
</li>
<li><p>Generic Type parameters, Trait Bounds, and lifetimes Together</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = longest_with_an_announcement(</span><br><span class="line">        string1.as_str(),</span><br><span class="line">        string2,</span><br><span class="line">        <span class="string">&quot;Today is someone&#x27;s birthday!&quot;</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest_with_an_announcement</span></span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">    y: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">    ann: T,</span><br><span class="line">) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>Writing Automated Tests</p>
<ol>
<li><p>How to Write Tests？</p>
<ol>
<li><p>Checking resutls with the <code>assert!</code> Macro</p>
<p>We give the <code>!assert</code> Marco an argument that avaluates to a Boolean,if the value is true, assert! does nothing an the test passes,if the value is false, the assert! Macro calls the panic! macro.</p>
</li>
<li><p>Testing equality with the <code>assert_eq!</code> And <code>assert_ne!</code> marcos</p>
</li>
<li><p>Adding custom failure messages</p>
</li>
<li><p>Checking for panics with <code>should_panic</code></p>
<p>To our test function, this attribute makes a test pass if the code inside the function panics, thet test will fial if the code inside the function doesn’t panic.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Guess</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Guess &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(value: <span class="built_in">i32</span>) -&gt; Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;&#125;.&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greater_than_100</span></span>() &#123;</span><br><span class="line">        Guess::new(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Test orgnization</p>
<p>The <code>#[cfg(test)]</code> annotation on the tests module tells Rust to compile and run the test code only when you run <code>cargo test</code>, not when you run <code>cargo build</code>. </p>
</li>
</ol>
</li>
<li><p>Function Language features:iterators and closures</p>
<ol>
<li><p>Closures:aninymous functions that can capture their environment</p>
<ol>
<li><p>To define a closure, we start with a pair of vertical pipes<code>|</code>，after the parameters,we place curly brackets that hold the body of the closure,which is optinal if the closure body is a sigle expression.</p>
</li>
<li><p>Closures don’t require  you to annotate the types of the parameters or the return value like functions do.The compiler is reliably able to infer the types if the paramaters and the return value, similar to how it’s able to infer types of most variables.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span>  <span class="title">add_one_v1</span>   </span>(x: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> add_one_v2 = |x: <span class="built_in">u32</span>| -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> add_one_v3 = |x|             &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> add_one_v4 = |x|               x + <span class="number">1</span>  ;</span><br></pre></td></tr></table></figure></li>
<li><p>Once user calling a closure, compiler refers the type of closure paramaters, and types are then locked into the closure,and we get a type error if we try to use a difference type with the same closure.</p>
</li>
<li><p>Cloures have an additional capability that functions don’t have: they can capture their environment and access variables from the scope in which they’re defined.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">equal_to_x</span></span>(z: <span class="built_in">i32</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        z == x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(equal_to_x(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Closures can capture value from their environment in three ways,which directly map to the three ways a function can take a parameter:taking ownership, borrowing mutably, and borrowing immutably.These are encoded in three <code>Fn</code> traits as follows:</p>
<ul>
<li><p><code>FnOnce</code>:consumes the variables it captures from its enclosing scope, known as the closure’s environment.To consume the captured variables, the closure must take ownership of these variables and move them into the closure when it is defined.The once part of the name represents the fact that the closure can’t take ownership of the same variables more than once, so it can be called only once.</p>
</li>
<li><p><code>FnMut</code>:can change the environment because it mutably borrows values.</p>
</li>
<li><p><code>Fn</code>:borrows values from the environment immutably</p>
</li>
</ul>
<p>When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement <code>FnOnce</code> because they can all be called at least once. Closures that don’t move the captured variables also implement <code>FnMut</code>, and closures that don’t need mutable access to the captured variables also implement <code>Fn</code>. In Listing 13-12, the <code>equal_to_x</code>closure borrows <code>x</code> immutably (so <code>equal_to_x</code> has the <code>Fn</code> trait) because the body of the closure only needs to read the value in <code>x</code>.</p>
<p>If you want to force the closure to take ownership of the values it uses in the environment, you can use the <code>move</code> keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it’s owned by the new thread.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> equal_to_x = <span class="keyword">move</span> |z| z == x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;can&#x27;t use x here: &#123;:?&#125;&quot;</span>, x);</span><br><span class="line">  <span class="comment">// move this line, the code can be compiled</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(equal_to_x(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Processing a series of items with iterators</p>
<ol>
<li><p>Iterators are lazy</p>
</li>
<li><p>The Iterator trait an next method</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// methods with default implementations elided</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The valuies we get from the calls to <code>next</code> are immutable references to the values in the vector.The <code>iter</code>  method produces an iterator over immutable references.If we want to create an iterator that takes ownership of vector and returns owned values, we can call <code>into_iter</code> instead of <code>iter</code>.Similarly， if we want to iterate over mutable references, we can call <code>iter_mut</code> instead of <code>iter</code>.</p>
</li>
<li><p>Methods that consume the iterator</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">iterator_sum</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">let</span> v1_iter = v1.iter();</span><br><span class="line">  <span class="keyword">let</span> total:<span class="built_in">i32</span> = v1.iter.sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Methods that produce other iterators</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> v2: <span class="built_in">Vec</span>&lt;_&gt; = v1.iter().map(|x| x+<span class="number">1</span>).collect();</span><br></pre></td></tr></table></figure>

<p>We use collect method to consume the iterator because iterators are lazy, we collect the results of iterating over the iterator that’s returned from the call to <code>map</code> into a vector.</p>
</li>
<li><p>Using closures that capture their environment</p>
<p><code>filter</code> iterator adaptor:The <code>filter</code> method on an iterator takes a closure that takes each item from the iterator and returns a boolean.If the closure returns true, the value will be included in the iterator produced by filter, if the closure returns false, the value won’t be included in the resulting iterator.</p>
<p><code>shoes.into_iter().filter(|s| s.size == shoe_size).collect()</code></p>
</li>
<li><p>Comparing performance:Loops and iterators</p>
<p>Closures and iterators are Rust features inspired by functional programming language ideas. They contribute to Rust’s capability to clearly express high-level ideas at low-level performance. The implementations of closures and iterators are such that runtime performance is not affected. This is part of Rust’s goal to strive to provide zero-cost abstractions.</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>More about Cargo and Crates.io (Not covered)</p>
</li>
<li><p>Smart Pointers</p>
<ol>
<li><p>In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that the reference are pointers that only borrow data; in contrast, in many cases, smart pointers own the data they point to.</p>
</li>
<li><p>Using Box<T> to point to data on the heap</p>
<p>Boxes allow you to store data on the heap rather than the stack, what remains on the stack is the pointer to the heap data.</p>
<ol>
<li>Enabling recursive types with boxes</li>
</ol>
</li>
<li><p>Treating smart pointers like regular references with the Deref trait</p>
<p>Implementing the <code>Deref</code> trait allows you to customize the behavior of the <em>dereference operator</em>, <code>*</code>(as opposed to the multiplication or glob operator). By implementing <code>Deref</code> in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</p>
<p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references.The <code>deref</code> method gives the compiller the ability to take value of any type that implements <code>Deref</code> and call the <code>deref</code> method to get a <code>&amp;</code> reference that it knows how to dereference.</p>
</li>
<li><p>Implicit deref coercions with functions and methods</p>
<p><em>Deref coercion</em> is a convenience that Rust performs on arguments to functions and methods. Deref coercion works only on types that implement the <code>Deref</code> trait. Deref coercion converts such a type into a reference to another type. For example, deref coercion can convert <code>&amp;String</code> to <code>&amp;str</code> because <code>String</code> implements the <code>Deref</code> trait such that it returns <code>&amp;str</code>. Deref coercion happens automatically when we pass a reference to a particular type’s value as an argument to a function or method that doesn’t match the parameter type in the function or method definition. A sequence of calls to the <code>deref</code> method converts the type we provided into the type the parameter needs.</p>
<p>Deref coercion was added to Rust so that programmers writing function and method calls don’t need to add as many explicit references and dereferences with <code>&amp;</code> and <code>*</code>. The deref coercion feature also lets us write more code that can work for either references or smart pointers.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(name: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    hello(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>with rust deref coercions, the code is equal to</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    hello(&amp;(*m)[..]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>How deref coercion interacts with mutability</p>
<p>rust does deref coercion when it finds types and trait implementions in three cases:</p>
<ul>
<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
</li>
<li><p>Running code on cleanup with the drop trait</p>
<p>The second trait important to the smart pointer pattern is <code>Drop</code>, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the <code>Drop</code>trait on any type, and the code you specify can be used to release resources like files or network connections. We’re introducing <code>Drop</code> in the context of smart pointers because the functionality of the <code>Drop</code> trait is almost always used when implementing a smart pointer. For example, when a <code>Box&lt;T&gt;</code> is dropped it will deallocate the space on the heap that the box points to.</p>
<p>Programmer do not have to free memory in code when finishing using an instance of a data type.In rust, when a value goes out of scope,the compiler will insert ‘free memory’ code automatically.</p>
<p>Most of time, programmers do not have to drop memory of one instance before the scope ending, if have to, rust provides a method <code>std::mem::drop</code> to do this.</p>
</li>
<li><p>Rc<T>, the reference counted smart pointer</p>
<p>To enable multiple ownership, Rust has a type called <code>Rc&lt;T&gt;</code>, which is an abbreviation for <em>reference counting</em>. The <code>Rc&lt;T&gt;</code> type keeps track of the number of references to a value to determine whether or not the value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</p>
<p>We use the <code>Rc&lt;T&gt;</code> type when we want to allocate some data on the heap for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data’s owner, and the normal ownership rules enforced at compile time would take effect.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RefCell<T> and the interior mutability pattern </p>
<p>……..(TODO)</p>
<p>reference:<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">https://doc.rust-lang.org/book/ch15-05-interior-mutability.html</a></p>
</li>
</ol>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/04/Distributed-protocol/" rel="prev" title="Distributed protocol">
      <i class="fa fa-chevron-left"></i> Distributed protocol
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/04/Dkey-Array-Object-update/" rel="next" title="Dkey-Array Object update">
      Dkey-Array Object update <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Go"><span class="nav-number">1.</span> <span class="nav-text">Go</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Cargo-Book"><span class="nav-number">2.</span> <span class="nav-text">The Cargo Book</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Rust-Programming-Language"><span class="nav-number">3.</span> <span class="nav-text">The Rust Programming Language</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Javie Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Javie Chen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
