<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Saturn">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Saturn">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Javie Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Saturn</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Saturn</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The devil is in the details.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/01/Daos-2-phase-commit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saturn">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/01/Daos-2-phase-commit/" class="post-title-link" itemprop="url">Daos-2-phase-commit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-01 16:03:03" itemprop="dateCreated datePublished" datetime="2023-04-01T16:03:03+08:00">2023-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-17 16:04:43" itemprop="dateModified" datetime="2023-04-17T16:04:43+08:00">2023-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/knowledge/" itemprop="url" rel="index"><span itemprop="name">knowledge</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Two-phase-Commit"><a href="#Two-phase-Commit" class="headerlink" title="Two-phase Commit"></a>Two-phase Commit</h1><h2 id="经典的2PC"><a href="#经典的2PC" class="headerlink" title="经典的2PC"></a>经典的2PC</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">client            coordinator           slave              slave</span><br><span class="line">  |     txn           |                  |                  |</span><br><span class="line">  | -----------------&gt;|                  |                  |</span><br><span class="line">  |                   |-----prepare-----&gt;|                  |</span><br><span class="line">  |                   |-----prepare------------------------&gt;|</span><br><span class="line">  |                   |                  |                  |</span><br><span class="line">  |                   |&lt;--------OK-------|                  |  </span><br><span class="line">  |                   |&lt;--------OK--------------------------|</span><br><span class="line">  |                   |                  |                  |</span><br><span class="line">  |                   |-----commit -----&gt;|                  |</span><br><span class="line">  |                   |-----commit ------------------------&gt;|</span><br><span class="line">  |                   |                  |                  |</span><br><span class="line">  |                   |&lt;-----OK----------|                  |</span><br><span class="line">  |                   |&lt;-----OK-----------------------------|</span><br><span class="line">  |&lt;-----reply--------|                  |                  |</span><br></pre></td></tr></table></figure>

<h3 id="经典2pc中的Coordinator侧的状态转移："><a href="#经典2pc中的Coordinator侧的状态转移：" class="headerlink" title="经典2pc中的Coordinator侧的状态转移："></a>经典2pc中的Coordinator侧的状态转移：</h3><ol>
<li>接受request执行Operation发送prepared message给所有的参与者，initiated</li>
<li>接受到所有participants的positive reply，prepared</li>
<li>发送committ请求给所有的participants, commiting</li>
<li>接受到所有participants的positive reply，committed</li>
</ol>
<h3 id="Redo-amp-undo-log在2pc协议中的作用："><a href="#Redo-amp-undo-log在2pc协议中的作用：" class="headerlink" title="Redo &amp; undo log在2pc协议中的作用："></a>Redo &amp; undo log在2pc协议中的作用：</h3><ol>
<li>coordinator在Commit Phase发送commit给所有participants之前记录redo log，如果在改动落盘之前coordinator宕机，可以从redo log恢复。</li>
<li>undo log保证了在Prepared Phase中，如果有slave回复不可提交，可用来abort transaction</li>
<li>redo log用来容灾，undo log用来恢复事务执行之前的状态。</li>
</ol>
<h3 id="Redo-amp-undo-log在2pc中写入的时机："><a href="#Redo-amp-undo-log在2pc中写入的时机：" class="headerlink" title="Redo &amp; undo log在2pc中写入的时机："></a>Redo &amp; undo log在2pc中写入的时机：</h3><ol>
<li>Coordinator:<ol>
<li>Prepare Phase, 执行Operation之前记录redolog/undolog</li>
<li>在提交事务之前，记录transaction到redolog</li>
</ol>
</li>
<li>Non-Coordinator:<ol>
<li>执行Operation之前记录redolog/undolog</li>
<li>回复positive Response之后将transaction记录到redolog</li>
</ol>
</li>
</ol>
<h3 id="Classical-2PC的劣势："><a href="#Classical-2PC的劣势：" class="headerlink" title="Classical 2PC的劣势："></a>Classical 2PC的劣势：</h3><ol>
<li>阻塞协议，所有的参与者都需要等待coordinator的决策，影响latency</li>
<li>协调者单点失败：如果coordinator失效，协议无法继续。</li>
<li>级联回滚：先到的事务回滚会导致后续的事务级联回滚</li>
<li>参与者单点失败：参与者的失败或者超时，影响latency</li>
<li>大量的网络通信开销：两个阶段的网络开销随着节点数的增多线性增长</li>
</ol>
<h2 id="DAOS-asynchronous-2PC"><a href="#DAOS-asynchronous-2PC" class="headerlink" title="DAOS asynchronous 2PC"></a>DAOS asynchronous 2PC</h2><h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h3><ol>
<li>client提交txn</li>
<li>coordinator接受，本地执行Operation，发送给其他participants</li>
<li>接受到其他participants的positive Response，标记事务为committable，batch住事务号</li>
<li>batch的事务号达到阈值，发送二阶段的commit rpc</li>
<li>coordinator和slave提交事务。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">client            coordinator           slave              slave</span><br><span class="line">  |     txn           |                  |                  |</span><br><span class="line">  | -----------------&gt;|                  |                  |</span><br><span class="line">  |                   |-----prepare-----&gt;|                  |</span><br><span class="line">  |                   |-----prepare------------------------&gt;|</span><br><span class="line">  |                   |                  |                  |</span><br><span class="line">  |                   |&lt;--------OK-------|                  |  </span><br><span class="line">  |                   |&lt;--------OK--------------------------|</span><br><span class="line">  |&lt;-------reply------|                  |                  |</span><br><span class="line">  ...              time elaps           ...                ...</span><br><span class="line">  |                   |                  |                  |</span><br><span class="line">  |                meet batch            |                  |</span><br><span class="line">  |                   |--commit batch---&gt;|                  |</span><br><span class="line">  |                   |--commit batch----------------------&gt;|</span><br><span class="line">  |                   |                  |                  |</span><br><span class="line">  |                   |&lt;-----OK----------|                  |</span><br><span class="line">  |                   |&lt;-----OK-----------------------------|</span><br><span class="line">  |                   |                  |                  |</span><br></pre></td></tr></table></figure>

<h3 id="相对于classical-2PC的改动点"><a href="#相对于classical-2PC的改动点" class="headerlink" title="相对于classical 2PC的改动点"></a>相对于classical 2PC的改动点</h3><ol>
<li>classical 2PC中coordinator在发送prepare之前写redo/undo 日志，A2PC中是发送之后写日志</li>
<li>classical 2PC中coordinator需要再二阶段执行完成后才能回复客户端，A2PC中一阶段完成即可回复</li>
<li>classical 2PC中二阶段的txn都是one by one的处理，A2PC中针对同一Redundancy Group的txns做了batch。</li>
</ol>
<h3 id="如何处理改动带来的一致性风险"><a href="#如何处理改动带来的一致性风险" class="headerlink" title="如何处理改动带来的一致性风险"></a>如何处理改动带来的一致性风险</h3><ol>
<li>coordinator在一阶段发送rpc后才写日志，假如在写日志之前宕机，可能会有两种场景：<ol>
<li>Prepared消息全部发送到了参与者节点<ol>
<li>新Coordinator必有这条日志，全部参与者可以提交，Resync协议保证此日志提交</li>
<li>新Coordinator必有这条日志，至少一个参与者abort，Resync协议保证此日志回滚</li>
</ol>
</li>
<li>Prepared消息部分发送到了参与者节点：<ol>
<li>新Coordinator有这条日志，由于部分参与者未收到这条Prepare，Resync协议保证此日志回滚</li>
<li>新Coordinator没有这条日志，不会尝试abort或者commit，客户端Timeout，对此日志在新的Coordinator上发起重试。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="如何解决batch机制引入的inconsistency"><a href="#如何解决batch机制引入的inconsistency" class="headerlink" title="如何解决batch机制引入的inconsistency"></a>如何解决batch机制引入的inconsistency</h3><p>由于batch机制，Coordinator状态为committable的状态的事务，在participants端可能是prepared的状态，participants端的读写请求如何处理？</p>
<ol>
<li>写请求：统一由leader端处理</li>
<li>读请求：通过redirect到leader端处理或者依赖于refresh流程同步后再处理</li>
</ol>
<h3 id="新的Coordinator如何产生"><a href="#新的Coordinator如何产生" class="headerlink" title="新的Coordinator如何产生"></a>新的Coordinator如何产生</h3><ol>
<li>通过伪哈希算法，在剩余的存活参与者中选出，因为参与者携带了未决事务的信息。</li>
<li>不能选择Fallback节点作为新的Coordinator，因为FallBack节点没有事务信息，无法执行Resync流程。</li>
</ol>
<h3 id="旧的Coordinator如何处理"><a href="#旧的Coordinator如何处理" class="headerlink" title="旧的Coordinator如何处理"></a>旧的Coordinator如何处理</h3><ol>
<li>暂时下线：在重新上线后，依赖rebuild协议同步事务信息</li>
<li>永久下线：在FallBack上rebuild事务信息</li>
</ol>
<h3 id="Resync"><a href="#Resync" class="headerlink" title="Resync"></a>Resync</h3><h4 id="principals"><a href="#principals" class="headerlink" title="principals"></a>principals</h4><ol>
<li>存活的节点，有任何节点针对此txn提交为abort或者没有voted log，则此txn回滚</li>
<li>失联的节点abort了当前事务且至少和一个存活节点确认了abort信息，此txn回滚</li>
<li>存活的节点对txn1标记为prepared，失联的leader对txn1标记为abort，txn1可以提交。</li>
</ol>
<h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h4><ol>
<li>client发送txn</li>
<li>leader接受，replicate，将log持久化</li>
<li>slave接受，将log持久化，处理txn</li>
<li>slave回复，leader接受</li>
<li>leader汇总，根据汇总结果abort或者commit</li>
<li>leader回复client</li>
<li>leader cache txn，等到batch满发送给slaves</li>
<li>slave做相应的处理。</li>
</ol>
<h4 id="极端例子"><a href="#极端例子" class="headerlink" title="极端例子"></a>极端例子</h4><img src="/2023/04/01/Daos-2-phase-commit/image-20230329105615285.png" alt="image-20230329105615285" style="zoom: 33%;">

<ol>
<li>T0到达client比T1早，T0和T1之间是冲突关系</li>
<li>T0在Coordinator执行成功，T1在Coordinator执行失败</li>
<li>T1的Prepare rpc已经先于T0到达了所有的参与者，且所有参阅者回复positive</li>
<li>协调者在收到T1的回复之前crash，无法发送abort T1</li>
<li>在Resync流程中，T1被commit，T0超时，因为crash之前并没有回复客户端，因此不影响一致性</li>
</ol>
<h3 id="Refresh"><a href="#Refresh" class="headerlink" title="Refresh"></a>Refresh</h3><h4 id="流程：-1"><a href="#流程：-1" class="headerlink" title="流程："></a>流程：</h4><ol>
<li>获取需要Refresh的dtx列表</li>
<li>遍历每个dtx</li>
<li>查找dtx leader</li>
<li>如果自己是leader，跳过当前dtx的检查</li>
<li>初始化</li>
<li>向leader发送RPC进行事务状态同步</li>
<li>根据同步的事务结果做相应的处理</li>
</ol>
<h1 id="Classical-2PC-amp-asynchronous-2PC对比："><a href="#Classical-2PC-amp-asynchronous-2PC对比：" class="headerlink" title="Classical 2PC &amp; asynchronous 2PC对比："></a>Classical 2PC &amp; asynchronous 2PC对比：</h1><h3 id="asynchronous-2PC解决了哪些问题："><a href="#asynchronous-2PC解决了哪些问题：" class="headerlink" title="asynchronous 2PC解决了哪些问题："></a>asynchronous 2PC解决了哪些问题：</h3><ol>
<li>Prepare阶段结束后就响应客户端，缓解了阻塞问题，至少节省了一个RTT的时间</li>
<li>Prepare阶段，不写日志就发rpc，至少节省了一次落盘的时间</li>
<li>参与者失败，通过SWIM协议在有限时间内发现并启用fallback，协调者失败，通过resync决策事务状态，一定程度上解决了了协调者和参与者的失败问题</li>
<li>Commit阶段通过batch成组提交，减小网络通信的开销</li>
<li>级联回滚依然存在</li>
</ol>
<h3 id="asynchronous-2PC可能带来那些问题："><a href="#asynchronous-2PC可能带来那些问题：" class="headerlink" title="asynchronous 2PC可能带来那些问题："></a>asynchronous 2PC可能带来那些问题：</h3><ol>
<li>asynchronous 2PC不是单独可用的协议，需要SWIM协议配合</li>
<li>引入resync的过程，增加了复杂性</li>
<li>batch提交引入了额外的复杂性，传统的2PC中，各节点的状态一致，任何节点都可以处理读写请求。在a2PC中，leader会将已经提交的事务的二阶段batch，因此slave节点上的事务状态仍然是Prepared，需要同步信息或者只由leader处理。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="client端："><a href="#client端：" class="headerlink" title="client端："></a>client端：</h2><h3 id="伪代码："><a href="#伪代码：" class="headerlink" title="伪代码："></a>伪代码：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">daos_handle_t tx = DAOS_TX_NONE;</span><br><span class="line">int           rc;</span><br><span class="line"></span><br><span class="line">/* allocate transaction */</span><br><span class="line">rc = daos_tx_open(dfs-&gt;coh, &amp;th, 0, NULL);</span><br><span class="line">if (rc)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">restart:</span><br><span class="line">	/* execute operations under the same transaction */</span><br><span class="line">	rc = daos_obj_fetch(..., th);</span><br><span class="line">	...</span><br><span class="line">	rc = daos_obj_update(..., th);</span><br><span class="line">	...</span><br><span class="line">	if (rc) &#123;</span><br><span class="line">		rc = daos_tx_abort(th, NULL);</span><br><span class="line">		/* either goto restart or exit */</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rc = daos_tx_commit(th, NULL);</span><br><span class="line">	if (rc) &#123;</span><br><span class="line">		if (rc == -DER_TX_RESTART) &#123;</span><br><span class="line">			/* conflict with another transaction, try again */</span><br><span class="line">			rc = daos_tx_restart(th, NULL);</span><br><span class="line">			goto restart;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">/* free up all the resources allocated for the transaction */</span><br><span class="line">rc = daos_tx_close(th, NULL);</span><br></pre></td></tr></table></figure>



<h3 id="关键调用点"><a href="#关键调用点" class="headerlink" title="关键调用点"></a>关键调用点</h3><h4 id="构造task"><a href="#构造task" class="headerlink" title="构造task"></a>构造task</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">daos_tx_commit(daos_handle_t th, daos_event_t *ev)</span><br></pre></td></tr></table></figure>

<h4 id="检查txn的状态是否满足提交条件"><a href="#检查txn的状态是否满足提交条件" class="headerlink" title="检查txn的状态是否满足提交条件"></a>检查txn的状态是否满足提交条件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">dc_tx_commit(tse_task_t *task)</span><br></pre></td></tr></table></figure>

<h4 id="发送rpc"><a href="#发送rpc" class="headerlink" title="发送rpc"></a>发送rpc</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 检查pool_map_version是够匹配</span><br><span class="line">// dc_tx_commit_prepare,比较复杂，取第一个target作为leader</span><br><span class="line">// 注册回调dc_tx_commit_cb</span><br><span class="line">// 修改事务状态为TX_COMMITTING</span><br><span class="line">// 构造rpc并发送rpc</span><br><span class="line">static int</span><br><span class="line">dc_tx_commit_trigger(tse_task_t *task, struct dc_tx *tx, daos_tx_commit_t *args)</span><br></pre></td></tr></table></figure>





<h2 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h2><h3 id="关键调用点-1"><a href="#关键调用点-1" class="headerlink" title="关键调用点"></a>关键调用点</h3><h4 id="检查冲突，分配内存，为每个子txn分配执行函数"><a href="#检查冲突，分配内存，为每个子txn分配执行函数" class="headerlink" title="检查冲突，分配内存，为每个子txn分配执行函数"></a>检查冲突，分配内存，为每个子txn分配执行函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">ds_obj_cpd_handler(crt_rpc_t *rpc)</span><br></pre></td></tr></table></figure>

<h4 id="执行Server端的leader操作"><a href="#执行Server端的leader操作" class="headerlink" title="执行Server端的leader操作"></a>执行Server端的leader操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 执行Server端的leader操作，设置内存栅栏</span><br><span class="line">// 为每个txn的每个tgt执行obj_obj_dtx_leader</span><br><span class="line">static void</span><br><span class="line">ds_obj_dtx_leader_ult(void *arg)</span><br></pre></td></tr></table></figure>

<h4 id="在txn的每个tgt上执行Operation"><a href="#在txn的每个tgt上执行Operation" class="headerlink" title="在txn的每个tgt上执行Operation"></a>在txn的每个tgt上执行Operation</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">ds_obj_dtx_leader(struct daos_cpd_args *dca)</span><br></pre></td></tr></table></figure>

<h4 id="分batch执行"><a href="#分batch执行" class="headerlink" title="分batch执行"></a>分batch执行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">dtx_leader_exec_ops(struct dtx_leader_handle *dlh, dtx_sub_func_t func,</span><br><span class="line">		    dtx_agg_cb_t agg_cb, int allow_failure, void *func_arg)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="leader上的每个tgt执行到的函数"><a href="#leader上的每个tgt执行到的函数" class="headerlink" title="leader上的每个tgt执行到的函数"></a>leader上的每个tgt执行到的函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">obj_obj_dtx_leader(struct dtx_leader_handle *dlh, void *arg, int idx,</span><br><span class="line">		   dtx_sub_comp_cb_t comp_cb)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">ds_cpd_handle_one_wrap(crt_rpc_t *rpc, struct daos_cpd_sub_head *dcsh,</span><br><span class="line">		       struct daos_cpd_disp_ent *dcde, struct daos_cpd_sub_req *dcsrs,</span><br><span class="line">		       struct obj_io_context *ioc, struct dtx_handle *dth)</span><br></pre></td></tr></table></figure>

<h4 id="leader-和-slave上都会执行到的读写接口"><a href="#leader-和-slave上都会执行到的读写接口" class="headerlink" title="leader 和 slave上都会执行到的读写接口"></a>leader 和 slave上都会执行到的读写接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// leader 和 slave上都会执行到的操作</span><br><span class="line">// 执行时机的写入操作，更新ts，此函数比较复杂</span><br><span class="line">static int</span><br><span class="line">ds_cpd_handle_one(crt_rpc_t *rpc, struct daos_cpd_sub_head *dcsh,</span><br><span class="line">		  struct daos_cpd_disp_ent *dcde,</span><br><span class="line">		  struct daos_cpd_sub_req *dcsrs,</span><br><span class="line">		  struct obj_io_context *ioc, struct dtx_handle *dth)</span><br><span class="line">/* Locally process the operations belong to one DTX.</span><br><span class="line"> * Common logic, shared by both leader and non-leader.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h4 id="2nd-phase"><a href="#2nd-phase" class="headerlink" title="2nd phase"></a>2nd phase</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">dtx_leader_end(struct dtx_leader_handle *dlh, struct ds_cont_hdl *coh, int result)</span><br></pre></td></tr></table></figure>







<h2 id="Resync关键调用点"><a href="#Resync关键调用点" class="headerlink" title="Resync关键调用点"></a>Resync关键调用点</h2><h4 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 构造Resync的txn列表</span><br><span class="line">int</span><br><span class="line">dtx_resync(daos_handle_t po_hdl, uuid_t po_uuid, uuid_t co_uuid, uint32_t ver, bool block)</span><br></pre></td></tr></table></figure>

<h4 id="one-by-one的检查"><a href="#one-by-one的检查" class="headerlink" title="one by one的检查"></a>one by one的检查</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 在这个function中one by one的检查</span><br><span class="line">// 如果返回的结果是DSHR_NEED_COMMIT，batch住txn，等待提交</span><br><span class="line">// 否则不会提交</span><br><span class="line">static int</span><br><span class="line">dtx_status_handle(struct dtx_resync_args *dra)</span><br></pre></td></tr></table></figure>

<h4 id="检查某一个entry"><a href="#检查某一个entry" class="headerlink" title="检查某一个entry"></a>检查某一个entry</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 检查某一个entry</span><br><span class="line">// 返回commit，则返给上层提交</span><br><span class="line">int</span><br><span class="line">dtx_status_handle_one(struct ds_cont_child *cont, struct dtx_entry *dte,</span><br><span class="line">		      daos_epoch_t epoch, int *tgt_array, int *err)</span><br></pre></td></tr></table></figure>

<h4 id="发送rpc同步Commit信息"><a href="#发送rpc同步Commit信息" class="headerlink" title="发送rpc同步Commit信息"></a>发送rpc同步Commit信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">dtx_check(struct ds_cont_child *cont, struct dtx_entry *dte, daos_epoch_t epoch)</span><br></pre></td></tr></table></figure>

<h4 id="DTX-Check的逻辑"><a href="#DTX-Check的逻辑" class="headerlink" title="DTX Check的逻辑"></a>DTX Check的逻辑</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">dtx_handler(crt_rpc_t *rpc)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="rpc处理"><a href="#rpc处理" class="headerlink" title="rpc处理"></a>rpc处理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">dtx_rpc_internal(struct dtx_common_args *dca)</span><br></pre></td></tr></table></figure>

<h4 id="rpc发送"><a href="#rpc发送" class="headerlink" title="rpc发送"></a>rpc发送</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">dtx_req_list_send(struct dtx_common_args *dca, daos_epoch_t epoch, int len)</span><br></pre></td></tr></table></figure>

<h4 id="回调汇总"><a href="#回调汇总" class="headerlink" title="回调汇总"></a>回调汇总</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 所有peers检查后的结果汇总回调</span><br><span class="line">// Resync principals</span><br><span class="line">static void</span><br><span class="line">dtx_req_list_cb(void **args)</span><br></pre></td></tr></table></figure>



<h2 id="Refresh关键调用点"><a href="#Refresh关键调用点" class="headerlink" title="Refresh关键调用点"></a>Refresh关键调用点</h2><h3 id="server-A"><a href="#server-A" class="headerlink" title="server A"></a>server A</h3><h4 id="触发refresh"><a href="#触发refresh" class="headerlink" title="触发refresh"></a>触发refresh</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">dtx_refresh_internal(struct ds_cont_child *cont, int *check_count,</span><br><span class="line">		     d_list_t *check_list, d_list_t *cmt_list,</span><br><span class="line">		     d_list_t *abt_list, d_list_t *act_list, bool failout)</span><br><span class="line">// 删选出leader不是当前节点的dtx列表</span><br></pre></td></tr></table></figure>

<h4 id="准备rpc并发送给Leader"><a href="#准备rpc并发送给Leader" class="headerlink" title="准备rpc并发送给Leader"></a>准备rpc并发送给Leader</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 为leader不是当前节点的所有dtx发送rpc</span><br><span class="line">rc = dtx_rpc_prep(cont, &amp;head, NULL, len, DTX_REFRESH, 0,</span><br><span class="line">				  cmt_list, abt_list, act_list, &amp;dca);</span><br><span class="line">rc = dtx_rpc_post(&amp;dca, rc);</span><br></pre></td></tr></table></figure>

<h4 id="处理leader不是当前节点的所有dtx的检查结果"><a href="#处理leader不是当前节点的所有dtx的检查结果" class="headerlink" title="处理leader不是当前节点的所有dtx的检查结果"></a>处理leader不是当前节点的所有dtx的检查结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d_list_for_each_entry_safe(dsp, tmp, cmt_list, dsp_link) // 处理可提交的事务</span><br><span class="line">d_list_for_each_entry_safe(dsp, tmp, abt_list, dsp_link) // 处理可bort的事务</span><br><span class="line">d_list_for_each_entry_safe(dsp, tmp, act_list, dsp_link) // 处理uncertain和inprogress的事务</span><br></pre></td></tr></table></figure>

<h4 id="遍历处理leader即为当前节点的每个dtx"><a href="#遍历处理leader即为当前节点的每个dtx" class="headerlink" title="遍历处理leader即为当前节点的每个dtx"></a>遍历处理leader即为当前节点的每个dtx</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d_list_for_each_entry_safe(dsp, tmp, &amp;self, dsp_link)</span><br></pre></td></tr></table></figure>

<h4 id="为每个dtx做检查"><a href="#为每个dtx做检查" class="headerlink" title="为每个dtx做检查"></a>为每个dtx做检查</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">dtx_status_handle_one(struct ds_cont_child *cont, struct dtx_entry *dte,</span><br><span class="line">		      daos_epoch_t epoch, int *tgt_array, int *err)</span><br><span class="line">// 根据检查返回的结果做相应的处理</span><br></pre></td></tr></table></figure>



<h3 id="Leader端"><a href="#Leader端" class="headerlink" title="Leader端"></a>Leader端</h3><h4 id="处理refresh-rpc"><a href="#处理refresh-rpc" class="headerlink" title="处理refresh rpc"></a>处理refresh rpc</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">dtx_handler(crt_rpc_t *rpc)</span><br><span class="line">case DTX_REFRESH分支</span><br></pre></td></tr></table></figure>

<h4 id="调用vos来做检查"><a href="#调用vos来做检查" class="headerlink" title="调用vos来做检查"></a>调用vos来做检查</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">vos_dtx_check(daos_handle_t coh, struct dtx_id *dti, daos_epoch_t *epoch,</span><br><span class="line">	      uint32_t *pm_ver, struct dtx_memberships **mbs, struct dtx_cos_key *dck,</span><br><span class="line">	      bool for_refresh)</span><br></pre></td></tr></table></figure>

<p>根据返回结果逐个处理dtx</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol>
<li><p>rebuild结束后才能开始Resync吗？</p>
<p>论文中没有明确提及。</p>
</li>
<li><p>一个事务中会有多个Operation，如果是replication协议，那么为什么≤还要引入两阶段提交？</p>
<p>Daos中的raft只用在pool或者Container service的主从之间同步状态，不用于数据的replication。</p>
</li>
<li><p>classical 2PC中Prepared的语义和a2PC中语义的区别</p>
<p>classical 2PC中，coordinator接收到所有其他participants节点的positive reply后标记事务状态为Prepared</p>
<p>a2PC中，coordinator或者其他节点，只要执行完了事务的operations，即可认为是Prepared状态。</p>
</li>
<li><p>DTE_ORPHAN是如何处理的？</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/29/Daos-mvcc-and-timestamp-ordering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saturn">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/29/Daos-mvcc-and-timestamp-ordering/" class="post-title-link" itemprop="url">Daos-mvcc-and-timestamp-ordering</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-29 15:31:36" itemprop="dateCreated datePublished" datetime="2023-03-29T15:31:36+08:00">2023-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-17 15:58:52" itemprop="dateModified" datetime="2023-04-17T15:58:52+08:00">2023-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/knowledge/" itemprop="url" rel="index"><span itemprop="name">knowledge</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式系统中的时间"><a href="#分布式系统中的时间" class="headerlink" title="分布式系统中的时间"></a>分布式系统中的时间</h1><p>计算机系统中的时间，通过石英振荡器的震动次数来确定。一个石英振荡器的震动频率是32768Hz每秒，计算机电路根据石英晶体的震动次数来确定1s钟。但是石英晶体的震荡次数会因为环境产生误差。</p>
<p>计算机系统中，假设发生了事件A和事件B，如何确认时间A和事件B的先后顺序？</p>
<ol>
<li>单机系统中，时间单调递增，假设时间A先于时间B发生，则一定意味着时间A发生时的时间戳小于事件B</li>
<li>分布式系统中，由于不同机器上的时间存在误差，假设A在机器a上发生，B在机器b上发生，物理上，A在B之前发生，显然不能直接推导出T(A) &lt;T(B),因为A和B在两台不同的机器上获取了时间戳，参考系不一样。</li>
</ol>
<p>物理时钟，包括NTP协议和TrueTime都属于物理时钟，另一种是逻辑时钟，包括Lamport逻辑时钟和向量时钟。这两种时钟有各自的优缺点。物理时钟的优点在于直观，就是真实世界的时间，使用方便，缺点在于无法做到绝对精确，成本相对高一些。逻辑时钟的优点在于可以做到精确的因果关系，缺点在于节点之间需要通信，而且使用上不如物理时钟直观。</p>
<h2 id="Network-Time-Protocol（NTP）"><a href="#Network-Time-Protocol（NTP）" class="headerlink" title="Network Time Protocol（NTP）"></a>Network Time Protocol（NTP）</h2><p>NTP协议的目标是将所有计算机的时间同步到几毫秒误差内。实际上广域网可以达到几十毫秒的误差，局域网误差可以在1毫秒内。</p>
<ol>
<li>客户端A发送NTP消息给服务器B，消息中包含发送时间戳 T1</li>
<li>服务器B收到NTP消息后，将接收时间 T2 写入消息中</li>
<li>服务器B发送该NTP消息给客户端A，发送时间 T3 写入消息中</li>
<li>客户端A收到该NTP消息的时间为 T4</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">         T1    T2`           T3`   T4</span><br><span class="line">A    -----------------------------^-----</span><br><span class="line">          \    |             |    /</span><br><span class="line">           \   |             |   /</span><br><span class="line">            \  |             |  /</span><br><span class="line">             \ |             | /</span><br><span class="line">              \|             |/</span><br><span class="line">B    ----------v-------------------------</span><br><span class="line">               T2            T3</span><br></pre></td></tr></table></figure>

<p>AB之间的网络往返时间RTT(Round Trip Time)：δ = (T4 - T1) - (T3 - T2)</p>
<p>AB之间的时间偏移：θ = ( (T2 - T1) + (T3 - T4) ) / 2</p>
<p>A从发送请求消息到收到响应的时间间隔是 T4 - T1，其中 T3 - T2 是B的处理时间，所以网络往返时间</p>
<p>δ = (T4 - T1) - (T3 - T2)。</p>
<p>假设A和B的时间偏差为θ，那么 T3 - θ = T3`。</p>
<p>T4和T3’的间隔是半个RTT：T4 - T3` = δ / 2</p>
<p>把T3`和δ代入上面这个等式，得到：θ = ( (T2 - T1) + (T3 - T4) ) / 2。</p>
<p>NTP协议在广域网可以达到几十毫秒的误差，局域网误差可以在1毫米内。误差最大的一个原因是发送请求和接收响应这两个阶段的网络时间可能是不一样的。前面我们推导时间偏移公式的时候，假设网络往返发送和接收阶段的时间是一样的，但是实际网络中，这两个阶段走的路由可能是不一样的，所花的时间也可能不一样，计算的时间偏移也不准确，这样就造成了广域网的误差可能达到几十毫秒甚至更高。局域网中因为网络比较稳定，经过的路由器也比较少，所以误差可以到1毫米内。</p>
<h2 id="Lamport逻辑时钟"><a href="#Lamport逻辑时钟" class="headerlink" title="Lamport逻辑时钟"></a>Lamport逻辑时钟</h2><p>通过逻辑时钟，可以刻画分布式系统中事件的因果一致性关系。</p>
<p>局限：</p>
<ol>
<li>无法感知系统外的事件。</li>
<li>由C(a) &lt; C(b)不能推导出a → b，即使知道了两个逻辑时钟值，但却不能确定这两个事件的因果关系。</li>
<li>不能区分事件之间是否并发</li>
<li>不够直观，脱离了物理时间的直观范畴</li>
</ol>
<h2 id="向量时钟"><a href="#向量时钟" class="headerlink" title="向量时钟"></a>向量时钟</h2><p>解决了Lamport逻辑时钟中不能描述时间因果关系的问题</p>
<ol>
<li>不能感知系统外的事件</li>
<li>可以描述时间之间的因果关系</li>
<li>可以区分事件之间的并发关系</li>
<li>不够直观，脱离了物理时间的直观范畴</li>
</ol>
<h2 id="TrueTime"><a href="#TrueTime" class="headerlink" title="TrueTime"></a>TrueTime</h2><p>由谷歌提出，通过高精度的硬件，刻画了相对准确的物理时间。</p>
<h2 id="HLC（Hybrid-Logical-Clocks）"><a href="#HLC（Hybrid-Logical-Clocks）" class="headerlink" title="HLC（Hybrid Logical Clocks）"></a>HLC（<strong>Hybrid Logical Clocks</strong>）</h2><p>(HLC)将物理时钟和逻辑时钟结合起来。</p>
<ol>
<li>需要的空间复杂度有限，不会随着集群规模的增长而增长。</li>
<li>需要满足因果关系。</li>
<li>逻辑时间部分的增长有界。</li>
<li>逻辑时间和真实的物理时间的误差是有边界的。</li>
</ol>
<h2 id="DAOS中的时钟"><a href="#DAOS中的时钟" class="headerlink" title="DAOS中的时钟"></a>DAOS中的时钟</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** Mask for the 18 logical bits */</span><br><span class="line">#define D_HLC_MASK 0x3FFFFULL</span><br></pre></td></tr></table></figure>

<p>18位用于存储逻辑时钟，46位用于存储物理时钟。</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库中的异常行为"><a href="#数据库中的异常行为" class="headerlink" title="数据库中的异常行为"></a>数据库中的异常行为</h2><ol>
<li>脏读</li>
<li>幻读</li>
<li>不可重复读</li>
<li>脏写</li>
<li>丢失更新</li>
</ol>
<h2 id="数据库中的并发控制机制"><a href="#数据库中的并发控制机制" class="headerlink" title="数据库中的并发控制机制"></a>数据库中的并发控制机制</h2><ol>
<li>基于时间的（Time-stamp ordering）</li>
<li>基于提交顺序的（Commitment ordering）</li>
<li>基于串行化图测试验证的（Serialization graph testing）</li>
<li>基于锁的（Locking）</li>
</ol>
<h2 id="Time-stamp-ordering"><a href="#Time-stamp-ordering" class="headerlink" title="Time-stamp ordering"></a>Time-stamp ordering</h2><p>时间戳<br> （Timestamp ordering，TO）：基于时间戳对事务提交顺序排序的并发控制技术。</p>
<h3 id="时间戳排序技术中有两类主体："><a href="#时间戳排序技术中有两类主体：" class="headerlink" title="时间戳排序技术中有两类主体："></a>时间戳排序技术中有两类主体：</h3><ol>
<li>事务</li>
<li>数据项。</li>
</ol>
<p>时间戳就要“盖（赋值）”在这两类主体上。</p>
<h3 id="依附在事务上的时间戳："><a href="#依附在事务上的时间戳：" class="headerlink" title="依附在事务上的时间戳："></a>依附在事务上的时间戳：</h3><p>每个事务分配一个时间值（通常是在事务开始的时候分配，但有的系统是在事务提交的时候才分配时间值）作为此事务发生的标识，这个时间值称为一个“时间戳”，“时间戳”就如同为事务盖了一个章。时间值取值有两种方式，一是系统时钟，二是逻辑计数器。</p>
<h3 id="依附在数据上的时间戳："><a href="#依附在数据上的时间戳：" class="headerlink" title="依附在数据上的时间戳："></a>依附在数据上的时间戳：</h3><p>数据项上有两个时间戳：</p>
<ol>
<li>读时间戳，记录读取该数据项的最大事务的时间戳</li>
<li>写时间戳，记录写入该数据项当前值的事务对应的时间戳，即最新的修改该数据项的事务的时间戳标识。</li>
</ol>
<h3 id="事务根据时间戳确认先后顺序关系"><a href="#事务根据时间戳确认先后顺序关系" class="headerlink" title="事务根据时间戳确认先后顺序关系"></a>事务根据时间戳确认先后顺序关系</h3><p>因存在并发， 所以通过检查Ti事务的时间戳和Tj事务的数据项上的时间戳以确定并发事务Ti和Tj之间的先后关系（如果Ti&lt;Tj，则事务调度器必须保证所产生的并发调度等价于事务Ti先于事务Tj的某个串行调度）。</p>
<h3 id="读写冲突按照时间戳顺序执行"><a href="#读写冲突按照时间戳顺序执行" class="headerlink" title="读写冲突按照时间戳顺序执行"></a>读写冲突按照时间戳顺序执行</h3><p>任何有冲突的READ或WRITE操作按时间戳顺序执行。</p>
<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p><img src="/2023/03/29/Daos-mvcc-and-timestamp-ordering/image-20230301140808905.png" alt="image-20230301140808905"></p>
<h3 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h3><h4 id="写读冲突"><a href="#写读冲突" class="headerlink" title="写读冲突"></a>写读冲突</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">begin T2                       R(X)</span><br><span class="line">|------------------------------|------------------------------------------ <span class="keyword">case</span> 1</span><br><span class="line">              begin T2                      R(X)</span><br><span class="line">              |-----------------------------|----------------------------- <span class="keyword">case</span> 2</span><br><span class="line">		begin T1       W(X)</span><br><span class="line">		|--------------|------------------------------------------------------</span><br><span class="line">                                begin T2       R(X)</span><br><span class="line">                                |--------------|-------------------------- <span class="keyword">case</span> 3</span><br><span class="line"></span><br><span class="line">-----------------------------Time line---------------------------------------&gt;</span><br></pre></td></tr></table></figure>

<p>case1:事务T2的开始时间早于事务T1,事务T2的R(X)时间晚于事务T1的W(X)时间，T2读被abort，避免脏读</p>
<p>case2:事务T2的开始时间晚于事务T1,事务T2的R(X)时间晚于事务T1的W(X)时间，T2读被abort，避免脏读</p>
<p>case3:事务T2的开始时间在T1写X之后，此时事务T2阻塞等待：</p>
<ol>
<li>事务T1提交，则事务T2不受影响</li>
<li>事务T1abort，事务T2也必须abort，避免脏读</li>
</ol>
<p>总结：</p>
<ol>
<li>当前事务开始早于其他事务的写，当前事务的读需要abort</li>
<li>当前事务开始晚于其他事务的写，其他事务commit，当前事务可以读。</li>
</ol>
<h4 id="读写冲突"><a href="#读写冲突" class="headerlink" title="读写冲突"></a>读写冲突</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin T2                       W(X)</span><br><span class="line">|------------------------------|------------------------------------------ <span class="keyword">case</span> 1</span><br><span class="line">              begin T2                      W(X)</span><br><span class="line">              |-----------------------------|----------------------------- <span class="keyword">case</span> 2</span><br><span class="line">		begin T1       R(X)</span><br><span class="line">		|--------------|------------------------------------------------------</span><br><span class="line"></span><br><span class="line">-----------------------------Time line-------------------------------------&gt;</span><br></pre></td></tr></table></figure>

<p>case1:事务T2的开始时间早于事务T1,事务T2的W(X)时间晚于事务T1的R(X)时间，T2读被abort，避免事务T1不可重复读</p>
<p>case1:事务T2的开始时间晚于事务T1,事务T2的W(X)时间晚于事务T1的R(X)时间，T2读被abort，避免事务T1不可重复读</p>
<p>总结：读前写后回滚写</p>
<h4 id="写写冲突"><a href="#写写冲突" class="headerlink" title="写写冲突"></a>写写冲突</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin T2                       W(X)</span><br><span class="line">|------------------------------|------------------------------------------ <span class="keyword">case</span> 1</span><br><span class="line">              begin T2                      W(X)</span><br><span class="line">              |-----------------------------|----------------------------- <span class="keyword">case</span> 2</span><br><span class="line">		begin T1       W(X)</span><br><span class="line">		|--------------|------------------------------------------------------</span><br><span class="line"></span><br><span class="line">-----------------------------Time line-----------------------------------------&gt;</span><br></pre></td></tr></table></figure>

<p>case1:事务T2的开始时间早于事务T1,事务T2的W(X)时间晚于事务T1的W(X)时间，T2读被abort，事务T2需要写的值是事务T1介入之前的值</p>
<p>case1:事务T2的开始时间晚于事务T1,事务T2的W(X)时间晚于事务T1的W(X)时间，T2读被abort，事务T2需要写的值是事务T1介入之前的值</p>
<p>问：T2事务中的W(X)可能小于T1事务中的W(X)吗?</p>
<p>答：假设Wt2(X) &lt; Wt1(X)，则代表着T2的写操作在T1的写操作之前完成，T2的写操作为后写，后写需要被abort，但是X的写时间被更新成了Wt1(X)，意味着T1的写成功， 两者矛盾，因此不可能T2事务中的W(X)可能小于T1事务中的W(X)。</p>
<p>总结：写写冲突，回滚后写。</p>
<h4 id="伪代码解释"><a href="#伪代码解释" class="headerlink" title="伪代码解释"></a>伪代码解释</h4><p>检查Ti需要使用到的所有value</p>
<ol>
<li>如果打算读value：【第一张图中的场景】<ol>
<li>如果当前事务开始早于写操作，读要回滚再重来（否则可能会脏读）</li>
<li>如果当前事务开始晚于写操作，将写value的事务加入到当前事务的依赖事务列表中DEP(Ti). add(WT’S(O;))，更新value的读时间戳DEP(Ti). add(WT’S(O;))</li>
</ol>
</li>
<li>如果打算写value：<ol>
<li>如果当前事务的开始早于读操作，回滚写（否则另一个事务的读可能出现不可重复读）【第二张图中的场景】</li>
<li>如果当前事务的开始晚于写操作，abort当前事务的写或者一句Thomas Write Rule skip【第三张图中的场景】</li>
<li>否则通过检查，存储更新前的旧值OLD(Ti). add(O;, WTS(O;)),更新value的写时间WTS(0;) = TS(I; ),更新value的值</li>
</ol>
</li>
</ol>
<p>如果DEP（Ti）中有未结束的事务，wait</p>
<p>如果DEP（Ti）中有abort的事务，则1.2中的读也需要abort</p>
<p>abort流程：恢复旧值和旧的时间戳。</p>
<h2 id="DAOS中的Time-stamp-ordering"><a href="#DAOS中的Time-stamp-ordering" class="headerlink" title="DAOS中的Time-stamp ordering"></a>DAOS中的Time-stamp ordering</h2><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><h4 id="A-read-at-epoch-e-follows-these-rules-（对应于写读冲突中的三个case）"><a href="#A-read-at-epoch-e-follows-these-rules-（对应于写读冲突中的三个case）" class="headerlink" title="A read at epoch e follows these rules: （对应于写读冲突中的三个case）"></a>A read at epoch e follows these rules: （对应于写读冲突中的三个case）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Epoch uncertainty check</span></span><br><span class="line">	<span class="keyword">if</span> e is uncertain</span><br><span class="line">			<span class="comment">// 写读冲突,读事务的读操作的开始晚于其他事务的写操作（读事务的读操作一定是在e_orig + epsilon之后吗？）</span></span><br><span class="line">      <span class="keyword">if</span> there is any overlapping, <span class="function">unaborted write <span class="title">in</span> <span class="params">(e, e_orig + epsilon]</span></span></span><br><span class="line"><span class="params"><span class="function">          reject <span class="comment">// 回滚读 (case1&amp;case2)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  find the highest overlapping, unaborted write in [<span class="number">0</span>, e] <span class="comment">//写读冲突，读事务的开始时间晚于其他写事务的写操作事件</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">if</span> the write is <span class="keyword">not</span> committed <span class="comment">// 等待</span></span></span></span><br><span class="line"><span class="params"><span class="function">      wait <span class="keyword">for</span> the write to commit <span class="keyword">or</span> <span class="built_in">abort</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">if</span> aborted</span></span></span><br><span class="line"><span class="params"><span class="function">          retry the find skipping <span class="keyword">this</span> write <span class="comment">// 如果其他写事务abort，此读事务retry (case3)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">// Read timestamp update</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">for</span> level i from container to the read<span class="string">&#x27;s level lv</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">      update i.high // 更新TimeStamp Cache</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">  update lv.low</span></span></span></span><br></pre></td></tr></table></figure>

<p>e:代指的是事务的开始HLC时间，e的实际开始物理时间可能在(e, e_orig + epsilon）范围内。</p>
<p>epsilon:代指的是是HLC时间和实际物理时间的误差范围。</p>
<h4 id="A-write-at-epoch-e-follows-these-rules-（对应于读写冲突-amp-写写冲突的几个case）"><a href="#A-write-at-epoch-e-follows-these-rules-（对应于读写冲突-amp-写写冲突的几个case）" class="headerlink" title="A write at epoch e follows these rules: （对应于读写冲突&amp;写写冲突的几个case）"></a>A write at epoch e follows these rules: （对应于读写冲突&amp;写写冲突的几个case）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Epoch uncertainty check</span></span><br><span class="line"> <span class="keyword">if</span> e is uncertain</span><br><span class="line"> 		<span class="comment">// 写写冲突，后写abort（认为当前事务的写在e_orig + epsilon时间之后）</span></span><br><span class="line">     <span class="keyword">if</span> there is any overlapping, <span class="function">unaborted write <span class="title">in</span> <span class="params">(e, e_orig + epsilon]</span></span></span><br><span class="line"><span class="params"><span class="function">         reject</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="comment">// Read timestamp check， 检查读写冲突，读在前写在后</span></span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">for</span> level i from container to one level above the write</span></span></span><br><span class="line"><span class="params"><span class="function"> 		<span class="comment">// 读写冲突，如果父节点的low小于当前事务的开始时间，意味着父节点下的所有子节点都在low这个时间点被读过，则可以推导出write的目			 // 标value在low时间被读取过,当前事务的开始时间早于value的读操作时间，则当前事务需要abort</span></span></span></span><br><span class="line"><span class="params"><span class="function"> 		<span class="comment">// (i.low == e) &amp;&amp; (other reader @ i.low) --&gt; 检查是否是同一个txn中的操作，如果是同一个txn的读写，则不需要abort</span></span></span></span><br><span class="line"><span class="params"><span class="function"> 		<span class="comment">// 这些父节点的检查可能是想快速判断出是够有冲突，不必递归到目标项上做检查</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">if</span> (i.low &gt; e) || ((i.low == e) &amp;&amp; (other reader @ i.low))</span></span></span><br><span class="line"><span class="params"><span class="function">         reject</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="comment">// 检查目标项，读写冲突，abort写</span></span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">if</span> (i.high &gt; e) || ((i.high == e) &amp;&amp; (other reader @ i.high))</span></span></span><br><span class="line"><span class="params"><span class="function">     reject</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="comment">// 此处的overlapping检查逻辑暂不明确作用,好像也是在检查写写冲突</span></span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="comment">// 上面的写写冲突检查区间并没有覆盖到e这个点，是个左开右闭区间，不清楚为什么要分开检测</span></span></span></span><br><span class="line"><span class="params"><span class="function"> find <span class="keyword">if</span> there is any overlapping write at e</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">if</span> found <span class="keyword">and</span> from a different transaction</span></span></span><br><span class="line"><span class="params"><span class="function">		reject</span></span></span><br></pre></td></tr></table></figure>

<p>i.low:目标节点和其所有子节点都至少在low时间点被读取过。</p>
<p>i.high:目标节点至少有一个子节点在high时间被读取过。</p>
<h3 id="Daos中检查冲突的代码片段"><a href="#Daos中检查冲突的代码片段" class="headerlink" title="Daos中检查冲突的代码片段"></a>Daos中检查冲突的代码片段</h3><h4 id="检查读写冲突"><a href="#检查读写冲突" class="headerlink" title="检查读写冲突"></a>检查读写冲突</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写操作检查，查看是够有读写冲突</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">vos_ts_check_read_conflict</span><span class="params">(struct vos_ts_set *ts_set, <span class="keyword">int</span> idx,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="keyword">daos_epoch_t</span> write_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vos_ts_set_entry</span>	*<span class="title">se</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vos_ts_entry</span>	*<span class="title">entry</span>;</span></span><br><span class="line">	<span class="keyword">int</span>			 write_level;</span><br><span class="line">	<span class="keyword">bool</span>			 conflict;</span><br><span class="line"></span><br><span class="line">	D_ASSERT(ts_set != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	se = &amp;ts_set-&gt;ts_entries[idx];</span><br><span class="line">	entry = se-&gt;se_entry;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ts_set-&gt;ts_wr_level &gt; ts_set-&gt;ts_max_type)</span><br><span class="line">		write_level = ts_set-&gt;ts_max_type;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		write_level = ts_set-&gt;ts_wr_level;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (se-&gt;se_etype &gt; write_level)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/** Check is redundant */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** NB: If there is a negative entry, we should also check it.  Otherwise, we can miss</span></span><br><span class="line"><span class="comment">	 *  timestamp updates associated with conditional operations where the tree exists but</span></span><br><span class="line"><span class="comment">	 *  we don&#x27;t load it ,不太明白这边的negative是什么意思？</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 检查目标value父节点</span></span><br><span class="line">	<span class="comment">// for level i from container to one level above the write</span></span><br><span class="line">	<span class="keyword">if</span> (se-&gt;se_etype &lt; write_level) &#123;</span><br><span class="line">		<span class="comment">/* check the low time */</span></span><br><span class="line">		conflict = vos_ts_check_conflict(entry-&gt;te_ts.tp_ts_rl, &amp;entry-&gt;te_ts.tp_tx_rl,</span><br><span class="line">						 write_time, &amp;ts_set-&gt;ts_tx_id);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (conflict || entry-&gt;te_negative == <span class="literal">NULL</span>) </span><br><span class="line">		<span class="comment">// conflict为true ---》冲突</span></span><br><span class="line">		<span class="comment">// conflict为false，negative为空，---》不冲突</span></span><br><span class="line">			<span class="keyword">return</span> conflict;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// conflict为false且negative不为空，检查negative：什么是negative？</span></span><br><span class="line">		<span class="comment">// 如果和negative冲突也代表冲突</span></span><br><span class="line">		<span class="keyword">return</span> vos_ts_check_conflict(entry-&gt;te_negative-&gt;te_ts.tp_ts_rl,</span><br><span class="line">					     &amp;entry-&gt;te_negative-&gt;te_ts.tp_tx_rl,</span><br><span class="line">					     write_time, &amp;ts_set-&gt;ts_tx_id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check the high time */</span></span><br><span class="line">	<span class="comment">// if (i.high &gt; e) || ((i.high == e) &amp;&amp; (other reader @ i.high)),检查目标value的high</span></span><br><span class="line">	conflict = vos_ts_check_conflict(entry-&gt;te_ts.tp_ts_rh, &amp;entry-&gt;te_ts.tp_tx_rh, write_time,</span><br><span class="line">					 &amp;ts_set-&gt;ts_tx_id);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (conflict || entry-&gt;te_negative == <span class="literal">NULL</span>)</span><br><span class="line">	<span class="comment">// conflict为true ---》冲突</span></span><br><span class="line">	<span class="comment">// conflict为false，negative为空，---》不冲突</span></span><br><span class="line">		<span class="keyword">return</span> conflict;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// conflict为false且negative不为空，检查negative：什么是negative？</span></span><br><span class="line">	<span class="comment">// 如果和negative冲突也代表冲突</span></span><br><span class="line">	<span class="keyword">return</span> vos_ts_check_conflict(entry-&gt;te_negative-&gt;te_ts.tp_ts_rh,</span><br><span class="line">				     &amp;entry-&gt;te_negative-&gt;te_ts.tp_tx_rh, write_time,</span><br><span class="line">				     &amp;ts_set-&gt;ts_tx_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查读写冲突的子函数</span></span><br><span class="line"><span class="comment">// 如果冲突，返回true</span></span><br><span class="line"><span class="comment">// 如果不冲突，返回false</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">vos_ts_check_conflict</span><span class="params">(<span class="keyword">daos_epoch_t</span> read_time, <span class="keyword">const</span> struct dtx_id *read_id,</span></span></span><br><span class="line"><span class="params"><span class="function">		      <span class="keyword">daos_epoch_t</span> write_time, <span class="keyword">const</span> struct dtx_id *write_id)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 当前事务的开始时间晚于读操作，则不冲突</span></span><br><span class="line">	<span class="keyword">if</span> (write_time &gt; read_time)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前事务的开始时间早于读操作，冲突，abort当前事务的写</span></span><br><span class="line">	<span class="keyword">if</span> (write_time != read_time)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前事务写操作和其他事务的读操作在同一时间发起，且这两事务不在同时发生，则冲突</span></span><br><span class="line">	<span class="keyword">if</span> (read_id-&gt;dti_hlc != write_id-&gt;dti_hlc)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前事务写操作和其他事务的读操作在同一时间发起，且这两个事务同时发生：</span></span><br><span class="line">	<span class="comment">//	1. 事务ID号相同，则不冲突 （同一个事务内同时的读写操作）</span></span><br><span class="line">	<span class="comment">//  2. 事务ID号不同，则冲突</span></span><br><span class="line">	<span class="keyword">return</span> uuid_compare(read_id-&gt;dti_uuid, write_id-&gt;dti_uuid) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="检查写写冲突，写读冲突"><a href="#检查写写冲突，写读冲突" class="headerlink" title="检查写写冲突，写读冲突"></a>检查写写冲突，写读冲突</h4><p>// TODO:不能理解case2，case3中的场景</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case1: &lt;-----------X----------------|----------------o-----------------o------------------&gt;</span><br><span class="line">                current            bound               U1                U2</span><br><span class="line">case2: &lt;-----------o----------------v----------------|-----------------o------------------&gt;</span><br><span class="line">                  U1               current          bound             U2	</span><br><span class="line">case3: &lt;-----------o----------------x----------------o-----------------|------------------&gt;</span><br><span class="line">                  U1               current          U2                bound	</span><br><span class="line">case4: &lt;-----------o----------------o----------------v-----------------|------------------&gt;</span><br><span class="line">                  U1               U2               current           bound				</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Do an uncertainty check on the entry.  Return true if there</span></span><br><span class="line"><span class="comment"> *  is a write within the epoch uncertainty bound or if it</span></span><br><span class="line"><span class="comment"> *  can&#x27;t be determined that the epoch is safe (e.g. a cache miss).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  There are the following cases for an uncertainty check</span></span><br><span class="line"><span class="comment"> *  1. The access timestamp is earlier than both.  In such</span></span><br><span class="line"><span class="comment"> *     case, we have a cache miss and can&#x27;t determine whether</span></span><br><span class="line"><span class="comment"> *     there is uncertainty so we must reject the access.</span></span><br><span class="line"><span class="comment"> *  2. The access is later than the first and the bound is</span></span><br><span class="line"><span class="comment"> *     less than or equal to the high time.  No conflict in</span></span><br><span class="line"><span class="comment"> *     this case because the write is outside the undertainty</span></span><br><span class="line"><span class="comment"> *     bound.</span></span><br><span class="line"><span class="comment"> *  3. The access is later than the first but the bound is</span></span><br><span class="line"><span class="comment"> *     greater than the high timestamp.  We must reject the</span></span><br><span class="line"><span class="comment"> *     access because there is an uncertain write.</span></span><br><span class="line"><span class="comment"> *  4. The access is later than both timestamps.  No conflict</span></span><br><span class="line"><span class="comment"> *     in this case.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  \param[in]	ts_set	The timestamp set</span></span><br><span class="line"><span class="comment"> *  \param[in]	epoch	The epoch of the update</span></span><br><span class="line"><span class="comment"> *  \param[in]	bound	The uncertainty bound</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">vos_ts_wcheck</span><span class="params">(struct vos_ts_set *ts_set, <span class="keyword">daos_epoch_t</span> epoch,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="keyword">daos_epoch_t</span> bound)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vos_wts_cache</span>	*<span class="title">wcache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vos_ts_set_entry</span>	*<span class="title">se</span>;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>		 high_idx;</span><br><span class="line">	<span class="keyword">daos_epoch_t</span>		 high;</span><br><span class="line">	<span class="keyword">daos_epoch_t</span>		 second;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!vos_ts_in_tx(ts_set) || ts_set-&gt;ts_init_count == <span class="number">0</span> ||</span><br><span class="line">	    bound &lt;= epoch)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	se = &amp;ts_set-&gt;ts_entries[ts_set-&gt;ts_init_count - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (se-&gt;se_entry == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	wcache = &amp;se-&gt;se_entry-&gt;te_w_cache;</span><br><span class="line">	high_idx = wcache-&gt;wc_w_high;</span><br><span class="line">	high = wcache-&gt;wc_ts_w[high_idx];</span><br><span class="line">	<span class="comment">// 事务的开始时间晚于任何其他事务的写时间，不产生任何冲突</span></span><br><span class="line">	<span class="comment">// 写读冲突中的case3,读事务的开始时间晚于其他事务的写操作时间，需要返回等待</span></span><br><span class="line">	<span class="comment">// 写写冲突中，写事务的开始时间晚于其他事务的写操作时间，不冲突</span></span><br><span class="line">	<span class="keyword">if</span> (epoch &gt;= high) <span class="comment">/* Case #4, the access is newer than any write */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	second = wcache-&gt;wc_ts_w[<span class="number">1</span> - high_idx];</span><br><span class="line">	<span class="comment">// 事务的开始时间小于其他事务写此value的Tlow,当前事务的写应该被abort</span></span><br><span class="line">	<span class="comment">// 写读冲突中，读事务的开始时间早于写事务的写操作时间，读操作需要被abort，写读冲突中的case1和case2属于此类</span></span><br><span class="line">	<span class="comment">// 写写冲突中，写事务的开始时间早于其他写事务的写操作时间，后写的需要被abort，写写冲突中的case1和case2属于此种</span></span><br><span class="line">	<span class="keyword">if</span> (epoch &lt; second) <span class="comment">/* Case #1, Cache miss, not enough history */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We know at this point that second &lt;= epoch so we need to determine</span></span><br><span class="line"><span class="comment">	 * only if the high time is inside the uncertainty bound.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (bound &gt;= high) <span class="comment">/* Case #3, Uncertain write conflict */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="DAOS中基于时间戳的多版本并发控制协议"><a href="#DAOS中基于时间戳的多版本并发控制协议" class="headerlink" title="DAOS中基于时间戳的多版本并发控制协议"></a>DAOS中基于时间戳的多版本并发控制协议</h2><h3 id="时间戳排序的多版本并发控制协议算法原理"><a href="#时间戳排序的多版本并发控制协议算法原理" class="headerlink" title="时间戳排序的多版本并发控制协议算法原理"></a>时间戳排序的多版本并发控制协议算法原理</h3><p>MVCC不是一 个可独立使用的事务并发控制技术，而是需要基于其他并发控制技术，如基于时间戳的称为多版本时间戳排序机制( multiversion timestamp-ordering scheme) ， 基于两 阶段封锁协议的称为多版本两 阶段封锁协议 ( multiversion two-phase locking protocol)’’。 </p>
<p>基于时间戳的称为多版本时间戳排序机制的基本原理：</p>
<ol>
<li>首先，数据库系统在事务开始前赋予一个时间戳，记为TS（Ti），这个时间戳则决定了并发的事务的调度顺序。</li>
<li>对于每个数据项X，多版本体现在：X有一个版本序列&lt;X1，X2，…，Xn&gt;，其中，每个版本Xi包括三个字段，分别是：<ol>
<li>Xi=value，value是数据项X的第i个版本的值，每个版本是由一个写操作生成的。</li>
<li>W-timestamp（Xi）是创建Xi这个版本的事务的时间戳（不是当前时间戳值），即表明此数据项是被谁在什么时候创建的。</li>
<li>R-timestamp（Xi）是所有成功读取Xi这个版本的事务的时间戳。</li>
</ol>
</li>
<li>再次，多版本时间戳排序机制通过如下规则，保证可串行性：<ol>
<li>如果事务Ti执行Read操作或Write操作，假设Xm表示X满足如下条件的版本，其写时间戳是小于或等于TS（Ti）的最大写时间戳（确保了在所有版本中找到一个“最近版本”）。</li>
<li>如果事务Ti执行读操作Read（X），返回给事务Ti的值为Xm。读永远不会被阻塞。 </li>
<li>如果事务Ti执行写操作Write（X）：<ol>
<li>如果 TS(Ti)&lt;R-timestamp(Xm)，则中止事务 Ti，这表明即将执行的这个写操作之后的时间上已经发生过了 一个读操作，如果允许写操作成功，则可能发生 不可重复读异常现象 。 这是写 - i卖冲突，事务 Ti 被中止 。 </li>
<li>如果 TS(Ti)=W-tim巳stamp(X时，则系统更新事务 Ti 的值 Xm 为新值，这表明本事务多次写过同一个数据项，新值覆盖旧值 </li>
<li>如果 TS(Ti)&gt;W-timestamp(Xm)，则系统为事务 Ti 的数据项 X 创建一个新值，这说明后发生的事务才创建新的版本 。 这是写一写冲突，导致产生新版本 。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="DAOS中的时间戳的多版本并发控制协议代码片段"><a href="#DAOS中的时间戳的多版本并发控制协议代码片段" class="headerlink" title="DAOS中的时间戳的多版本并发控制协议代码片段"></a>DAOS中的时间戳的多版本并发控制协议代码片段</h3><p>TODO</p>
<h2 id="Question："><a href="#Question：" class="headerlink" title="Question："></a>Question：</h2><ol>
<li><p>为什么Daos中每个entry需要记录两个write TimeStamp？</p>
<p>按照传统的Time Ordering算法，只记录一个readTimeStamp和一个writeTimeStamp。</p>
<p>daos的文档中这样描述：</p>
<blockquote>
<p>In order to detect epoch uncertainty violations, VOS also maintains a pair of write timestamps for each container, object, dkey, and akey. Logically, the timestamps represent the latest two updates to either the entity itself or to an entity in a subtree. At least two timestamps are required to avoid assuming uncertainty if there are any later updates. The figure below shows the need for at least two timestamps. With a single timestamp only, the first, second, and third cases would be indistinguishable and would be rejected as uncertain. </p>
</blockquote>
<pre><code> 根据文档的描述，记录两个Write TimeStamp，可以减少一些uncertain场景的冲突个数。按照传统的Time Ordering算法，上一小        节中的case2，case3，和case4都应该被abort。通过记录两个TimeStamp，case2可以不abort。没有理解这边不abort的理由。
</code></pre>
</li>
<li><p>TimeStamp entry中的negative代表了什么？为什么检查冲突的时候也需要检查negative</p>
<blockquote>
<p>NB: If there is a negative entry, we should also check it.  Otherwise, we can miss timestamp updates associated with conditional operations where the tree exists but we don’t load it </p>
</blockquote>
</li>
</ol>
<h2 id="其他参考："><a href="#其他参考：" class="headerlink" title="其他参考："></a>其他参考：</h2><h3 id="CockroachDB中关于TimeStamp-Cache的描述："><a href="#CockroachDB中关于TimeStamp-Cache的描述：" class="headerlink" title="CockroachDB中关于TimeStamp Cache的描述："></a>CockroachDB中关于TimeStamp Cache的描述：</h3><blockquote>
<h4 id="Read-Write-Conflicts-–-Read-Timestamp-Cache"><a href="#Read-Write-Conflicts-–-Read-Timestamp-Cache" class="headerlink" title="Read-Write Conflicts – Read Timestamp Cache"></a><strong>Read-Write Conflicts</strong> – Read Timestamp Cache</h4><p>On any read operation, the timestamp of that read operation is recorded in a node-local <em>timestamp cache</em>. This cache will return the most recent timestamp at which the key was read.</p>
<p>All write operations consult the timestamp cache for the key they are writing; if the returned timestamp is greater than the operation timestamp, this indicates a RW conflict with a later timestamp.  To disallow this, the operation (and its transaction) must be aborted and restarted with a later timestamp.</p>
<p>The timestamp cache is an interval cache, meaning that its keys are actually key ranges. If a read operation is actually a predicate operating over a range of keys (such as a scan), then the entire scanned key range is written to the timestamp cache. This prevents RW conflicts where the key being written was not present during the scan operation.</p>
<p>The timestamp cache is a size-limited, in-memory LRU (least recently used) data structure, with the oldest timestamps being evicted when the size limit is reached. To deal with keys not in the cache, we also maintain a “low water mark”, which is equivalent to the earliest read timestamp of any key that is present in the cache. If a write operation writes to a key not present in the cache, the “low water mark” is returned instead.</p>
<h4 id="Write-Write-Conflicts-–-Can-only-write-the-most-recent-version-of-a-key"><a href="#Write-Write-Conflicts-–-Can-only-write-the-most-recent-version-of-a-key" class="headerlink" title="Write-Write Conflicts – Can only write the most recent version of a key"></a><strong>Write-Write Conflicts</strong> – Can only write the most recent version of a key</h4><p>If a write operation attempts to write to a key, but that key already has a version with a later timestamp than the operation itself, allowing the operation would create a WW conflict with the later transaction.  To ensure serializability, the operation (and its transaction) must be aborted and restarted with a later timestamp.</p>
<p>By choosing a timestamp-based ordering, and rejecting all conflicts which disagree with that ordering, CockroachDB’s Serializable Snapshot guarantees a serializable schedule.</p>
<h3 id="Timestamp-cache"><a href="#Timestamp-cache" class="headerlink" title="Timestamp cache"></a>Timestamp cache</h3><p>The timestamp cache tracks the highest timestamp (i.e., most recent) for any read operation that a given range has served.</p>
<p>Each write operation in a <code>BatchRequest</code> checks its own timestamp versus the timestamp cache to ensure that the write operation has a higher timestamp; this guarantees that history is never rewritten and you can trust that reads always served the most recent data. It’s one of the crucial mechanisms CockroachDB uses to ensure serializability. If a write operation fails this check, it must be restarted at a timestamp higher than the timestamp cache’s value.</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/25/notes-of-craft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saturn">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/25/notes-of-craft/" class="post-title-link" itemprop="url">Notes of CRaft</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-25 10:41:13" itemprop="dateCreated datePublished" datetime="2023-03-25T10:41:13+08:00">2023-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-17 15:28:38" itemprop="dateModified" datetime="2023-04-17T15:28:38+08:00">2023-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/knowledge/" itemprop="url" rel="index"><span itemprop="name">knowledge</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h2><p><img src="/2023/03/25/notes-of-craft/image-20230316131248161-1716311.png" alt="image-20230316131248161"></p>
<h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h3><ol>
<li>选主，投票，确认</li>
<li>向Leader发送日志</li>
<li>Leader分发日志，F+1个slave确认</li>
<li>Leader提交日志，回复client，同步commit信息</li>
</ol>
<h3 id="Raft协议保证两个properties："><a href="#Raft协议保证两个properties：" class="headerlink" title="Raft协议保证两个properties："></a>Raft协议保证两个properties：</h3><ol>
<li><em>Safety</em>. They never return incorrect results under all non- Byzantine conditions.</li>
<li><em>Liveness</em>. They are fully functional as long as any majority of the servers are alive and can communicate with each other and with clients. We call this group of servers <em>healthy</em>.</li>
</ol>
<p>Safety property由Leader Completeness Property 保证： if a log entry is committed in a given term, then that entry will be present in the logs of the leaders for all higher-numbered terms.</p>
<p>Liveness 由Raft的rule保证。</p>
<h2 id="Erasure-Coding"><a href="#Erasure-Coding" class="headerlink" title="Erasure Coding"></a>Erasure Coding</h2><p>纠删码是一种通用的用来在存储和网络传输领域容错的手段。</p>
<h3 id="Reed-Solomon-code（RS-code）"><a href="#Reed-Solomon-code（RS-code）" class="headerlink" title="Reed-Solomon code（RS-code）"></a>Reed-Solomon code（RS-code）</h3><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>给定n个数据块d1, d2,…, dn，n和一个正整数m， RS根据n个数据块生成m个校验块， c1, c2,…, cm。 对于任意的n和m， 从n个原始数据块和m 个校验块中任取n块就能解码出原始数据， 即RS最多容忍m个数据块或者校验块同时丢失（纠删码只能容忍数据丢失，无法容忍数据篡改，纠删码正是得名与此）。</p>
<img src="/2023/03/25/notes-of-craft/image-20230316132947759-1716311.png" alt="image-20230316132947759" style="zoom:50%;">

<h5 id="单位矩阵："><a href="#单位矩阵：" class="headerlink" title="单位矩阵："></a>单位矩阵：</h5><p>定义：在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%80%A7%E4%BB%A3%E6%95%B8">线性代数</a>中，n<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" alt="n">阶<strong>单位矩阵</strong>，是一个n×n<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/59d2b4cb72e304526cf5b5887147729ea259da78" alt="n\times n">的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%99%A3">方形矩阵</a>，其<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%B0%8D%E8%A7%92%E7%B7%9A">主对角线</a>元素为1，其馀元素为0。</p>
<p>性质：<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/270d2d1250b851b5ab8c8b6784ae6f7af43605d4" alt="AI_{n}=A">且InB=B<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cbeb82b24cbbca97fea9fb9343b305f04b046c0f" alt="I_{n}B=B">(<strong>任何矩阵与单位矩阵相乘都等于本身</strong>)</p>
<h5 id="范德蒙矩阵（vandermonde-matrix）："><a href="#范德蒙矩阵（vandermonde-matrix）：" class="headerlink" title="范德蒙矩阵（vandermonde matrix）："></a><strong>范德蒙矩阵</strong>（vandermonde matrix）：</h5><p>定义：<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b8f4302012c92aae6005095ab7c03aed1409e0f3" alt="{\displaystyle V={\begin{bmatrix}1&amp;\alpha _{1}&amp;\alpha _{1}^{2}&amp;\dots &amp;\alpha _{1}^{n-1}\\1&amp;\alpha _{2}&amp;\alpha _{2}^{2}&amp;\dots &amp;\alpha _{2}^{n-1}\\1&amp;\alpha _{3}&amp;\alpha _{3}^{2}&amp;\dots &amp;\alpha _{3}^{n-1}\\\vdots &amp;\vdots &amp;\vdots &amp;\ddots &amp;\vdots \\1&amp;\alpha _{m}&amp;\alpha _{m}^{2}&amp;\dots &amp;\alpha _{m}^{n-1}\\\end{bmatrix}}}"></p>
<p>之所以采用vandermonde矩阵的原因是， RS数据恢复算法要求编码矩阵任意n*n子矩阵可逆。</p>
<h5 id="逆矩阵："><a href="#逆矩阵：" class="headerlink" title="逆矩阵："></a>逆矩阵：</h5><p>性质：矩阵和其逆矩阵相乘，结果等于单位矩阵。</p>
<h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><p>假设D1，D4和C2丢失，如何通过RS-code恢复？</p>
<ol>
<li>根据编码的等式，获得B‘等式：</li>
</ol>
<img src="/2023/03/25/notes-of-craft/image-20230316134304214-1716311.png" alt="image-20230316134304214" style="zoom:50%;">

<ol start="2">
<li><p>由于编码矩阵可逆，将等式两边乘以编码矩阵的逆矩阵：</p>
<img src="/2023/03/25/notes-of-craft/image-20230316134640443-1716311.png" alt="image-20230316134640443" style="zoom:50%;"></li>
<li><p>根据上面提到的逆矩阵性质，矩阵乘以其逆矩阵等于单位矩阵，得到以下等式</p>
<img src="/2023/03/25/notes-of-craft/image-20230316134737115-1716311.png" alt="image-20230316134737115" style="zoom:50%;"></li>
<li><p>所以对幸存的fragment使用编码矩阵的逆矩阵进行重新编码，可以获取到原始的fragment。</p>
</li>
</ol>
<h4 id="此论文中RS-code的一些相关定义："><a href="#此论文中RS-code的一些相关定义：" class="headerlink" title="此论文中RS-code的一些相关定义："></a>此论文中RS-code的一些相关定义：</h4><p>RS可以定义一组整数，k和m，data被等分为k组，使用k组fragment编码生成m组parity fragment，因此一共有k+m组编码后的fragment，称作coded-fragment。集群中有N个Server，每个Server存储一个coded-fragment，因此k+m = N。</p>
<h2 id="RS-Paxos"><a href="#RS-Paxos" class="headerlink" title="RS-Paxos"></a>RS-Paxos</h2><p>RS-Paxos也是结合了RS纠删码，可以将存储代价大大降低，付出的代价是Liveness性质不能和Paxos一致。</p>
<p>假设集群中有2F + 1个节点，Paxos可以容忍F个节点的failure，因此将Liveness定义为F。Paxos算法和Raft算法都遵循排容原理（inclusion-exclusion principle）：</p>
<p><code>|A ∪ B| = | A |+| B |−| A ∩ B | </code>(1)</p>
<p>（1）中是两个集合之间的排容原理：</p>
<ol>
<li>假设有限集A和B不相交，则 A U B = A + B</li>
<li>假设有限集A和B相交，则A + B中交集算了两次，需要减去一次交集A ∩ B</li>
</ol>
<p>inclusion-exclusion principle 保证了在一个Raft group中，两个majority必定至少有一个共同的节点。</p>
<p>证明：If |<em>A</em>| &gt; |<em>A</em>∪<em>B</em>|/2 and |<em>B</em>| &gt; |<em>A</em>∪<em>B</em>|/2, |<em>A</em>∩<em>B</em>| = |<em>A</em>|+|<em>B</em>|−|<em>A</em>∪<em>B</em>| &gt; 0.</p>
<p>结论：RS-Paxos的Liveness是小于F的。</p>
<p>证明：</p>
<ol>
<li>RS-Paxos中，需要满足条件<code>Qr + Qw − N ≥ k</code> (2)：Qr和Qw的交集中的Server个数至少为k</li>
<li>RS-Paxos中，至少要max(Qr,Qw)个healthy节点存在才能work</li>
<li>如果一个command被提交，那么至少Qw个节点accept过</li>
<li>如果某节点proposal一个command，那么在prepare阶段至少需要contact Qr个节点</li>
<li>设RS-Paxos的Liveness为L</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. L &lt;= N - max(Qr,Qw)</span><br><span class="line">2. 根据（2），max(Qr,Qw) &gt;= (Qr + Qw)/2 &gt;= (N + k)/2 </span><br><span class="line">3. 根据以上两条，所以 L &lt;= N - (N + k)/2 = (N - k)/2 = (2F + 1 - k)/2 = F - (k + 1)/2 &lt; F</span><br></pre></td></tr></table></figure>



<h2 id="CRaft"><a href="#CRaft" class="headerlink" title="CRaft"></a>CRaft</h2><h3 id="设计目标："><a href="#设计目标：" class="headerlink" title="设计目标："></a>设计目标：</h3><ol>
<li>提供和经典Raft算法一致的Liveness性质（通过限制1来实现）</li>
<li>通过RS-code,降低存储代价</li>
</ol>
<h3 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h3><ol>
<li><p>在一个有2F+1个节点的Raft Group中，当只有F+1个节点存活时，log entry只有在被完整的复制到所有的F+1个healthy节点上后，才能被提交。</p>
<p>证明：假设在2F+1个节点的Group中，当前时刻T1只有F+1个Server存活（S和剩余节点），有节点S和log e，e已经提交，S只存储了e的一个fragment。下一时刻T2，S存活，上一时刻的剩余节点全部unhealthy，上一时刻unhealthy的节点全部转为active，此时只有S存储有log e的一个fragment，无法恢复出完整的log，得证。</p>
</li>
</ol>
<h3 id="coded-fragment-replication-and-complete-entry-replication"><a href="#coded-fragment-replication-and-complete-entry-replication" class="headerlink" title="coded-fragment replication and complete-entry replication"></a>coded-fragment replication and complete-entry replication</h3><h4 id="Coded-fragment-Replication"><a href="#Coded-fragment-Replication" class="headerlink" title="Coded-fragment Replication"></a>Coded-fragment Replication</h4><h5 id="流程：-1"><a href="#流程：-1" class="headerlink" title="流程："></a>流程：</h5><ol>
<li><p>encode原始log，获取k+m个fragment</p>
</li>
<li><p>leader分fragments</p>
</li>
<li><p>至少F+k个slave成功收到fragment并响应leader后，leader commit此log</p>
</li>
<li><p>通知slave commit此log</p>
<p><img src="/2023/03/25/notes-of-craft/image-20230316143621949-1716311.png" alt="image-20230316143621949"></p>
</li>
</ol>
<h5 id="why-F-k"><a href="#why-F-k" class="headerlink" title="why F+k?"></a>why F+k?</h5><p>相较于经典raft理论中，leader在收到F+1个slave的成功响应后即可commit log，CRaft中的commit条件更为严格，在使用coded-fragment replication分发后，需要在F+k个slave响应后方能提交。F+k为了保证Liveness属性，保证了在leader选举后，leader能够正确的从fragment中恢复出完整的log entry。</p>
<h5 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h5><p>假设T1时刻leader无响应，出发leader选举后，选举出新的leader。Raft的election rule保证了选举出的leader拥有最新最全的日志，假设日志e已经提交，新的leader必定拥有e的fragment，由于e已提交，因此至少F+k个Server存储了e的coded-fragments：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">设 A = (F + k),B = (F + 1)</span><br><span class="line">A + B = F + k + F + 1 = 2F + 1 + K</span><br><span class="line">因为 2F + 1 = N</span><br><span class="line">所以 A + B - N = 2F + 1 - N + K = k (1)</span><br><span class="line">根据 A ∪ B = A + B − A ∩ B，因此 A ∩ B = A + B - A ∪ B (2)</span><br><span class="line">由于 A 和 B都属于raft组的majority，因此 A ∪ B &lt;= N</span><br><span class="line">所以 A + B - N &lt; A + B - A ∪ B，</span><br><span class="line">带入 (1)和(2),的 k &lt; A ∩ B</span><br></pre></td></tr></table></figure>

<p>由以上推导可得，在Raft Group中任取F + 1个Server，这F + 1个Server中至少存在k个coded-fragments。</p>
<p>由于Rs-code要求至少要k个coded-fragments才能恢复数据，由此满足条件。</p>
<h5 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h5><p><img src="/2023/03/25/notes-of-craft/image-20230316145948620-1716311.png" alt="image-20230316145948620"></p>
<p>2 * 3 + 1,七个节点，可以容忍三个节点的failure，（k，m） =  （3，4），<br>即一个日志被code成3个fragment和4个parity，一共7个coded fragment，可以容忍4个fragment的丢失，至少需要3个fragment<br>才能恢复出完整的日志。<br>假设使用 3 + 1即 4个节点应答就commit，例如log3，在T2时刻，仅剩4个节点active，因为只有两个fragment，<br>因此无法恢复出完整的log。</p>
<h4 id="complete-entry-replication"><a href="#complete-entry-replication" class="headerlink" title="complete-entry replication"></a>complete-entry replication</h4><h5 id="何时触发？"><a href="#何时触发？" class="headerlink" title="何时触发？"></a>何时触发？</h5><p>coded-fragment要求至少有F + k个节点存活，才能保证Liveness属性，因此如果Raft Group内的healthy节点个数在[F + 1, F + k)区间内时，需要转化为complete-entry replication。</p>
<h5 id="日志提交条件"><a href="#日志提交条件" class="headerlink" title="日志提交条件"></a>日志提交条件</h5><p>和经典raft一致，即日志得到F+1个slave的成功回复后，可以提交。</p>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>在日志提交后，没有获取到日志的节点可以使用coded-fragment replication来节省Storage cost</p>
<p>定义参数p，0 ≤ <em>p</em> ≤ F，leader可以首先发送完整日志到F+p个followers，再向剩余的F-p个followers发送fragment。p值的大小和Storage&amp;network cost成正比关系，当p = F时，退化成经典的raft算法。本文的实现中选取的p值为0。</p>
<p><img src="/2023/03/25/notes-of-craft/image-20230316151703873-1716311.png" alt="image-20230316151703873"></p>
<h3 id="strategy-prediction"><a href="#strategy-prediction" class="headerlink" title="strategy prediction"></a>strategy prediction</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>通过心跳信息来确定active Server的个数：</p>
<ol>
<li>如果active Serve个数不少于F+k，触发coded-fragment replication</li>
<li>如果active Server个数少于F+k，触发complete-entry replication</li>
</ol>
<p><img src="/2023/03/25/notes-of-craft/image-20230316152248757-1716311.png" alt="image-20230316152248757"></p>
<h3 id="Newly-elected-Leader"><a href="#Newly-elected-Leader" class="headerlink" title="Newly-elected Leader"></a>Newly-elected Leader</h3><p>对于new elected leader，可能存在以下两种类型的日志：</p>
<ol>
<li>commit过的日志，coded-fragment replication 保证了至少有k个fragment可以恢复出此条日志，complete-entry replication保证了其他Server有存储过完整的日志，因此committed log可以在new elected leader上正确的恢复。</li>
<li>unapply过的日志，没有机制可以保证此条日志可以正确的恢复，CRaft中引入了<em>LeaderPre</em> operation</li>
</ol>
<h4 id="LeaderPre-operation"><a href="#LeaderPre-operation" class="headerlink" title="LeaderPre operation"></a><em>LeaderPre</em> operation</h4><h5 id="流程：-2"><a href="#流程：-2" class="headerlink" title="流程："></a>流程：</h5><ol>
<li>new elected leader查找出本地unapplied code-fragments</li>
<li>为每条日志向所有的follower发送request</li>
<li>如果接收到了此条日志的完整副本或者k条fragment，则恢复出此条日志，但不会commit或者apply</li>
<li>如果无法恢复，删除</li>
<li>此过程中需要不断向slave发送心跳，防止触发新的选举</li>
</ol>
<p><img src="/2023/03/25/notes-of-craft/image-20230316154606324-1716311.png" alt="image-20230316154606324"></p>
<p>unrecoverable意味着uncommitted，因此删除是harmless的。</p>
<h5 id="具体证明"><a href="#具体证明" class="headerlink" title="具体证明"></a>具体证明</h5><p>Leader Completeness Property：如果log e在term T被提交，那么e会在所有有更高term的leader中出现，且e不会被更高term中的leader删除。</p>
<p>反证：</p>
<p>假设LCP无法被hold，有两种场景：</p>
<ol>
<li>e在Term U的新Leader选举时不在Leader的日志中。</li>
<li>e在Term U的新Leader选举的LeaderPre阶段中被删除了。</li>
</ol>
<p>先证明场景1，根据假设，在Term T到Term U之间的所有Leader都持有log e且e没有被LeaderPre阶段删除过，因此e从Term T开始就没有被任何节点删除过。LeaderT将e至少分发给了F+1个节点，LeaderU至少接收到了F+1个节点的投票响应，根据排容原理，F+1 + F+1 =  N + 1 &gt; N,即至少一个节点接受了e日志且给LeaderU投了票。此Server先一定是先接受了e日志，再给LeaderU投票，否则，它会reject LeaderT的AppendEntris RPC。因为e从Term T开始就没有被删除过，且投票给了LeaderU，因此LeaderU的日志一定至少和此节点的日志一样新，因此LeaderU的日志中一定包含了e，这个假设1存在矛盾。（此证明和Raft经典论文的证明思路一致）</p>
<p>再证明场景2，假设在Term U中e被删除了，有一个无法被恢复的log e1，假设e1不是e，因为e被删除了，因此e1的index一定是小于e的。因为e在Term T中由LeaderT提交且e1的index小于e，因此e1也被提交过。因此e1打破了Leader Completeness Property且index比e小，因此此处矛盾，所以e1一定是e。(这边不是废话吗？论文里假设的就是e在Term U中被删除了)。所以e因为无法正确的恢复而在LeaderPre中被删除。因为e在Term T中被提交，所以至少完整的复制到了F+1个节点上或者以EC Fragment的形式被部分的复制到了至少F+k个节点上，因此e一定是能够被恢复的。此处和假设2产生矛盾。</p>
<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><ol>
<li>新的Leader选出来后，需要做日志恢复，影响性能</li>
<li>LeaderPre会延长选举时间，影响可用性</li>
<li>新选举的Leader恢复所有完整的日志带来的损耗和降低读延迟之间存在取舍</li>
<li>日志滞后的节点当前无法通过snapshot来同步，snapshot机制在CRaft中要复杂的多</li>
<li>编解码会消耗CPU</li>
</ol>
<h4 id="Latency"><a href="#Latency" class="headerlink" title="Latency"></a>Latency</h4><p><img src="/2023/03/25/notes-of-craft/image-20230316162654905-1716311.png" alt="image-20230316162654905"></p>
<p>在value size比较小的时候，几乎没有性能区别，在value size比较大的时候，因为CRaft只做coded-fragment分发，因此性能优势明显。（they reduce 20%–45% of latency compared to Raft when <em>N</em> = 5, and 20%–60.8% when <em>N</em> = 7.）</p>
<h4 id="Throughput"><a href="#Throughput" class="headerlink" title="Throughput"></a>Throughput</h4><p><img src="/2023/03/25/notes-of-craft/image-20230316163237975-1716311.png" alt="image-20230316163237975"></p>
<p>value size比较大的时候，对于带宽的提升明显，大到临界点时，总带宽会降低，因为遇到了网络拥塞问题（CRaft and RS-Raft can have a 180% improvement on write throughput when <em>N</em> = 5 and 250% when <em>N</em> = 7. Also, the throughput peaks of CRaft and RS-Raft both appear much later than Raft’s. ）</p>
<h4 id="Network-Cost"><a href="#Network-Cost" class="headerlink" title="Network Cost"></a>Network Cost</h4><p><img src="/2023/03/25/notes-of-craft/image-20230316164326189-1716311.png" alt="image-20230316164326189"></p>
<p>通过leader端的检测，Craft相较于原始raft协议，在N = 7时，配置不同的k值，raft中leader的数据发送量是Craft的250%~300%</p>
<h4 id="Liveness"><a href="#Liveness" class="headerlink" title="Liveness"></a>Liveness</h4><p>健康节点数为5时，CRaft的带宽不如Rs-Paxos,因为CRaft必须使用complete-log replication</p>
<p>健康节点数为4时，Rs-Paxos无法work。</p>
<table>
<thead>
<tr>
<th>节点数</th>
<th>CRaft可以容忍的失败节点数</th>
<th>RS-Paxos可以容忍的失败节点数</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>7</td>
<td>3</td>
<td>2</td>
</tr>
</tbody></table>
<p><img src="/2023/03/25/notes-of-craft/image-20230316164936694-1716311.png" alt="image-20230316164936694"></p>
<h4 id="Recovery-Read"><a href="#Recovery-Read" class="headerlink" title="Recovery Read"></a>Recovery Read</h4><p>当leader发生切换时，在CRaft中，第一次读取可能需要leader做Recovery，因为leader可能只存储了log的部分fragment，假如leader不发生频繁切换，那么CRaft的read延时和Raft类似，在Recovery Read中，相较于Raft，延时为raft的1.4倍左右，当多次读同一个key时，延迟基本相当。</p>
<p><img src="/2023/03/25/notes-of-craft/image-20230316165402693-1716311.png" alt="image-20230316165402693"></p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><table>
<thead>
<tr>
<th></th>
<th>Raft</th>
<th>RS-Paxos</th>
<th>CRaft</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Storage cost</strong></td>
<td>2F + 1</td>
<td>2F / k + 1</td>
<td>2F / k + 1</td>
</tr>
<tr>
<td><strong>network cost</strong></td>
<td>2F</td>
<td>2F / k</td>
<td>2F / k</td>
</tr>
<tr>
<td><strong>liveness level</strong></td>
<td>F</td>
<td>F - (k - 1) / 2</td>
<td>F</td>
</tr>
<tr>
<td><strong>Commit slave reply cnt</strong></td>
<td>F + 1</td>
<td>F + 1</td>
<td>F + k</td>
</tr>
</tbody></table>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A:"></a>Q&amp;A:</h3><ol>
<li>m和k之间的约束是什么，在实际的工业场景中，此算法的价值如何？</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">现有：m + k = N（1）</span><br><span class="line"></span><br><span class="line">		2F + 1 = N（2）</span><br><span class="line"></span><br><span class="line">需满足：F  + k &lt; N (3)，即不需要commit_all</span><br><span class="line"></span><br><span class="line">由（2）（3）可得：(N - 1) / 2 + k &lt; N，可得k &lt; ( N + 1) / 2 （4）</span><br><span class="line"></span><br><span class="line">由（4）可得：m + k  &lt; m + (N + 1) /2 （5）</span><br><span class="line"></span><br><span class="line">由（1）（5）可得：N &lt; m + (N + 1) /2，可得m &gt; (N - 1) / 2 （6）</span><br><span class="line"></span><br><span class="line">由（2）（6）可得：m &gt; (2F + 1 - 1) / 2，可得m &gt; F</span><br><span class="line"></span><br><span class="line">因为m为整数，所以m至少为F+1。</span><br><span class="line"></span><br><span class="line">当m为F + 1时，由（1）可得，k = F， 此时F + k = 2F，即在最坏的case，要2F个节点确认后才能提交log。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>k</th>
<th>m</th>
<th>commit条件</th>
</tr>
</thead>
<tbody><tr>
<td>F</td>
<td>F + 1</td>
<td>2F</td>
</tr>
<tr>
<td>F - 1</td>
<td>F + 2</td>
<td>2F - 1</td>
</tr>
<tr>
<td>F - 2</td>
<td>F + 3</td>
<td>2F - 2</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>F - x</td>
<td>F + x + 1</td>
<td>2F - x</td>
</tr>
</tbody></table>
<p>2F - x &gt;= F + 1,即 x &lt;= F - 1。</p>
<table>
<thead>
<tr>
<th>k</th>
<th>m</th>
<th>commit条件</th>
</tr>
</thead>
<tbody><tr>
<td>F + 1</td>
<td>F</td>
<td>2F + 1</td>
</tr>
<tr>
<td>F + 2</td>
<td>F - 1</td>
<td>2F + 2 (无法使用CRaft)</td>
</tr>
<tr>
<td>F + 3</td>
<td>F - 2</td>
<td>2F + 3 (无法使用CRaft)</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>F + x</td>
<td>F + x + 1</td>
<td>2F - x (无法使用CRaft)</td>
</tr>
</tbody></table>
<p>结论：</p>
<ol>
<li>按照上面的推导，k比m小的越多，则commit的条件越宽松</li>
<li>在k大于m的场景中，k最小为F+1,m为F，此时F+k = 2F + 1 = N,为commit_all, k再大的话，不满足条件，无法使用CRaft</li>
<li>在实际的场景中，k往往比m大，因此CRaft的应用条件比较有限。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/17/gcc-hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saturn">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/17/gcc-hello-world/" class="post-title-link" itemprop="url">gcc_hello_world</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-17 16:24:10" itemprop="dateCreated datePublished" datetime="2022-05-17T16:24:10+08:00">2022-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-17 14:25:03" itemprop="dateModified" datetime="2023-04-17T14:25:03+08:00">2023-04-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GCC-hello-world"><a href="#GCC-hello-world" class="headerlink" title="GCC hello_world"></a>GCC hello_world</h1><h2 id="将-c文件预处理成-i文件"><a href="#将-c文件预处理成-i文件" class="headerlink" title="将.c文件预处理成.i文件"></a>将.c文件预处理成.i文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>

<p>此阶段称为预处理阶段。</p>
<h2 id="将-i文件汇编成-s文件"><a href="#将-i文件汇编成-s文件" class="headerlink" title="将.i文件汇编成.s文件"></a>将.i文件汇编成.s文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>

<p>此阶段为编译阶段，将预处理文件转为汇编代码文件。</p>
<h2 id="将-s文件转变成-o机器码可执行文件"><a href="#将-s文件转变成-o机器码可执行文件" class="headerlink" title="将.s文件转变成.o机器码可执行文件"></a>将.s文件转变成.o机器码可执行文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>

<p>此阶段将汇编语言转变为二进制机器码。</p>
<h3 id="使用readelf查看二进制文件"><a href="#使用readelf查看二进制文件" class="headerlink" title="使用readelf查看二进制文件"></a>使用readelf查看二进制文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -a hello.o</span><br></pre></td></tr></table></figure>

<h2 id="将-o可执行文件链接成最终可执行程序"><a href="#将-o可执行文件链接成最终可执行程序" class="headerlink" title="将.o可执行文件链接成最终可执行程序"></a>将.o可执行文件链接成最终可执行程序</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 动态链接</span></span></span><br><span class="line">gcc hello.c -o hello</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 静态链接</span></span></span><br><span class="line">gcc hello.c -o hello --static</span><br></pre></td></tr></table></figure>

<h1 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h1><h2 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h2><table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-ansi</td>
<td align="left">只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td>
</tr>
<tr>
<td align="left">-c</td>
<td align="left">只编译并生成目标文件。</td>
</tr>
<tr>
<td align="left">-DMACRO</td>
<td align="left">以字符串”1”定义 MACRO 宏。</td>
</tr>
<tr>
<td align="left">-DMACRO=DEFN</td>
<td align="left">以字符串”DEFN”定义 MACRO 宏。</td>
</tr>
<tr>
<td align="left">-E</td>
<td align="left">只运行 C 预编译器。</td>
</tr>
<tr>
<td align="left">-g</td>
<td align="left">生成调试信息。GNU 调试器可利用该信息。</td>
</tr>
<tr>
<td align="left">-IDIRECTORY</td>
<td align="left">指定额外的头文件搜索路径DIRECTORY。</td>
</tr>
<tr>
<td align="left">-LDIRECTORY</td>
<td align="left">指定额外的函数库搜索路径DIRECTORY。</td>
</tr>
<tr>
<td align="left">-lLIBRARY</td>
<td align="left">连接时搜索指定的函数库LIBRARY。</td>
</tr>
<tr>
<td align="left">-m486</td>
<td align="left">针对 486 进行代码优化。</td>
</tr>
<tr>
<td align="left">-o FILE</td>
<td align="left">生成指定的输出文件。用在生成可执行文件时。</td>
</tr>
<tr>
<td align="left">-O0</td>
<td align="left">不进行优化处理。</td>
</tr>
<tr>
<td align="left">-O 或 -O1</td>
<td align="left">优化生成代码。</td>
</tr>
<tr>
<td align="left">-O2</td>
<td align="left">进一步优化。</td>
</tr>
<tr>
<td align="left">-O3</td>
<td align="left">比 -O2 更进一步优化，包括 inline 函数。</td>
</tr>
<tr>
<td align="left">-shared</td>
<td align="left">生成共享目标文件。通常用在建立共享库时。</td>
</tr>
<tr>
<td align="left">-static</td>
<td align="left">禁止使用共享连接。</td>
</tr>
<tr>
<td align="left">-UMACRO</td>
<td align="left">取消对 MACRO 宏的定义。</td>
</tr>
<tr>
<td align="left">-w</td>
<td align="left">不生成任何警告信息。</td>
</tr>
<tr>
<td align="left">-Wall</td>
<td align="left">生成所有警告信息。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/13/GDB-HELLO-WORLD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saturn">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/13/GDB-HELLO-WORLD/" class="post-title-link" itemprop="url">GDB_HELLO_WORLD</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-13 09:32:05" itemprop="dateCreated datePublished" datetime="2022-05-13T09:32:05+08:00">2022-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-17 14:22:51" itemprop="dateModified" datetime="2023-04-17T14:22:51+08:00">2023-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/knowledge/" itemprop="url" rel="index"><span itemprop="name">knowledge</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="GDB单步跟踪"><a href="#GDB单步跟踪" class="headerlink" title="GDB单步跟踪"></a>GDB单步跟踪</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">gdb + 可执行二进制程序</span><br><span class="line">r   + 参数列表</span><br><span class="line">b   + 断点行数</span><br><span class="line">bt 显示堆栈信息</span><br><span class="line">print 打印表达式值</span><br><span class="line">continue 在一个断点之后继续执行</span><br><span class="line">list 列出源码的一部分</span><br><span class="line">next 在停止之后单步执行</span><br><span class="line">set 设置变量的值</span><br><span class="line">step 进入函数调用</span><br><span class="line">watch 监视一个函数的值</span><br><span class="line">rwatch 监视变量被读暂停程序</span><br><span class="line">awatch 监视变量被读写暂停程序</span><br><span class="line">disable 消除断点</span><br><span class="line">display 在断点停止的地方显示表达式的值</span><br><span class="line">enable 允许断点</span><br><span class="line">finish 继续执行直到函数返回</span><br><span class="line">ignore 忽略断点的次数</span><br><span class="line">info 查看信息</span><br><span class="line">load 动态加载程序到调试器</span><br><span class="line">whatis显示变量的值和类型</span><br><span class="line">ptype 显示变量的类型</span><br><span class="line">return 强制从当前函数返回</span><br><span class="line">make 不退出gdb即可重新产生可执行文件</span><br><span class="line">shel 不退出gdb即可执行linux shell命令</span><br><span class="line">help</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><table>
<thead>
<tr>
<th>参数</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>指定可执行文件名</td>
</tr>
<tr>
<td>-c</td>
<td>指定coredump文件</td>
</tr>
<tr>
<td>-d</td>
<td>指定目录加入到源文件搜索路径</td>
</tr>
<tr>
<td>–cd</td>
<td>指定目录作为路径运行gdb</td>
</tr>
<tr>
<td>-s</td>
<td>指定文件读取符号表</td>
</tr>
<tr>
<td>-p</td>
<td>指定attach进程</td>
</tr>
</tbody></table>
<h2 id="调试进程"><a href="#调试进程" class="headerlink" title="调试进程"></a>调试进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb -p 进程名</span><br><span class="line">gdb attach 进程名</span><br></pre></td></tr></table></figure>

<h2 id="调试线程"><a href="#调试线程" class="headerlink" title="调试线程"></a>调试线程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info thread //列出已允许的进程下的线程</span><br><span class="line">thread 线程号 //切换到线程</span><br></pre></td></tr></table></figure>

<h2 id="查看相关信息"><a href="#查看相关信息" class="headerlink" title="查看相关信息"></a>查看相关信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info　　thread　　  //列出线程</span><br><span class="line">(gdb) info　　register　 //列出寄存器</span><br><span class="line">(gdb) info　　frame　   //列出栈帧</span><br><span class="line">(gdb) info　　files　　//列出当前文件</span><br><span class="line">(gdb) info　　share　 //列出当前共享库</span><br></pre></td></tr></table></figure>

<h2 id="指定程序允许参数"><a href="#指定程序允许参数" class="headerlink" title="指定程序允许参数"></a>指定程序允许参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set args 1 2 3 4</span><br><span class="line">show args</span><br></pre></td></tr></table></figure>

<h2 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">path 设定程序的允许路径</span><br><span class="line">show path</span><br><span class="line">set environment K=v 设置环境变量</span><br><span class="line">show environment 查看环境变量</span><br><span class="line">show language 查看语言环境</span><br><span class="line">info frame 查看函数的程序语言</span><br><span class="line">info source 查看当前文件的程序语言</span><br><span class="line">info breakpoints 显示所有断点</span><br><span class="line">info terminal 显示程序用到的终端模式</span><br></pre></td></tr></table></figure>

<h2 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">break function 进入指定函数时停住</span><br><span class="line">break n 在指定行号停住</span><br><span class="line">break +offset / -offset 在行号后offset行停住或者前offset行停住</span><br><span class="line">break filename:linenum filename的linenum行停住</span><br><span class="line">break filename:function 同理</span><br><span class="line">break *address 在程序运行的内存地址处停住</span><br><span class="line">break 没有参数时表示在下一条指令处停住</span><br></pre></td></tr></table></figure>

<h2 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delte n 删除n号断点</span><br><span class="line">delte 删除所有断点</span><br><span class="line">clear 删除行n上面的所有断点</span><br></pre></td></tr></table></figure>

<h2 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">run/r 程序执行直到遇到断点</span><br><span class="line">continue/c 程序执行直到遇到下个断点</span><br><span class="line">next/n 执行下条语句</span><br><span class="line">step/s 单步进入</span><br><span class="line">finish 跳出当前函数</span><br><span class="line">jump location 直到下一条语句的运行点</span><br><span class="line">print/p 输出变量值</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print num</span><br><span class="line">(gdb) p num</span><br><span class="line">(gdb) print file::variable</span><br><span class="line">(gdb) print function::variable</span><br><span class="line">(gdb) p *array@len</span><br><span class="line"><span class="meta">$</span><span class="bash">1 = &#123;2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">静态数组直接<span class="built_in">print</span> + 数组名就可以打印内容</span></span><br></pre></td></tr></table></figure>

<h2 id="源代码显示"><a href="#源代码显示" class="headerlink" title="源代码显示"></a>源代码显示</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">命令	解析</span><br><span class="line">list n	显示程序第n行的周围的源程序。</span><br><span class="line">list function	显示函数名为function的函数的源程序。</span><br><span class="line">list +n	显示当前行n后面的源程序。</span><br><span class="line">list -n	显示当前行n前面的源程序。</span><br><span class="line">set listsize	设置一次显示源代码的行数。</span><br><span class="line">show listsize	查看当前listsize的设置。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看源代码的内存地址</span></span><br><span class="line">(gdb) info line tst.c:func</span><br><span class="line">Line 5 of &quot;tst.c&quot; starts at address 0x8048456 and ends at 0x804845d .</span><br></pre></td></tr></table></figure>

<h2 id="查看内存地址保存的值"><a href="#查看内存地址保存的值" class="headerlink" title="查看内存地址保存的值"></a>查看内存地址保存的值</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：</span><br><span class="line"></span><br><span class="line">(gdb) x/nfu addr</span><br><span class="line">1</span><br><span class="line">n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。</span><br><span class="line">f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是</span><br><span class="line">指令地址，那么格式可以是i。</span><br><span class="line">u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可</span><br><span class="line">以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当</span><br><span class="line">我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作</span><br><span class="line">一个值取出来。</span><br><span class="line">addr表示一个内存地址。</span><br><span class="line">n/f/u三个参数可以一起使用。例如：</span><br><span class="line"></span><br><span class="line">(gdb) x/3uh 0x54320 //从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。</span><br></pre></td></tr></table></figure>

<h2 id="查看寄存器"><a href="#查看寄存器" class="headerlink" title="查看寄存器"></a>查看寄存器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info registers</span><br><span class="line">info all-registers</span><br></pre></td></tr></table></figure>

<h2 id="显示堆栈"><a href="#显示堆栈" class="headerlink" title="显示堆栈"></a>显示堆栈</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) backtrace [-full] [n]</span><br><span class="line">/*命令产生一张列表，包含着从最近的过程开始的所有有效过程和调用这些过程的参数。</span><br><span class="line">n：一个整数值，当为正整数时，表示打印最里层的 n 个栈帧的信息；n为负整数时，那么表示打印最外层n个栈帧的信息；</span><br><span class="line">-full：打印栈帧信息的同时，打印出局部变量的值</span><br><span class="line">注意，当调试多线程程序时，该命令仅用于打印当前线程中所有栈帧的信息。</span><br><span class="line">如果想要打印所有线程的栈帧信息，应执行thread apply all backtrace命令*/</span><br></pre></td></tr></table></figure>

<h2 id="显示栈帧"><a href="#显示栈帧" class="headerlink" title="显示栈帧"></a>显示栈帧</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">frame 或 f 会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。</span><br><span class="line">查看当前栈帧中存储的信息</span><br><span class="line"></span><br><span class="line">(gdb) info frame</span><br><span class="line">Stack level 0, frame at 0x7ffc1da10e80:</span><br><span class="line"> rip = 0x7f800008b4e3 in __epoll_wait_nocancel; saved rip = 0x5560eac8b902</span><br><span class="line"> called by frame at 0x7ffc1da11280</span><br><span class="line"> Arglist at 0x7ffc1da10e70, args:</span><br><span class="line"> Locals at 0x7ffc1da10e70, Previous frame&#x27;s sp is 0x7ffc1da10e80</span><br><span class="line"> Saved registers:</span><br><span class="line">  rip at 0x7ffc1da10e78</span><br><span class="line"></span><br><span class="line">该命令会依次打印出当前栈帧的如下信息：</span><br><span class="line">1、当前栈帧的编号，以及栈帧的地址；</span><br><span class="line">2、当前栈帧对应函数的存储地址，以及该函数被调用时的代码存储的地址</span><br><span class="line">3、当前函数的调用者，对应的栈帧的地址；</span><br><span class="line">4、编写此栈帧所用的编程语言；</span><br><span class="line">5、函数参数的存储地址以及值；</span><br><span class="line">6、函数中局部变量的存储地址；</span><br><span class="line">7、栈帧中存储的寄存器变量，例如指令寄存器（64位环境中用 rip 表示，32为环境中用eip 表示）、</span><br><span class="line">堆栈基指针寄存器（64位环境用 rbp表示，32位环境用 ebp表示）等。</span><br></pre></td></tr></table></figure>

<h2 id="搜索源代码"><a href="#搜索源代码" class="headerlink" title="搜索源代码"></a>搜索源代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward-search</span><br><span class="line">reverse-search</span><br></pre></td></tr></table></figure>

<h2 id="设置观察点"><a href="#设置观察点" class="headerlink" title="设置观察点"></a>设置观察点</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch 	为表达式(变量)expr设置一个观察点。一旦表达式值有变化时，马上停住程序</span><br><span class="line">(gdb) watch i != 10</span><br><span class="line">//这里，i != 10这个表达式一旦变化，则停住。watch &lt;expr&gt; 为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序(也是一种断点)。</span><br></pre></td></tr></table></figure>

<h2 id="设置捕捉点"><a href="#设置捕捉点" class="headerlink" title="设置捕捉点"></a>设置捕捉点</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可设置捕捉点来补捉程序运行时的一些事件。如载入共享库(动态链接库)或是C++的异常。设置捕捉点的格式为：</span><br><span class="line">//catch 	当event发生时，停住程序</span><br><span class="line">(gdb) info catch</span><br><span class="line">//打印出当前的函数中的异常处理信息。</span><br><span class="line">(gdb) info locals</span><br><span class="line">//打印出当前函数中所有局部变量及其值。</span><br></pre></td></tr></table></figure>

<h2 id="强制调用函数"><a href="#强制调用函数" class="headerlink" title="强制调用函数"></a>强制调用函数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) call &lt;expr&gt;</span><br><span class="line">/*这里,&lt;expr&gt;可以是一个函数，这样就会返回函数的返回值，如果函数的返回类型是void那么就不会打印函数的返回值,但是实践发现，函数运行过程中的打印语句还是没有被打印出来。</span><br><span class="line">表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返</span><br><span class="line">回值是void，那么就不显示。*/</span><br></pre></td></tr></table></figure>

<h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill 终止正在调试的程序</span><br><span class="line">detach 将gdb和程序分离</span><br><span class="line">q 退出gdb</span><br></pre></td></tr></table></figure>

<h2 id="打印美化"><a href="#打印美化" class="headerlink" title="打印美化"></a>打印美化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set print pretty on</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/04/DAOS-simple-obj-example/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saturn">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/04/DAOS-simple-obj-example/" class="post-title-link" itemprop="url">DAOS-simple-obj-example</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-04 10:41:13" itemprop="dateCreated datePublished" datetime="2022-02-04T10:41:13+08:00">2022-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-17 14:21:47" itemprop="dateModified" datetime="2023-04-17T14:21:47+08:00">2023-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/knowledge/" itemprop="url" rel="index"><span itemprop="name">knowledge</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Daos-simple-Obj"><a href="#Daos-simple-Obj" class="headerlink" title="Daos simple Obj"></a>Daos simple Obj</h1><h2 id="Connect-Pool"><a href="#Connect-Pool" class="headerlink" title="Connect Pool"></a>Connect Pool</h2><h2 id="Create-Container"><a href="#Create-Container" class="headerlink" title="Create Container"></a>Create Container</h2><h2 id="Example-daos-key-array"><a href="#Example-daos-key-array" class="headerlink" title="Example_daos_key_array"></a>Example_daos_key_array</h2><ol>
<li><p>daos_obj_generate_oid</p>
<ol>
<li>poh = dc_cont_hdl2pool_hdl(coh); // 获取cookie</li>
<li>pool = dc_hdl2pool(poh); //获取pool<ol>
<li>获取plmap，一个双向链表</li>
<li>获取pool</li>
</ol>
</li>
</ol>
</li>
<li><p>daos_obj_open(coh, oid, DAOS_OO_RW, &amp;oh, NULL);</p>
<ol>
<li>rc = dc_obj_open_task_create(coh, oid, mode, oh, ev, NULL, &amp;task); //创建task</li>
<li>dc_task_schedule(tse_task_t *task, bool instant)//执行task</li>
</ol>
</li>
<li><p>dts_buf_render//创建buffer</p>
</li>
<li><p>循环创建十个Dkey：</p>
<ol>
<li><p>d_iov_set(&amp;dkey, dkey_str, strlen(dkey_str));//初始化dkey</p>
</li>
<li><p>rc = daos_obj_update(oh, DAOS_TX_NONE, 0, &amp;dkey, 1, &amp;iod, &amp;sgl,NULL);//更新dkey，一个dkey下只有一个akey，因此只有1个oid和一个sgl.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">iod // iovec for memory buffer</span><br><span class="line">&#123;...&#125;</span><br><span class="line">iod_name</span><br><span class="line">iov_buf:0x5555555596e4</span><br><span class="line">iov_buf_len:4</span><br><span class="line">iov_len:4</span><br><span class="line">iod_type:DAOS_IOD_ARRAY</span><br><span class="line">iod_size:1</span><br><span class="line">iod_flags:0</span><br><span class="line">iod_nr:1</span><br><span class="line">iod_recxs:0x7fffffffd710</span><br><span class="line">rx_idx:0</span><br><span class="line">rx_nr:1024</span><br><span class="line">------------</span><br><span class="line">sgl  // scatter and gather list for memory buffers</span><br><span class="line">&#123;...&#125;</span><br><span class="line">sg_nr:1</span><br><span class="line">sg_nr_out:0</span><br><span class="line">sg_iovs:0x7fffffffd740</span><br><span class="line">iov_buf:0x7fffffffd7c0</span><br><span class="line">iov_buf_len:1024</span><br><span class="line">iov_len:1024</span><br><span class="line">------------</span><br><span class="line">daos_recx_t // 记录array的第一个元素地址和其中的元素个数</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>循环fetch 10个dkey</p>
</li>
<li><p>遍历所有的dkey</p>
</li>
<li><p>删除一个dkey</p>
</li>
<li><p>遍历所有dkey，现在只有9个dkey了</p>
</li>
<li><p>daos_obj_close(oh, NULL);//关闭obj</p>
</li>
</ol>
<h2 id="example-daos-key-sv"><a href="#example-daos-key-sv" class="headerlink" title="example_daos_key_sv()"></a>example_daos_key_sv()</h2><ol>
<li><p>daos_obj_generate_oid(coh, &amp;oid, 0, OC_SX, 0, 0);</p>
</li>
<li><p>rc = daos_obj_open(coh, oid, DAOS_OO_RW, &amp;oh, NULL);</p>
</li>
<li><p>dts_buf_render(buf, BUFLEN);</p>
</li>
<li><p>rc = daos_obj_update(oh, DAOS_TX_NONE, 0, &amp;dkey, 1, &amp;iod, &amp;sgl,NULL);</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">oh</span><br><span class="line">&#123;...&#125;</span><br><span class="line">cookie:71</span><br><span class="line">dkey</span><br><span class="line">&#123;...&#125;</span><br><span class="line">iov_buf:0x7fffffffd780</span><br><span class="line">iov_buf_len:6</span><br><span class="line">iov_len:6</span><br><span class="line">iod</span><br><span class="line">&#123;...&#125;</span><br><span class="line">iod_name</span><br><span class="line">iod_type:DAOS_IOD_SINGLE</span><br><span class="line">iod_size:1024</span><br><span class="line">iod_flags:4</span><br><span class="line">iod_nr:1</span><br><span class="line">iod_recxs:0x0</span><br><span class="line">rx_idx</span><br><span class="line">rx_nr</span><br><span class="line">&#123;...&#125;</span><br><span class="line">sg_nr:1</span><br><span class="line">sg_nr_out:0</span><br><span class="line">sg_iovs:0x7fffffffd720</span><br><span class="line">iov_buf:0x7fffffffd7c0</span><br><span class="line">iov_buf_len:1024</span><br><span class="line">iov_len:1024</span><br></pre></td></tr></table></figure></li>
<li><p>循环10次，创建10个dkey，每个dkey有一个akey和一个1k的single value：</p>
<ol>
<li>初始化参数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> iod.iod_nr	= <span class="number">1</span>; <span class="comment">/** has to be 1 for single value */</span></span><br><span class="line">iod.iod_size	= BUFLEN; <span class="comment">/** size of the single value */</span></span><br><span class="line">iod.iod_recxs	= <span class="literal">NULL</span>; <span class="comment">/** recx is ignored for single value */</span></span><br><span class="line">iod.iod_type	= DAOS_IOD_SINGLE; <span class="comment">/** value type of the akey */</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>rc = daos_obj_update(oh, DAOS_TX_NONE, 0, &amp;dkey, 1, &amp;iod, &amp;sgl,<br>NULL);</li>
</ol>
</li>
<li><p>循环10次update：</p>
<ol>
<li>rc = daos_obj_update(oh, DAOS_TX_NONE, 0, &amp;dkey, 1, &amp;iod, &amp;sgl, NULL);</li>
</ol>
</li>
<li><p>循环10次fetch：</p>
<ol>
<li>rc = daos_obj_fetch(oh, DAOS_TX_NONE, 0, &amp;dkey, 1, &amp;iod, &amp;sgl, NULL, NULL);</li>
</ol>
</li>
</ol>
<h2 id="example-daos-array"><a href="#example-daos-array" class="headerlink" title="example_daos_array()"></a>example_daos_array()</h2><ol>
<li><p>daos_array_generate_oid(coh, &amp;oid, true, 0, 0, 0);</p>
</li>
<li><p>Create the array object with cell size 1 (byte array) and 1m chunk size (similar to stripe size in Lustre). Both are configurable by the user of course :</p>
<p>rc = daos_array_create(coh, oid, DAOS_TX_NONE, 1, 1048576, &amp;oh,<br>NULL);</p>
</li>
<li><p>rc = daos_array_write(oh, DAOS_TX_NONE, &amp;iod, &amp;sgl, NULL);</p>
</li>
<li><p>rc = daos_array_get_size(oh, DAOS_TX_NONE, &amp;array_size, NULL); // check size</p>
</li>
<li><p>rc = daos_array_read(oh, DAOS_TX_NONE, &amp;iod, &amp;sgl, NULL); // read &amp; verify</p>
</li>
<li><p>daos_array_close(oh, NULL); //close</p>
</li>
</ol>
<h2 id="example-daos-kv"><a href="#example-daos-kv" class="headerlink" title="example_daos_kv()"></a>example_daos_kv()</h2><p>Abstract iyt the 2-level keys and exposes a single Key and atomic value to represent a more traditional KV API.</p>
<ol>
<li>daos_obj_generate_oid(coh, &amp;oid, DAOS_OT_KV_HASHED, OC_SX, 0, 0);</li>
<li>rc = daos_kv_open(coh, oid, DAOS_OO_RW, &amp;oh, NULL);</li>
<li>dts_buf_render(buf, BUFLEN);</li>
<li>循环10次，为rank0 put 10个key：<ol>
<li>rc = daos_kv_put(oh, DAOS_TX_NONE, 0, key, BUFLEN, buf, NULL);</li>
</ol>
</li>
<li>循环10次：<ol>
<li>rc = daos_kv_get(oh, DAOS_TX_NONE, 0, key, &amp;size, NULL, NULL); // query size &amp; verify</li>
<li>rc = daos_kv_get(oh, DAOS_TX_NONE, 0, key, &amp;size, rbuf, NULL); // get data write into rbuf</li>
<li>memcmp(buf, rbuf, BUFLEN) // verify</li>
</ol>
</li>
<li>list_keys(oh, &amp;num_keys); // 10个key</li>
<li>rc = daos_kv_remove(oh, DAOS_TX_NONE, 0, key, NULL); // remove a key</li>
<li>list_keys(oh, &amp;num_keys); // 9个key</li>
<li>daos_kv_close(oh, NULL);</li>
</ol>
<h2 id="daos-cont-close-coh-NULL"><a href="#daos-cont-close-coh-NULL" class="headerlink" title="daos_cont_close(coh, NULL);"></a>daos_cont_close(coh, NULL);</h2><h2 id="daos-pool-disconnect-poh-NULL"><a href="#daos-pool-disconnect-poh-NULL" class="headerlink" title="daos_pool_disconnect(poh, NULL)"></a>daos_pool_disconnect(poh, NULL)</h2><h2 id="daos-fini"><a href="#daos-fini" class="headerlink" title="daos_fini();"></a>daos_fini();</h2><h2 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h2><h3 id="daos-obj-generate-oid"><a href="#daos-obj-generate-oid" class="headerlink" title="daos_obj_generate_oid"></a>daos_obj_generate_oid</h3><ol>
<li>输入：<ul>
<li>daos_handle_t oh ： 存储了一个unsigned int 64的cookie</li>
<li>daos_obj_id_t  oid : daos object id, 用两个64位int 存储 lo（low）和 high （high）</li>
<li>enum DAOS_OT_KV_HASHED :  flat KV (no akey) with integer dkey </li>
<li>OC_SX ：OC策略</li>
<li>0 ：边长参数</li>
<li>0 ：变长参数</li>
</ul>
</li>
<li>实现，内部调用了<code>daos_obj_generate_oid2</code><ul>
<li>输入：<ul>
<li>daos_handle_t</li>
<li>daos_obj_id_t</li>
<li>daos_otype_t</li>
<li>daos_oclass_id_t ： object class id， 32位int</li>
<li>daos_oclass_hints_t  ：object class hint， 16位int</li>
<li>args : 其他int参数</li>
</ul>
</li>
<li>dc_cont_hdl2pool_hdl<ul>
<li>根据cookie获取pool handler</li>
</ul>
</li>
<li>rc = pl_map_query(pool-&gt;dp_pool, &amp;attr)</li>
<li>dc_pool_put(struct dc_pool *pool) // 将pool-&gt;dp_hlink放入了一个双向队列中？</li>
<li>按照选定的OC策略做相应的操作</li>
<li>daos_obj_set_oid(oid, type, ord, nr_grp, args); // 就生成好了？</li>
</ul>
</li>
</ol>
<h3 id="daos-kv-open"><a href="#daos-kv-open" class="headerlink" title="daos_kv_open"></a>daos_kv_open</h3><ol>
<li>输入：<ul>
<li>daos_handle_t</li>
<li>daos_obj_id_t</li>
<li>mode : int 类型</li>
<li>daos_handle_t</li>
<li>daos_event_t : event and event queue, maybe used for debug</li>
</ul>
</li>
<li>调用<code>rc = dc_task_create(dc_kv_open, NULL, ev, &amp;task)</code><ul>
<li>将参数包装成dc_kv_open结构体</li>
<li>生成一个kvOpen的task并调度</li>
</ul>
</li>
</ol>
<h3 id="dts-buf-render-buf-BUFLEN"><a href="#dts-buf-render-buf-BUFLEN" class="headerlink" title="dts_buf_render(buf, BUFLEN)"></a>dts_buf_render(buf, BUFLEN)</h3><ol>
<li>输入buf和len</li>
<li>利用随机生成的字符填满buf</li>
</ol>
<h3 id="daos-kev-put"><a href="#daos-kev-put" class="headerlink" title="daos_kev_put"></a>daos_kev_put</h3><ol>
<li>输入：<ul>
<li>daos_handle_t oh</li>
<li>daos_handle_t th</li>
<li>uint64_t flag</li>
<li>char * key</li>
<li>daos_size_t buf_size</li>
<li>void * buf</li>
<li>daos_event_t * ev</li>
</ul>
</li>
<li>调用rc = dc_task_create(dc_kv_put, NULL, ev, &amp;task);</li>
<li>将参数包装到task的args中</li>
<li>调用dc_task_schedule(task, true);<ol>
<li>task_is_valid(task)</li>
<li>ev = task_ptr2args(task)-&gt;ta_ev;</li>
<li>rc = daos_event_launch(ev);<ul>
<li>输入：daos_event *ev</li>
</ul>
</li>
<li>rc = tse_task_schedule(task, instant);</li>
</ol>
</li>
</ol>
<h3 id="kv-update"><a href="#kv-update" class="headerlink" title="kv_update"></a>kv_update</h3><ol>
<li><p>daos_io_0线程接收到io请求，crt_handle_rpc(void *arg)处理rpc</p>
</li>
<li><p>ds_obj_rw_handler(crt_rpc_t *rpc)处理rpc</p>
<ul>
<li><p>obj_ioc_begin(orw-&gt;orw_oid.id_pub, orw-&gt;orw_map_ver,</p>
<p>​               orw-&gt;orw_pool_uuid, orw-&gt;orw_co_hdl,</p>
<p>​               orw-&gt;orw_co_uuid, opc_get(rpc-&gt;cr_opc),</p>
<p>​               orw-&gt;orw_flags, &amp;ioc); // various check before access VOS</p>
</li>
</ul>
</li>
<li><p>​    rc = process_epoch(&amp;orw-&gt;orw_epoch, &amp;orw-&gt;orw_epoch_first,</p>
<p>​               &amp;orw-&gt;orw_flags); // 处理epoch相关</p>
</li>
</ol>
<h2 id="Object-Update"><a href="#Object-Update" class="headerlink" title="Object_Update"></a>Object_Update</h2><ol>
<li><p>callstack</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">libvos_srv.so!dkey_update(<span class="keyword">daos_key_t</span> * dkey, <span class="keyword">uint32_t</span> pm_ver, struct vos_io_context * ioc) (/home/kuhan/daos/src/vos/vos_io.c:<span class="number">1803</span>)</span><br><span class="line">libvos_srv.so!vos_update_end(<span class="keyword">daos_handle_t</span> ioh, <span class="keyword">uint32_t</span> pm_ver, <span class="keyword">daos_key_t</span> * dkey, <span class="keyword">int</span> err, <span class="keyword">daos_size_t</span> * size, struct dtx_handle * dth) (/home/kuhan/daos/src/vos/vos_io.c:<span class="number">2278</span>)</span><br><span class="line">libobj.so!obj_rw_complete(struct dtx_handle * dth, <span class="keyword">int</span> status, <span class="keyword">daos_handle_t</span> ioh, struct obj_io_context * ioc, <span class="keyword">crt_rpc_t</span> * rpc) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">128</span>)</span><br><span class="line">libobj.so!obj_local_rw_internal(struct dtx_handle * dth, <span class="keyword">uint64_t</span> * split_offs, struct dcs_iod_csums * split_csums, <span class="keyword">daos_iod_t</span> * split_iods, struct obj_io_context * ioc, <span class="keyword">crt_rpc_t</span> * rpc) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">1677</span>)</span><br><span class="line">libobj.so!obj_local_rw(<span class="keyword">crt_rpc_t</span> * rpc, struct obj_io_context * ioc, <span class="keyword">daos_iod_t</span> * split_iods, struct dcs_iod_csums * split_csums, <span class="keyword">uint64_t</span> * split_offs, struct dtx_handle * dth, <span class="built_in">_Bool</span> pin) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">1697</span>)</span><br><span class="line">libobj.so!obj_tgt_update(<span class="keyword">dtx_sub_comp_cb_t</span> comp_cb, <span class="keyword">void</span> * arg, struct dtx_leader_handle * dlh) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">2425</span>)</span><br><span class="line">libobj.so!obj_tgt_update(struct dtx_leader_handle * dlh, <span class="keyword">void</span> * arg, <span class="keyword">int</span> idx, <span class="keyword">dtx_sub_comp_cb_t</span> comp_cb) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">2356</span>)</span><br><span class="line">libobj.so!ds_obj_rw_handler(<span class="keyword">crt_rpc_t</span> * rpc) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">2664</span>)</span><br><span class="line">libcart.so<span class="number">.4</span>!crt_handle_rpc(<span class="keyword">void</span> * arg) (/home/kuhan/daos/src/cart/crt_rpc.c:<span class="number">1638</span>)</span><br><span class="line">libabt.so<span class="number">.1</span>!ABTD_ythread_func_wrapper (未知源:<span class="number">0</span>)</span><br><span class="line">libabt.so<span class="number">.1</span>!make_fcontext (未知源:<span class="number">0</span>)</span><br><span class="line">[Unknown/Just-In-Time compiled code] (未知源:<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="obj-local-rw-internal"><a href="#obj-local-rw-internal" class="headerlink" title="obj_local_rw_internal"></a>obj_local_rw_internal</h3><ol>
<li><p>​        rc = vos_update_begin(ioc-&gt;ioc_vos_coh, orw-&gt;orw_oid,</p>
<p>​                  orw-&gt;orw_epoch, cond_flags, dkey,</p>
<p>​                  orw-&gt;orw_nr, iods, iod_csums,</p>
<p>​                  ioc-&gt;ioc_coc-&gt;sc_props.dcp_dedup_size,</p>
<p>​                  &amp;ioh, dth);</p>
<ul>
<li><p>rc = vos_check_akeys(iod_nr, iods);</p>
</li>
<li><p>vos_ioc_create</p>
</li>
<li><p> rc = vos_space_hold(vos_cont2pool(ioc-&gt;ic_cont), flags, dkey, iod_nr,</p>
</li>
</ul>
<p>  ​                iods, iods_csums, &amp;ioc-&gt;ic_space_held[0]);</p>
<ul>
<li><p>rc = dkey_update_begin(ioc);</p>
<ul>
<li><p>循环rc = akey_update_begin(ioc);</p>
<ul>
<li><p>获取dcs_csum_info</p>
</li>
<li><p>获取daos_iod_t,1k</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iod</span><br><span class="line"><span class="number">0x7f9a07a4dee0</span></span><br><span class="line">iod_name</span><br><span class="line">iod_type:DAOS_IOD_ARRAY</span><br><span class="line">iod_size:<span class="number">1</span></span><br><span class="line">iod_flags:<span class="number">0</span></span><br><span class="line">iod_nr:<span class="number">1</span></span><br><span class="line">iod_recxs:<span class="number">0x7f9a07e9fbf0</span></span><br><span class="line">rx_idx:<span class="number">0</span></span><br><span class="line">rx_nr:<span class="number">1024</span></span><br></pre></td></tr></table></figure></li>
<li><p>for (i = 0; i &lt; iod-&gt;iod_nr; i++) //循环</p>
<ul>
<li><p>size = (iod-&gt;iod_type == DAOS_IOD_SINGLE) ? iod-&gt;iod_size :</p>
<p>​                iod-&gt;iod_recxs[i].rx_nr * iod-&gt;iod_size; //获取size，1k–1024</p>
</li>
<li><p>media = vos_media_select(vos_cont2pool(ioc-&gt;ic_cont),</p>
<p>​                     iod-&gt;iod_type, size); //决定往哪个media上写，0 –&gt; scm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A simple media selection policy embedded in VOS, which select media by</span></span><br><span class="line"><span class="comment"> * akey type and record size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint16_t</span></span></span><br><span class="line"><span class="function"><span class="title">vos_media_select</span><span class="params">(struct vos_pool *pool, <span class="keyword">daos_iod_type_t</span> type, <span class="keyword">daos_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;vp_vea_info == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> DAOS_MEDIA_SCM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (size &gt;= VOS_BLK_SZ) ? DAOS_MEDIA_NVME : DAOS_MEDIA_SCM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首先做特判</span></span><br><span class="line"><span class="comment">// 如果大于等于4k，写到NVME上，否则写到SCM</span></span><br></pre></td></tr></table></figure></li>
<li><p>iod-&gt;iod_type<br>为 DAOS_IOD_ARRAY类型：</p>
<ul>
<li><p>rc = vos_reserve_recx(ioc, media, size, recx_csum, csum_len);</p>
<ul>
<li><p>为    struct bio_iov  biov 分配内存</p>
</li>
<li><p>rc = reserve_space(ioc, media, size, &amp;off);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">oc</span><br><span class="line"><span class="number">0x7f9a0724ef00</span></span><br><span class="line">ic_ent_array_alloc</span><br><span class="line">ea_data</span><br><span class="line">ea_ents:<span class="number">0x0</span></span><br><span class="line">ea_ent_nr:<span class="number">0</span></span><br><span class="line">ea_size:<span class="number">0</span></span><br><span class="line">ea_max:<span class="number">0</span></span><br><span class="line">ea_inob:<span class="number">0</span></span><br><span class="line">ea_first_delete:<span class="number">0</span></span><br><span class="line">ea_delete_nr:<span class="number">0</span></span><br><span class="line">ea_embedded_ents</span><br><span class="line">ea_embedded</span><br><span class="line">ic_ent_array:<span class="number">0x0</span></span><br><span class="line">ic_bound:<span class="number">509171074455830528</span></span><br><span class="line">ic_epr</span><br><span class="line">ic_oid</span><br><span class="line">ic_cont:<span class="number">0x7f9a07e9eb60</span></span><br><span class="line">ic_iods:<span class="number">0x7f9a07a4dee0</span></span><br><span class="line">iod_csums:<span class="number">0x0</span></span><br><span class="line">ic_obj:<span class="number">0x0</span></span><br><span class="line">ic_biod:<span class="number">0x7f99c89c63b0</span></span><br><span class="line">ic_ts_set:<span class="number">0x7f99c89c6f90</span></span><br><span class="line">ic_biov_csums:<span class="number">0x7f99c87c76e0</span></span><br><span class="line">ic_biov_csums_at:<span class="number">0</span></span><br><span class="line">ic_biov_csums_nr:<span class="number">1</span></span><br><span class="line">ic_dkey_info</span><br><span class="line">ic_akey_info</span><br><span class="line">ic_sgl_at:<span class="number">0</span></span><br><span class="line">ic_iov_at:<span class="number">0</span></span><br><span class="line">ic_rsrvd_scm:<span class="number">0x7f9a07e86980</span></span><br><span class="line">ic_umoffs:<span class="number">0x7f9a07e9e6a0</span></span><br><span class="line">ic_umoffs_cnt:<span class="number">0</span></span><br><span class="line">ic_umoffs_at:<span class="number">0</span></span><br><span class="line">  ic_blk_exts</span><br><span class="line">next:<span class="number">0x7f9a0724fb38</span></span><br><span class="line">prev:<span class="number">0x7f9a0724fb38</span></span><br><span class="line">ic_space_held</span><br><span class="line">ic_iod_nr:<span class="number">1</span></span><br><span class="line">ic_dedup_th:<span class="number">4096</span></span><br><span class="line">ic_dedup_entries</span><br><span class="line">ic_dedup_bsgls:<span class="number">0x0</span></span><br><span class="line">ic_dedup_bufs:<span class="number">0x0</span></span><br><span class="line">ic_io_size:<span class="number">0</span></span><br><span class="line">ic_update:<span class="number">1</span></span><br><span class="line">ic_size_fetch:<span class="number">0</span></span><br><span class="line">ic_save_recx:<span class="number">0</span></span><br><span class="line">ic_dedup:<span class="number">0</span></span><br><span class="line">ic_dedup_verify:<span class="number">0</span></span><br><span class="line">ic_read_ts_only:<span class="number">0</span></span><br><span class="line">ic_check_existence:<span class="number">0</span></span><br><span class="line">ic_remove:<span class="number">0</span></span><br><span class="line">ic_skip_fetch:<span class="number">0</span></span><br><span class="line">ic_ec:<span class="number">0</span></span><br><span class="line">ic_shadows:<span class="number">0x0</span></span><br><span class="line">re_nr</span><br><span class="line">re_total</span><br><span class="line">re_snapshot</span><br><span class="line">re_ep_valid</span><br><span class="line">re_items</span><br><span class="line">ic_recx_lists:<span class="number">0x0</span></span><br><span class="line">re_nr</span><br><span class="line">re_total</span><br><span class="line">re_snapshot</span><br><span class="line">re_ep_valid</span><br><span class="line">re_items</span><br></pre></td></tr></table></figure>

<ul>
<li>在SCM上申请内存</li>
</ul>
</li>
<li><p>bio_addr_set(&amp;biov.bi_addr, media, off);//设置偏移量</p>
</li>
<li><p>bio_iov_set_len(&amp;biov, size); //设置长度</p>
</li>
<li><p>rc = iod_reserve(ioc, &amp;biov);</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>*ioh = vos_ioc2ioh(ioc); //获取cookie？</p>
</li>
</ul>
</li>
<li><p>biod = vos_ioh2desc(ioh); //获取io descriptor？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7f99c89c63b0</span></span><br><span class="line">bd_ctxt:<span class="number">0x7f99c89b0650</span></span><br><span class="line">bic_link</span><br><span class="line">bic_umem:<span class="number">0x7f99c860ab58</span></span><br><span class="line">bic_pmempool_uuid:<span class="number">12137328209446634291</span></span><br><span class="line">bic_blob:<span class="number">0x7f99c89b1530</span></span><br><span class="line">bic_xs_ctxt:<span class="number">0x7f9a04427370</span></span><br><span class="line">bic_inflight_dmas:<span class="number">0</span></span><br><span class="line">bic_io_unit:<span class="number">4096</span></span><br><span class="line">bic_pool_id</span><br><span class="line">bic_opening:<span class="number">0</span></span><br><span class="line">bic_closing:<span class="number">0</span></span><br><span class="line">bd_rsrvd</span><br><span class="line">brd_regions:<span class="number">0x0</span></span><br><span class="line">brd_rg_max:<span class="number">0</span></span><br><span class="line">brd_rg_cnt:<span class="number">0</span></span><br><span class="line">brd_dma_chks:<span class="number">0x0</span></span><br><span class="line">brd_chk_max:<span class="number">0</span></span><br><span class="line">brd_chk_cnt:<span class="number">0</span></span><br><span class="line">bd_dma_done:<span class="number">0x10</span></span><br><span class="line">bd_inflights:<span class="number">0</span></span><br><span class="line">bd_result:<span class="number">0</span></span><br><span class="line">bd_chk_type:<span class="number">0</span></span><br><span class="line">bd_type:<span class="number">0</span></span><br><span class="line">bd_buffer_prep:<span class="number">0</span></span><br><span class="line">bd_dma_issued:<span class="number">0</span></span><br><span class="line">bd_retry:<span class="number">0</span></span><br><span class="line">bd_rdma:<span class="number">0</span></span><br><span class="line">bd_bulk_hdls:<span class="number">0x0</span></span><br><span class="line">bd_bulk_max:<span class="number">0</span></span><br><span class="line">bd_bulk_cnt:<span class="number">0</span></span><br><span class="line">bd_sgl_cnt:<span class="number">1</span></span><br><span class="line">bd_sgls</span><br></pre></td></tr></table></figure></li>
<li><p>rc = bio_iod_prep(biod, BIO_CHK_TYPE_IO, rma ? rpc-&gt;cr_ctx : NULL,CRT_BULK_RW);</p>
<ul>
<li><p>rc = iterate_biov(biod, arg ? bulk_map_one : dma_map_one, arg);</p>
<ul>
<li><p>for循环：rc = cb_fn(biod, biov, data);  // 函数指针调用，此处写SCM</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">biod</span><br><span class="line"><span class="number">0x7f99c89c63b0</span></span><br><span class="line">bd_ctxt:<span class="number">0x7f99c89b0650</span></span><br><span class="line">bic_link</span><br><span class="line">bic_umem:<span class="number">0x7f99c860ab58</span></span><br><span class="line">bic_pmempool_uuid:<span class="number">12137328209446634291</span></span><br><span class="line">bic_blob:<span class="number">0x7f99c89b1530</span></span><br><span class="line">bic_xs_ctxt:<span class="number">0x7f9a04427370</span></span><br><span class="line">bic_inflight_dmas:<span class="number">0</span></span><br><span class="line">bic_io_unit:<span class="number">4096</span></span><br><span class="line">bic_pool_id</span><br><span class="line">bic_opening:<span class="number">0</span></span><br><span class="line">bic_closing:<span class="number">0</span></span><br><span class="line">bd_rsrvd</span><br><span class="line">bd_dma_done:<span class="number">0x10</span></span><br><span class="line">bd_inflights:<span class="number">0</span></span><br><span class="line">bd_result:<span class="number">0</span></span><br><span class="line">bd_chk_type:<span class="number">0</span></span><br><span class="line">bd_type:<span class="number">0</span></span><br><span class="line">bd_buffer_prep:<span class="number">0</span></span><br><span class="line">bd_dma_issued:<span class="number">0</span></span><br><span class="line">bd_retry:<span class="number">0</span></span><br><span class="line">bd_rdma:<span class="number">0</span></span><br><span class="line">bd_bulk_hdls:<span class="number">0x0</span></span><br><span class="line">bd_bulk_max:<span class="number">0</span></span><br><span class="line">bd_bulk_cnt:<span class="number">0</span></span><br><span class="line">bd_sgl_cnt:<span class="number">1</span></span><br><span class="line">bd_sgls</span><br><span class="line">--------------</span><br><span class="line">biov</span><br><span class="line"><span class="number">0x7f9a07e9eeb0</span></span><br><span class="line">bi_buf:<span class="number">0x0</span></span><br><span class="line">bi_data_len:<span class="number">1024</span></span><br><span class="line">bi_addr</span><br><span class="line">ba_off:<span class="number">4576720</span></span><br><span class="line">ba_type:<span class="number">0</span> <span class="string">&#x27;\000&#x27;</span></span><br><span class="line">ba_pad1:<span class="number">0</span> <span class="string">&#x27;\000&#x27;</span></span><br><span class="line">ba_flags:<span class="number">0</span></span><br><span class="line">ba_pad2:<span class="number">0</span></span><br><span class="line">bi_prefix_len:<span class="number">0</span></span><br><span class="line">bi_suffix_len:<span class="number">0</span></span><br><span class="line">--------------</span><br><span class="line">data</span><br><span class="line"><span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>函数指针调用dma_map_one(struct bio_desc *biod, struct bio_iov *biov, void *arg)</p>
<p>// /* Convert offset of @biov into memory pointer */</p>
<ul>
<li>direct_scm_access(biod, biov):<ul>
<li>bio_iov_set_raw_buf(biov,umem_off2ptr(umem, bio_iov2raw_off(biov)));</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>rc = bio_iod_copy(biod, orw-&gt;orw_sgls.ca_arrays, orw-&gt;orw_nr);</p>
<ul>
<li>将参数包装成bio_copy_args结构体</li>
<li>iterate_biov(biod, copy_one, &amp;arg);</li>
</ul>
</li>
<li><p>rc = vos_dedup_verify(ioh);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check if the dedup data is identical to the RDMA data in a temporal</span></span><br><span class="line"><span class="comment"> * allocated DRAM extent, if memcmp fails, allocate a new SCM extent and</span></span><br><span class="line"><span class="comment"> * update it&#x27;s address in VOS tree, otherwise, keep using the original</span></span><br><span class="line"><span class="comment"> * dedup data address in VOS tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
<li><p>rc = obj_verify_bio_csum(orw-&gt;orw_oid.id_pub, iods, iod_csums,biod, ioc-&gt;ioc_coc-&gt;sc_csummer,orw-&gt;orw_iod_array.oia_iod_nr); //verify CSUM</p>
</li>
<li><p>rc = obj_rw_complete(rpc, ioc, ioh, rc, dth); // the callstack is deep inside this function…</p>
<ul>
<li><p>rc = vos_update_end(ioh, ioc-&gt;ioc_map_ver,&amp;orwi-&gt;orw_dkey, status,&amp;ioc-&gt;ioc_io_size, dth);</p>
<ul>
<li><p>一些dtx commit逻辑？</p>
</li>
<li><p>err = dkey_update(ioc, pm_ver, dkey, dtx_is_valid_handle(dth) ? dth-&gt;dth_op_seq : VOS_SUB_OP_MAX); // update tree index</p>
<ul>
<li><p>rc = obj_tree_init(obj); // initialize tree for an object</p>
</li>
<li><p>rc = key_tree_prepare(obj, obj-&gt;obj_toh, VOS_BTR_DKEY, dkey,SUBTR_CREATE, DAOS_INTENT_UPDATE, &amp;krec, &amp;ak_toh,ioc-&gt;ic_ts_set);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the subtree roots embedded in the parent tree record.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * akey tree	: all akeys under the same dkey</span></span><br><span class="line"><span class="comment"> * recx tree	: all record extents under the same akey, this function will</span></span><br><span class="line"><span class="comment"> *		  load both btree and evtree root.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="comment">/* NB: In order to avoid complexities of passing parameters to the</span></span><br><span class="line"><span class="comment">	 * multi-nested tree, tree operations are not nested, instead:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * - In the case of fetch, we load the subtree root stored in the</span></span><br><span class="line"><span class="comment">	 *   parent tree leaf.</span></span><br><span class="line"><span class="comment">	 * - In the case of update/insert, we call dbtree_update() which may</span></span><br><span class="line"><span class="comment">	 *   create the root for the subtree, or just return it if it&#x27;s already</span></span><br><span class="line"><span class="comment">	 *   there.</span></span><br><span class="line"><span class="comment">	 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>rc = dbtree_fetch(toh, BTR_PROBE_EQ, intent, key,NULL, &amp;riov);</p>
</li>
<li><p>/* use BTR_PROBE_BYPASS to avoid probe again */</p>
<p>rc = dbtree_upsert(toh, BTR_PROBE_BYPASS, intent, key, &amp;riov);</p>
<ul>
<li><pre><code class="c">Update the value of the provided key, or insert it as a new key if
 * there is no match.
</code></pre>
</li>
<li><p>tcx = btr_hdl2tcx(toh); ///** find the tree context of the handle */</p>
</li>
<li><p>rc = btr_tx_begin(tcx); // begin transaction？</p>
</li>
<li><p>rc = btr_upsert(tcx, opc, intent, key, val);</p>
<ul>
<li>rc = btr_insert(tcx, key, val); // bypass策略，直接取前一次probe的结果，create a new record, insert it into tree leaf node.<ul>
<li>btr_hkey_gen(tcx, key, &amp;rec-&gt;rec_hkey[0]); //生成hkey</li>
<li>rc = btr_node_insert_rec(tcx, trace, rec);<ul>
<li>btr_node_insert_rec_only(tcx, trace, rec);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>btr_tx_end(tcx, rc);</p>
<ul>
<li>rc = umem_tx_commit(btr_umm(tcx));</li>
</ul>
</li>
</ul>
</li>
<li><p>vos_ilog_ts_ignore(vos_obj2umm(obj), &amp;krec-&gt;kr_ilog);</p>
</li>
<li><p>vos_ilog_ts_mark(ts_set, &amp;krec-&gt;kr_ilog);</p>
</li>
</ul>
</li>
<li><p>rc = vos_ilog_update(ioc-&gt;ic_cont, &amp;krec-&gt;kr_ilog, &amp;ioc-&gt;ic_epr,</p>
<p>​                 ioc-&gt;ic_bound, &amp;obj-&gt;obj_ilog_info,</p>
<p>​                 &amp;ioc-&gt;ic_dkey_info, update_cond, ioc-&gt;ic_ts_set); // update dkey log ？</p>
</li>
<li><p>for循环：rc = akey_update(ioc, pm_ver, ak_toh, minor_epc);</p>
<ul>
<li><p>​    rc = key_tree_prepare(obj, ak_toh, VOS_BTR_AKEY,</p>
<p>​                  &amp;iod-&gt;iod_name, flags, DAOS_INTENT_UPDATE,</p>
<p>​                  &amp;krec, &amp;toh, ioc-&gt;ic_ts_set);</p>
</li>
<li><p>….</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>vos_ts_set_check_conflict(ioc-&gt;ic_ts_set, ioc-&gt;ic_epr.epr_hi) // Now that we are past the existence checks, ensure there isn’t a read conflict</p>
</li>
<li><p>err = vos_tx_end(ioc-&gt;ic_cont, dth, &amp;ioc-&gt;ic_rsrvd_scm,&amp;ioc-&gt;ic_blk_exts, tx_started, err); // dtx operations，on scm</p>
</li>
<li><p>vos_ts_set_upgrade(ioc-&gt;ic_ts_set);</p>
</li>
<li><p>vos_space_unhold(vos_cont2pool(ioc-&gt;ic_cont), &amp;ioc-&gt;ic_space_held[0]);</p>
</li>
<li><p>vos_ioc_destroy(ioc, err != 0); // memory free</p>
<ul>
<li>bio_iod_free(ioc-&gt;ic_biod);</li>
<li>vos_obj_release(vos_obj_cache_current(), ioc-&gt;ic_obj, evict);</li>
<li>vos_ioc_reserve_fini(ioc);</li>
<li>vos_ilog_fetch_finish(&amp;ioc-&gt;ic_dkey_info);</li>
<li> vos_ilog_fetch_finish(&amp;ioc-&gt;ic_akey_info);</li>
<li> vos_cont_decref(ioc-&gt;ic_cont);</li>
<li>vos_ts_set_free(ioc-&gt;ic_ts_set);</li>
<li>D_FREE(ioc);</li>
</ul>
</li>
<li><p>vos_dth_set(NULL);</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="update流程"><a href="#update流程" class="headerlink" title="update流程"></a>update流程</h2><ul>
<li>client端：<ul>
<li>调用daos_obj_update</li>
<li>create_task</li>
<li>schedule_task</li>
<li>发RPC</li>
</ul>
</li>
<li>Server端：<ul>
<li>收到rpc</li>
<li>调用rw_handler</li>
<li>leader开始执行</li>
<li>前置检查</li>
<li>预估空间</li>
<li>申请空间</li>
<li>更新Dkey</li>
<li>更新AKey</li>
<li>更新Index</li>
<li>释放空间</li>
<li>reply rpc</li>
</ul>
</li>
</ul>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy2t2613s2j30pl3upn23.jpg" alt="Canvas 1"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/Dkey-Array-Object-update/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saturn">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/Dkey-Array-Object-update/" class="post-title-link" itemprop="url">Dkey-Array Object update</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-04 17:50:56" itemprop="dateCreated datePublished" datetime="2022-01-04T17:50:56+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-17 14:22:35" itemprop="dateModified" datetime="2023-04-17T14:22:35+08:00">2023-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/knowledge/" itemprop="url" rel="index"><span itemprop="name">knowledge</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="daos-obj-generate-oid"><a href="#daos-obj-generate-oid" class="headerlink" title="daos_obj_generate_oid"></a>daos_obj_generate_oid</h3><ol>
<li>输入：<ul>
<li>daos_handle_t oh ： 存储了一个unsigned int 64的cookie</li>
<li>daos_obj_id_t  oid : daos object id, 用两个64位int 存储 lo（low）和 high （high）</li>
<li>enum DAOS_OT_KV_HASHED :  flat KV (no akey) with integer dkey </li>
<li>OC_SX ：OC策略</li>
<li>0 ：边长参数</li>
<li>0 ：变长参数</li>
</ul>
</li>
<li>实现，内部调用了<code>daos_obj_generate_oid2</code><ul>
<li>输入：<ul>
<li>daos_handle_t</li>
<li>daos_obj_id_t</li>
<li>daos_otype_t</li>
<li>daos_oclass_id_t ： object class id， 32位int</li>
<li>daos_oclass_hints_t  ：object class hint， 16位int</li>
<li>args : 其他int参数</li>
</ul>
</li>
<li>dc_cont_hdl2pool_hdl<ul>
<li>根据cookie获取pool handler</li>
</ul>
</li>
<li>rc = pl_map_query(pool-&gt;dp_pool, &amp;attr)</li>
<li>dc_pool_put(struct dc_pool *pool) // 将pool-&gt;dp_hlink放入了一个双向队列中？</li>
<li>按照选定的OC策略做相应的操作</li>
<li>daos_obj_set_oid(oid, type, ord, nr_grp, args); // 就生成好了？</li>
</ul>
</li>
</ol>
<h3 id="daos-kv-open"><a href="#daos-kv-open" class="headerlink" title="daos_kv_open"></a>daos_kv_open</h3><ol>
<li>输入：<ul>
<li>daos_handle_t</li>
<li>daos_obj_id_t</li>
<li>mode : int 类型</li>
<li>daos_handle_t</li>
<li>daos_event_t : event and event queue, maybe used for debug</li>
</ul>
</li>
<li>调用<code>rc = dc_task_create(dc_kv_open, NULL, ev, &amp;task)</code><ul>
<li>将参数包装成dc_kv_open结构体</li>
<li>生成一个kvOpen的task并调度</li>
</ul>
</li>
</ol>
<h3 id="dts-buf-render-buf-BUFLEN"><a href="#dts-buf-render-buf-BUFLEN" class="headerlink" title="dts_buf_render(buf, BUFLEN)"></a>dts_buf_render(buf, BUFLEN)</h3><ol>
<li>输入buf和len</li>
<li>利用随机生成的字符填满buf</li>
</ol>
<h3 id="daos-kev-put"><a href="#daos-kev-put" class="headerlink" title="daos_kev_put"></a>daos_kev_put</h3><ol>
<li>输入：<ul>
<li>daos_handle_t oh</li>
<li>daos_handle_t th</li>
<li>uint64_t flag</li>
<li>char * key</li>
<li>daos_size_t buf_size</li>
<li>void * buf</li>
<li>daos_event_t * ev</li>
</ul>
</li>
<li>调用rc = dc_task_create(dc_kv_put, NULL, ev, &amp;task);</li>
<li>将参数包装到task的args中</li>
<li>调用dc_task_schedule(task, true);<ol>
<li>task_is_valid(task)</li>
<li>ev = task_ptr2args(task)-&gt;ta_ev;</li>
<li>rc = daos_event_launch(ev);<ul>
<li>输入：daos_event *ev</li>
</ul>
</li>
<li>rc = tse_task_schedule(task, instant);</li>
</ol>
</li>
</ol>
<h2 id="kv-update"><a href="#kv-update" class="headerlink" title="kv_update"></a>kv_update</h2><ol>
<li><p>daos_io_0线程接收到io请求，crt_handle_rpc(void *arg)处理rpc</p>
</li>
<li><p>ds_obj_rw_handler(crt_rpc_t *rpc)处理rpc</p>
<ul>
<li><p>obj_ioc_begin(orw-&gt;orw_oid.id_pub, orw-&gt;orw_map_ver,</p>
<p>​               orw-&gt;orw_pool_uuid, orw-&gt;orw_co_hdl,</p>
<p>​               orw-&gt;orw_co_uuid, opc_get(rpc-&gt;cr_opc),</p>
<p>​               orw-&gt;orw_flags, &amp;ioc); // various check before access VOS</p>
</li>
</ul>
</li>
<li><p>​    rc = process_epoch(&amp;orw-&gt;orw_epoch, &amp;orw-&gt;orw_epoch_first,</p>
<p>​               &amp;orw-&gt;orw_flags); // 处理epoch相关</p>
</li>
</ol>
<h2 id="Object-Update"><a href="#Object-Update" class="headerlink" title="Object_Update"></a>Object_Update</h2><ol>
<li><p>callstack</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">libvos_srv.so!dkey_update(<span class="keyword">daos_key_t</span> * dkey, <span class="keyword">uint32_t</span> pm_ver, struct vos_io_context * ioc) (/home/kuhan/daos/src/vos/vos_io.c:<span class="number">1803</span>)</span><br><span class="line">libvos_srv.so!vos_update_end(<span class="keyword">daos_handle_t</span> ioh, <span class="keyword">uint32_t</span> pm_ver, <span class="keyword">daos_key_t</span> * dkey, <span class="keyword">int</span> err, <span class="keyword">daos_size_t</span> * size, struct dtx_handle * dth) (/home/kuhan/daos/src/vos/vos_io.c:<span class="number">2278</span>)</span><br><span class="line">libobj.so!obj_rw_complete(struct dtx_handle * dth, <span class="keyword">int</span> status, <span class="keyword">daos_handle_t</span> ioh, struct obj_io_context * ioc, <span class="keyword">crt_rpc_t</span> * rpc) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">128</span>)</span><br><span class="line">libobj.so!obj_local_rw_internal(struct dtx_handle * dth, <span class="keyword">uint64_t</span> * split_offs, struct dcs_iod_csums * split_csums, <span class="keyword">daos_iod_t</span> * split_iods, struct obj_io_context * ioc, <span class="keyword">crt_rpc_t</span> * rpc) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">1677</span>)</span><br><span class="line">libobj.so!obj_local_rw(<span class="keyword">crt_rpc_t</span> * rpc, struct obj_io_context * ioc, <span class="keyword">daos_iod_t</span> * split_iods, struct dcs_iod_csums * split_csums, <span class="keyword">uint64_t</span> * split_offs, struct dtx_handle * dth, <span class="built_in">_Bool</span> pin) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">1697</span>)</span><br><span class="line">libobj.so!obj_tgt_update(<span class="keyword">dtx_sub_comp_cb_t</span> comp_cb, <span class="keyword">void</span> * arg, struct dtx_leader_handle * dlh) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">2425</span>)</span><br><span class="line">libobj.so!obj_tgt_update(struct dtx_leader_handle * dlh, <span class="keyword">void</span> * arg, <span class="keyword">int</span> idx, <span class="keyword">dtx_sub_comp_cb_t</span> comp_cb) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">2356</span>)</span><br><span class="line">libobj.so!ds_obj_rw_handler(<span class="keyword">crt_rpc_t</span> * rpc) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">2664</span>)</span><br><span class="line">libcart.so<span class="number">.4</span>!crt_handle_rpc(<span class="keyword">void</span> * arg) (/home/kuhan/daos/src/cart/crt_rpc.c:<span class="number">1638</span>)</span><br><span class="line">libabt.so<span class="number">.1</span>!ABTD_ythread_func_wrapper (未知源:<span class="number">0</span>)</span><br><span class="line">libabt.so<span class="number">.1</span>!make_fcontext (未知源:<span class="number">0</span>)</span><br><span class="line">[Unknown/Just-In-Time compiled code] (未知源:<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="obj-local-rw-internal"><a href="#obj-local-rw-internal" class="headerlink" title="obj_local_rw_internal"></a>obj_local_rw_internal</h3><ol>
<li><p>​        rc = vos_update_begin(ioc-&gt;ioc_vos_coh, orw-&gt;orw_oid,</p>
<p>​                  orw-&gt;orw_epoch, cond_flags, dkey,</p>
<p>​                  orw-&gt;orw_nr, iods, iod_csums,</p>
<p>​                  ioc-&gt;ioc_coc-&gt;sc_props.dcp_dedup_size,</p>
<p>​                  &amp;ioh, dth);</p>
<ul>
<li><p>rc = vos_check_akeys(iod_nr, iods);</p>
</li>
<li><p>vos_ioc_create</p>
</li>
<li><p> rc = vos_space_hold(vos_cont2pool(ioc-&gt;ic_cont), flags, dkey, iod_nr,</p>
</li>
</ul>
<p>  ​                iods, iods_csums, &amp;ioc-&gt;ic_space_held[0]);</p>
<ul>
<li><p>rc = dkey_update_begin(ioc);</p>
<ul>
<li><p>循环rc = akey_update_begin(ioc);</p>
<ul>
<li><p>获取dcs_csum_info</p>
</li>
<li><p>获取daos_iod_t,1k</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iod</span><br><span class="line"><span class="number">0x7f9a07a4dee0</span></span><br><span class="line">iod_name</span><br><span class="line">iod_type:DAOS_IOD_ARRAY</span><br><span class="line">iod_size:<span class="number">1</span></span><br><span class="line">iod_flags:<span class="number">0</span></span><br><span class="line">iod_nr:<span class="number">1</span></span><br><span class="line">iod_recxs:<span class="number">0x7f9a07e9fbf0</span></span><br><span class="line">rx_idx:<span class="number">0</span></span><br><span class="line">rx_nr:<span class="number">1024</span></span><br></pre></td></tr></table></figure></li>
<li><p>for (i = 0; i &lt; iod-&gt;iod_nr; i++) //循环</p>
<ul>
<li><p>size = (iod-&gt;iod_type == DAOS_IOD_SINGLE) ? iod-&gt;iod_size :</p>
<p>​                iod-&gt;iod_recxs[i].rx_nr * iod-&gt;iod_size; //获取size，1k–1024</p>
</li>
<li><p>media = vos_media_select(vos_cont2pool(ioc-&gt;ic_cont),</p>
<p>​                     iod-&gt;iod_type, size); //决定往哪个media上写，0 –&gt; scm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A simple media selection policy embedded in VOS, which select media by</span></span><br><span class="line"><span class="comment"> * akey type and record size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint16_t</span></span></span><br><span class="line"><span class="function"><span class="title">vos_media_select</span><span class="params">(struct vos_pool *pool, <span class="keyword">daos_iod_type_t</span> type, <span class="keyword">daos_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;vp_vea_info == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> DAOS_MEDIA_SCM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (size &gt;= VOS_BLK_SZ) ? DAOS_MEDIA_NVME : DAOS_MEDIA_SCM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首先做特判</span></span><br><span class="line"><span class="comment">// 如果大于等于4k，写到NVME上，否则写到SCM</span></span><br></pre></td></tr></table></figure></li>
<li><p>iod-&gt;iod_type<br>为 DAOS_IOD_ARRAY类型：</p>
<ul>
<li><p>rc = vos_reserve_recx(ioc, media, size, recx_csum, csum_len);</p>
<ul>
<li><p>为    struct bio_iov  biov 分配内存</p>
</li>
<li><p>rc = reserve_space(ioc, media, size, &amp;off);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">oc</span><br><span class="line"><span class="number">0x7f9a0724ef00</span></span><br><span class="line">ic_ent_array_alloc</span><br><span class="line">ea_data</span><br><span class="line">ea_ents:<span class="number">0x0</span></span><br><span class="line">ea_ent_nr:<span class="number">0</span></span><br><span class="line">ea_size:<span class="number">0</span></span><br><span class="line">ea_max:<span class="number">0</span></span><br><span class="line">ea_inob:<span class="number">0</span></span><br><span class="line">ea_first_delete:<span class="number">0</span></span><br><span class="line">ea_delete_nr:<span class="number">0</span></span><br><span class="line">ea_embedded_ents</span><br><span class="line">ea_embedded</span><br><span class="line">ic_ent_array:<span class="number">0x0</span></span><br><span class="line">ic_bound:<span class="number">509171074455830528</span></span><br><span class="line">ic_epr</span><br><span class="line">ic_oid</span><br><span class="line">ic_cont:<span class="number">0x7f9a07e9eb60</span></span><br><span class="line">ic_iods:<span class="number">0x7f9a07a4dee0</span></span><br><span class="line">iod_csums:<span class="number">0x0</span></span><br><span class="line">ic_obj:<span class="number">0x0</span></span><br><span class="line">ic_biod:<span class="number">0x7f99c89c63b0</span></span><br><span class="line">ic_ts_set:<span class="number">0x7f99c89c6f90</span></span><br><span class="line">ic_biov_csums:<span class="number">0x7f99c87c76e0</span></span><br><span class="line">ic_biov_csums_at:<span class="number">0</span></span><br><span class="line">ic_biov_csums_nr:<span class="number">1</span></span><br><span class="line">ic_dkey_info</span><br><span class="line">ic_akey_info</span><br><span class="line">ic_sgl_at:<span class="number">0</span></span><br><span class="line">ic_iov_at:<span class="number">0</span></span><br><span class="line">ic_rsrvd_scm:<span class="number">0x7f9a07e86980</span></span><br><span class="line">ic_umoffs:<span class="number">0x7f9a07e9e6a0</span></span><br><span class="line">ic_umoffs_cnt:<span class="number">0</span></span><br><span class="line">ic_umoffs_at:<span class="number">0</span></span><br><span class="line">  ic_blk_exts</span><br><span class="line">next:<span class="number">0x7f9a0724fb38</span></span><br><span class="line">prev:<span class="number">0x7f9a0724fb38</span></span><br><span class="line">ic_space_held</span><br><span class="line">ic_iod_nr:<span class="number">1</span></span><br><span class="line">ic_dedup_th:<span class="number">4096</span></span><br><span class="line">ic_dedup_entries</span><br><span class="line">ic_dedup_bsgls:<span class="number">0x0</span></span><br><span class="line">ic_dedup_bufs:<span class="number">0x0</span></span><br><span class="line">ic_io_size:<span class="number">0</span></span><br><span class="line">ic_update:<span class="number">1</span></span><br><span class="line">ic_size_fetch:<span class="number">0</span></span><br><span class="line">ic_save_recx:<span class="number">0</span></span><br><span class="line">ic_dedup:<span class="number">0</span></span><br><span class="line">ic_dedup_verify:<span class="number">0</span></span><br><span class="line">ic_read_ts_only:<span class="number">0</span></span><br><span class="line">ic_check_existence:<span class="number">0</span></span><br><span class="line">ic_remove:<span class="number">0</span></span><br><span class="line">ic_skip_fetch:<span class="number">0</span></span><br><span class="line">ic_ec:<span class="number">0</span></span><br><span class="line">ic_shadows:<span class="number">0x0</span></span><br><span class="line">re_nr</span><br><span class="line">re_total</span><br><span class="line">re_snapshot</span><br><span class="line">re_ep_valid</span><br><span class="line">re_items</span><br><span class="line">ic_recx_lists:<span class="number">0x0</span></span><br><span class="line">re_nr</span><br><span class="line">re_total</span><br><span class="line">re_snapshot</span><br><span class="line">re_ep_valid</span><br><span class="line">re_items</span><br></pre></td></tr></table></figure>

<ul>
<li>在SCM上申请内存</li>
</ul>
</li>
<li><p>bio_addr_set(&amp;biov.bi_addr, media, off);//设置偏移量</p>
</li>
<li><p>bio_iov_set_len(&amp;biov, size); //设置长度</p>
</li>
<li><p>rc = iod_reserve(ioc, &amp;biov);</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>*ioh = vos_ioc2ioh(ioc); //获取cookie？</p>
</li>
</ul>
</li>
<li><p>biod = vos_ioh2desc(ioh); //获取io descriptor？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7f99c89c63b0</span></span><br><span class="line">bd_ctxt:<span class="number">0x7f99c89b0650</span></span><br><span class="line">bic_link</span><br><span class="line">bic_umem:<span class="number">0x7f99c860ab58</span></span><br><span class="line">bic_pmempool_uuid:<span class="number">12137328209446634291</span></span><br><span class="line">bic_blob:<span class="number">0x7f99c89b1530</span></span><br><span class="line">bic_xs_ctxt:<span class="number">0x7f9a04427370</span></span><br><span class="line">bic_inflight_dmas:<span class="number">0</span></span><br><span class="line">bic_io_unit:<span class="number">4096</span></span><br><span class="line">bic_pool_id</span><br><span class="line">bic_opening:<span class="number">0</span></span><br><span class="line">bic_closing:<span class="number">0</span></span><br><span class="line">bd_rsrvd</span><br><span class="line">brd_regions:<span class="number">0x0</span></span><br><span class="line">brd_rg_max:<span class="number">0</span></span><br><span class="line">brd_rg_cnt:<span class="number">0</span></span><br><span class="line">brd_dma_chks:<span class="number">0x0</span></span><br><span class="line">brd_chk_max:<span class="number">0</span></span><br><span class="line">brd_chk_cnt:<span class="number">0</span></span><br><span class="line">bd_dma_done:<span class="number">0x10</span></span><br><span class="line">bd_inflights:<span class="number">0</span></span><br><span class="line">bd_result:<span class="number">0</span></span><br><span class="line">bd_chk_type:<span class="number">0</span></span><br><span class="line">bd_type:<span class="number">0</span></span><br><span class="line">bd_buffer_prep:<span class="number">0</span></span><br><span class="line">bd_dma_issued:<span class="number">0</span></span><br><span class="line">bd_retry:<span class="number">0</span></span><br><span class="line">bd_rdma:<span class="number">0</span></span><br><span class="line">bd_bulk_hdls:<span class="number">0x0</span></span><br><span class="line">bd_bulk_max:<span class="number">0</span></span><br><span class="line">bd_bulk_cnt:<span class="number">0</span></span><br><span class="line">bd_sgl_cnt:<span class="number">1</span></span><br><span class="line">bd_sgls</span><br></pre></td></tr></table></figure></li>
<li><p>rc = bio_iod_prep(biod, BIO_CHK_TYPE_IO, rma ? rpc-&gt;cr_ctx : NULL,CRT_BULK_RW);</p>
<ul>
<li><p>rc = iterate_biov(biod, arg ? bulk_map_one : dma_map_one, arg);</p>
<ul>
<li><p>for循环：rc = cb_fn(biod, biov, data);  // 函数指针调用，此处写SCM</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">biod</span><br><span class="line"><span class="number">0x7f99c89c63b0</span></span><br><span class="line">bd_ctxt:<span class="number">0x7f99c89b0650</span></span><br><span class="line">bic_link</span><br><span class="line">bic_umem:<span class="number">0x7f99c860ab58</span></span><br><span class="line">bic_pmempool_uuid:<span class="number">12137328209446634291</span></span><br><span class="line">bic_blob:<span class="number">0x7f99c89b1530</span></span><br><span class="line">bic_xs_ctxt:<span class="number">0x7f9a04427370</span></span><br><span class="line">bic_inflight_dmas:<span class="number">0</span></span><br><span class="line">bic_io_unit:<span class="number">4096</span></span><br><span class="line">bic_pool_id</span><br><span class="line">bic_opening:<span class="number">0</span></span><br><span class="line">bic_closing:<span class="number">0</span></span><br><span class="line">bd_rsrvd</span><br><span class="line">bd_dma_done:<span class="number">0x10</span></span><br><span class="line">bd_inflights:<span class="number">0</span></span><br><span class="line">bd_result:<span class="number">0</span></span><br><span class="line">bd_chk_type:<span class="number">0</span></span><br><span class="line">bd_type:<span class="number">0</span></span><br><span class="line">bd_buffer_prep:<span class="number">0</span></span><br><span class="line">bd_dma_issued:<span class="number">0</span></span><br><span class="line">bd_retry:<span class="number">0</span></span><br><span class="line">bd_rdma:<span class="number">0</span></span><br><span class="line">bd_bulk_hdls:<span class="number">0x0</span></span><br><span class="line">bd_bulk_max:<span class="number">0</span></span><br><span class="line">bd_bulk_cnt:<span class="number">0</span></span><br><span class="line">bd_sgl_cnt:<span class="number">1</span></span><br><span class="line">bd_sgls</span><br><span class="line">--------------</span><br><span class="line">biov</span><br><span class="line"><span class="number">0x7f9a07e9eeb0</span></span><br><span class="line">bi_buf:<span class="number">0x0</span></span><br><span class="line">bi_data_len:<span class="number">1024</span></span><br><span class="line">bi_addr</span><br><span class="line">ba_off:<span class="number">4576720</span></span><br><span class="line">ba_type:<span class="number">0</span> <span class="string">&#x27;\000&#x27;</span></span><br><span class="line">ba_pad1:<span class="number">0</span> <span class="string">&#x27;\000&#x27;</span></span><br><span class="line">ba_flags:<span class="number">0</span></span><br><span class="line">ba_pad2:<span class="number">0</span></span><br><span class="line">bi_prefix_len:<span class="number">0</span></span><br><span class="line">bi_suffix_len:<span class="number">0</span></span><br><span class="line">--------------</span><br><span class="line">data</span><br><span class="line"><span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>函数指针调用dma_map_one(struct bio_desc *biod, struct bio_iov *biov, void *arg)</p>
<p>// /* Convert offset of @biov into memory pointer */</p>
<ul>
<li>direct_scm_access(biod, biov):<ul>
<li>bio_iov_set_raw_buf(biov,umem_off2ptr(umem, bio_iov2raw_off(biov)));</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>rc = bio_iod_copy(biod, orw-&gt;orw_sgls.ca_arrays, orw-&gt;orw_nr);</p>
<ul>
<li>将参数包装成bio_copy_args结构体</li>
<li>iterate_biov(biod, copy_one, &amp;arg);</li>
</ul>
</li>
<li><p>rc = vos_dedup_verify(ioh);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check if the dedup data is identical to the RDMA data in a temporal</span></span><br><span class="line"><span class="comment"> * allocated DRAM extent, if memcmp fails, allocate a new SCM extent and</span></span><br><span class="line"><span class="comment"> * update it&#x27;s address in VOS tree, otherwise, keep using the original</span></span><br><span class="line"><span class="comment"> * dedup data address in VOS tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
<li><p>rc = obj_verify_bio_csum(orw-&gt;orw_oid.id_pub, iods, iod_csums,biod, ioc-&gt;ioc_coc-&gt;sc_csummer,orw-&gt;orw_iod_array.oia_iod_nr); //verify CSUM</p>
</li>
<li><p>rc = obj_rw_complete(rpc, ioc, ioh, rc, dth); // the callstack is deep inside this function…</p>
<ul>
<li><p>rc = vos_update_end(ioh, ioc-&gt;ioc_map_ver,&amp;orwi-&gt;orw_dkey, status,&amp;ioc-&gt;ioc_io_size, dth);</p>
<ul>
<li><p>一些dtx commit逻辑？</p>
</li>
<li><p>err = dkey_update(ioc, pm_ver, dkey, dtx_is_valid_handle(dth) ? dth-&gt;dth_op_seq : VOS_SUB_OP_MAX); // update tree index</p>
<ul>
<li><p>rc = obj_tree_init(obj); // initialize tree for an object</p>
</li>
<li><p>rc = key_tree_prepare(obj, obj-&gt;obj_toh, VOS_BTR_DKEY, dkey,SUBTR_CREATE, DAOS_INTENT_UPDATE, &amp;krec, &amp;ak_toh,ioc-&gt;ic_ts_set);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the subtree roots embedded in the parent tree record.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * akey tree	: all akeys under the same dkey</span></span><br><span class="line"><span class="comment"> * recx tree	: all record extents under the same akey, this function will</span></span><br><span class="line"><span class="comment"> *		  load both btree and evtree root.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="comment">/* NB: In order to avoid complexities of passing parameters to the</span></span><br><span class="line"><span class="comment">	 * multi-nested tree, tree operations are not nested, instead:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * - In the case of fetch, we load the subtree root stored in the</span></span><br><span class="line"><span class="comment">	 *   parent tree leaf.</span></span><br><span class="line"><span class="comment">	 * - In the case of update/insert, we call dbtree_update() which may</span></span><br><span class="line"><span class="comment">	 *   create the root for the subtree, or just return it if it&#x27;s already</span></span><br><span class="line"><span class="comment">	 *   there.</span></span><br><span class="line"><span class="comment">	 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>rc = dbtree_fetch(toh, BTR_PROBE_EQ, intent, key,NULL, &amp;riov);</p>
</li>
<li><p>/* use BTR_PROBE_BYPASS to avoid probe again */</p>
<p>rc = dbtree_upsert(toh, BTR_PROBE_BYPASS, intent, key, &amp;riov);</p>
<ul>
<li><pre><code class="c">Update the value of the provided key, or insert it as a new key if
 * there is no match.
</code></pre>
</li>
<li><p>tcx = btr_hdl2tcx(toh); ///** find the tree context of the handle */</p>
</li>
<li><p>rc = btr_tx_begin(tcx); // begin transaction？</p>
</li>
<li><p>rc = btr_upsert(tcx, opc, intent, key, val);</p>
<ul>
<li>rc = btr_insert(tcx, key, val); // bypass策略，直接取前一次probe的结果，create a new record, insert it into tree leaf node.<ul>
<li>btr_hkey_gen(tcx, key, &amp;rec-&gt;rec_hkey[0]); //生成hkey</li>
<li>rc = btr_node_insert_rec(tcx, trace, rec);<ul>
<li>btr_node_insert_rec_only(tcx, trace, rec);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>btr_tx_end(tcx, rc);</p>
<ul>
<li>rc = umem_tx_commit(btr_umm(tcx));</li>
</ul>
</li>
</ul>
</li>
<li><p>vos_ilog_ts_ignore(vos_obj2umm(obj), &amp;krec-&gt;kr_ilog);</p>
</li>
<li><p>vos_ilog_ts_mark(ts_set, &amp;krec-&gt;kr_ilog);</p>
</li>
</ul>
</li>
<li><p>rc = vos_ilog_update(ioc-&gt;ic_cont, &amp;krec-&gt;kr_ilog, &amp;ioc-&gt;ic_epr,</p>
<p>​                 ioc-&gt;ic_bound, &amp;obj-&gt;obj_ilog_info,</p>
<p>​                 &amp;ioc-&gt;ic_dkey_info, update_cond, ioc-&gt;ic_ts_set); // update dkey log ？</p>
</li>
<li><p>for循环：rc = akey_update(ioc, pm_ver, ak_toh, minor_epc);</p>
<ul>
<li><p>​    rc = key_tree_prepare(obj, ak_toh, VOS_BTR_AKEY,</p>
<p>​                  &amp;iod-&gt;iod_name, flags, DAOS_INTENT_UPDATE,</p>
<p>​                  &amp;krec, &amp;toh, ioc-&gt;ic_ts_set);</p>
</li>
<li><p>….</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>vos_ts_set_check_conflict(ioc-&gt;ic_ts_set, ioc-&gt;ic_epr.epr_hi) // Now that we are past the existence checks, ensure there isn’t a read conflict</p>
</li>
<li><p>err = vos_tx_end(ioc-&gt;ic_cont, dth, &amp;ioc-&gt;ic_rsrvd_scm,&amp;ioc-&gt;ic_blk_exts, tx_started, err); // dtx operations，on scm</p>
</li>
<li><p>vos_ts_set_upgrade(ioc-&gt;ic_ts_set);</p>
</li>
<li><p>vos_space_unhold(vos_cont2pool(ioc-&gt;ic_cont), &amp;ioc-&gt;ic_space_held[0]);</p>
</li>
<li><p>vos_ioc_destroy(ioc, err != 0); // memory free</p>
<ul>
<li>bio_iod_free(ioc-&gt;ic_biod);</li>
<li>vos_obj_release(vos_obj_cache_current(), ioc-&gt;ic_obj, evict);</li>
<li>vos_ioc_reserve_fini(ioc);</li>
<li>vos_ilog_fetch_finish(&amp;ioc-&gt;ic_dkey_info);</li>
<li> vos_ilog_fetch_finish(&amp;ioc-&gt;ic_akey_info);</li>
<li> vos_cont_decref(ioc-&gt;ic_cont);</li>
<li>vos_ts_set_free(ioc-&gt;ic_ts_set);</li>
<li>D_FREE(ioc);</li>
</ul>
</li>
<li><p>vos_dth_set(NULL);</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="update流程"><a href="#update流程" class="headerlink" title="update流程"></a>update流程</h2><p>api调用–&gt;task generate –&gt; client rpc call –&gt; server accept –&gt; handle rpc –&gt; decide type –&gt; allocate memory –&gt; write data –&gt; update index –&gt; free memory</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/Programming-language-GO-RUST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saturn">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/Programming-language-GO-RUST/" class="post-title-link" itemprop="url">Programming language GO & RUST</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-04 10:41:13" itemprop="dateCreated datePublished" datetime="2022-01-04T10:41:13+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-17 14:24:55" itemprop="dateModified" datetime="2023-04-17T14:24:55+08:00">2023-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming-language/" itemprop="url" rel="index"><span itemprop="name">Programming language</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><ol>
<li><p>常量</p>
<ol>
<li>定义格式 const Name [Type] = Value</li>
</ol>
</li>
<li><p>变量</p>
<ol>
<li>定义格式 var Name [Type]</li>
<li>系统自动赋予初值</li>
<li>全局变量希望能被外部包所使用，则需要将变量首字母大写</li>
<li>函数体内定义的变量为局部变量，否则为全局变量</li>
<li>可以省去Type，变量在被赋值时编辑器会在编译阶段做类型推断</li>
<li>当你在函数体内声明局部变量时，应使用简短声明语法 <code>:=</code></li>
<li>值类型和引用类型<ol>
<li>值类型用等号赋值的时候，实际上是在内存中做了值拷贝<ol>
<li>int float bool string 数组 struct</li>
<li>存储在栈内</li>
</ol>
</li>
<li>引用类型变量存储的是值所在的内存地址<ol>
<li>指针 slices maps channel</li>
<li>存储在堆中</li>
<li>局部变量的简短化创建形式a := 50</li>
<li>局部变量不可以声明了但却不使用，全局变量可以</li>
</ol>
</li>
<li>init函数<ol>
<li>变量可以在init函数中被初始化，init函数在每个包完成初始化后自动执行，优先级比main高</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>基本类型和运算符</p>
<ol>
<li>bool 格式化输出时，可以用%t来表示要输出的类型为bool</li>
<li>数值类型：<ol>
<li>int和uint根据操作系统的位数，决定数值的长度（4位或者8位）</li>
<li>uintptr长度被设定为足够放一个指针即可</li>
<li>整数：<ol>
<li>int8（-128 -&gt; 127）</li>
<li>int16（-32768 -&gt; 32767）</li>
<li>int32（-2,147,483,648 -&gt; 2,147,483,647）</li>
<li>int64（-9,223,372,036,854,775,808 -&gt; 9,223,372,036,854,775,807）</li>
</ol>
</li>
<li>无符号整数：<ol>
<li>uint8（0 -&gt; 255）</li>
<li>uint16（0 -&gt; 65,535）</li>
<li>uint32（0 -&gt; 4,294,967,295）</li>
<li>uint64（0 -&gt; 18,446,744,073,709,551,615）</li>
</ol>
</li>
<li>浮点数：<ol>
<li>float32（+- 1e-45 -&gt; +- 3.4 * 1e38）：小数点后7位</li>
<li>float64（+- 5 <em>1e-324 -&gt; 107</em> 1e308）：小数点后15位</li>
</ol>
</li>
<li>复数：<ol>
<li>complex64(32位实数和虚数)</li>
<li>Complex128(64位实数和虚数)</li>
</ol>
</li>
<li>随机数：<ol>
<li>rand包</li>
</ol>
</li>
<li>类型别名：<ol>
<li>type 别名 类型</li>
</ol>
</li>
<li>字符类型<ol>
<li>char</li>
<li>实际存储了整型</li>
</ol>
</li>
</ol>
</li>
<li>字符串<ol>
<li>字符串是字节的定长数组</li>
<li>解释字符串，用双引号括起来</li>
<li>非解释字符串，反引号括起来</li>
<li>字符串的二元运算符比较，逐个字节对比</li>
<li>获取字符串中某个字节的地址是非法的$str[i]</li>
<li>字符串使用+拼接</li>
</ol>
</li>
<li>strings和strconv包（String 库函数的使用）</li>
<li>指针：<ol>
<li>一个指针变量可以指向任何一个值得内存地址</li>
</ol>
</li>
</ol>
</li>
<li><p>控制结构（省去了condition两侧的括号，使得代码更加整洁,执行语句中的括号在任何情况下都不能被省略）</p>
<ol>
<li>if-else</li>
<li>if-else if-else</li>
<li>测试多返回值函数的错误<ol>
<li>方法可以返回多个返回值，第二个返回值可以是错误的详细信息，如果第二个返回值不为Nil，则代表发生了错误。</li>
</ol>
</li>
<li>switch case：<ol>
<li>不需要写break</li>
<li>如果希望匹配到之后还继续执行后面的分支，用“fallthrough”关键字</li>
<li>switch 语句的第二种形式是不提供任何被判断的值（实际上默认为判断是否为 true），然后在每个 case 分支中进行测试不同的条件。当任一分支的测试结果为 true 时，该分支的代码会被执行。这看起来非常像链式的 if-else 语句，但是在测试条件非常多的情况下，提供了可读性更好的书写方式。</li>
<li>switch的第三种形式是condition中可以对两个变量进行计算赋值。随后在case分支中根据变量的值进行具体的行为</li>
</ol>
</li>
<li>循环：for结构<ol>
<li>基本形式：for 初始化语句;条件语句;修饰语句{}</li>
<li>第二种形式，类似于while循环。没有初始化语句和index更新语句</li>
<li>第三种形式，无限循环。for {}</li>
<li>for-range结构：<code>for ix, val := range coll &#123; &#125;</code></li>
</ol>
</li>
<li>Break 和 continue</li>
<li>label和goto（不推荐使用，没看）</li>
</ol>
</li>
<li><p>函数</p>
<ol>
<li><p>分类：普通的带有名字的函数、匿名函数、方法</p>
</li>
<li><p>go里面函数重载是不允许的，没有泛型，为了效率</p>
</li>
<li><p>函数的一般定义：<code>func f(name1 type1,name 2type2) 返回值类型</code>,参数可以没有参数名。</p>
</li>
<li><p>函数都是按照值传递的</p>
</li>
<li><p>带命名的返回值，只需要在函数尾部直接return</p>
</li>
<li><p>不带命名的返回值，需要用（）装起来写在return后面</p>
</li>
<li><p>空白符<code>_</code>匹配一些不需要的值，然后丢掉</p>
</li>
<li><p>通过传递指针来改变函数外部变量的值</p>
</li>
<li><p>变长参数函数</p>
<ol>
<li><p>形式：<code>func myFunc(a,b,arg ...int)&#123;&#125;</code></p>
</li>
<li><p>如果一个变长参数的类型没有被指定，则可以使用默认的空接口 <code>interface&#123;&#125;</code>，这样就可以接受任何类型的参数</p>
<p>`func typecheck(..,..,values … interface{}) {</p>
<pre><code>for _, value := range values &#123;
    switch v := value.(type) &#123;
        case int: …
        case float: …
        case string: …
        case bool: …
        default: …
    &#125;
&#125;
</code></pre>
<p>}`</p>
</li>
</ol>
</li>
<li><p>defer和追踪</p>
<ol>
<li>defer作用：类似于finally，用于一些资源的释放</li>
<li>使用defer来记录函数的参数和返回值</li>
</ol>
</li>
<li><p>将函数作为参数</p>
<ol>
<li><code>func IndexFunc(s string, f func(c int) bool) int</code></li>
</ol>
</li>
<li><p>闭包</p>
<ol>
<li>匿名函数赋值给变量：<code>fplus := func(x, y int) int &#123; return x + y &#125;</code></li>
<li>直接调用匿名函数：<code>func(x, y int) int &#123; return x + y &#125; (3, 4)</code></li>
<li>匿名函数的调用，在匿名函数后加一对（）表示对其的调用</li>
</ol>
</li>
<li><p>应用闭包：将函数作为返回值</p>
<ol>
<li><p>闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。</p>
</li>
<li><p>在闭包中使用到的变量可以是在闭包函数体内声明的，也可以是在外部函数声明的：</p>
<p>`var g int<br>go func(i int) {</p>
<pre><code>s := 0
for j := 0; j &lt; i; j++ &#123; s += j &#125;
g = s
</code></pre>
<p>}(1000) // Passes argument 1000 to the function literal.`</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数组与切片</p>
<ol>
<li><p>数组</p>
<ol>
<li>声明语句：<code>var identifier [len]type</code></li>
<li>使用for循环遍历</li>
</ol>
<p>`for i:=0; i &lt; len(arr1); i++｛</p>
<pre><code>arr1[i] = ...
</code></pre>
<p>}`</p>
<ol start="3">
<li>使用for-range遍历</li>
</ol>
<p>`for i:=0; i &lt; len(arr1); i++｛</p>
<pre><code>arr1[i] = ...
</code></pre>
<p>}`</p>
<ol start="4">
<li>Go 语言中的数组是一种 <strong>值类型</strong>（不像 C/C++ 中是指向首元素的指针），所以可以通过 <code>new()</code> 来创建： <code>var arr1 = new([5]int)</code>。arr1的类型是*[5]int，把arr1赋值给另一个时，需要做一次数组内存的拷贝。</li>
<li>讲数组作为函数参数时，会做一次数组的拷贝，如果需要修改传入数组的值，需要用引用传递的方式</li>
<li>数组可以在声明时使用{}来初始化</li>
</ol>
</li>
<li><p>切片</p>
<ol>
<li><p>定义和相关特性</p>
<ol>
<li>切片（slice）是对数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以切片是一个引用类型</li>
<li>和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个 <strong>长度可变的数组</strong>。</li>
<li>多个切片如果表示同一个数组的片段，它们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。</li>
</ol>
</li>
<li><p>优点：</p>
<ol>
<li>因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go 代码中 切片比数组更常用。</li>
</ol>
</li>
<li><p>声明：<code>var identifier []type</code>（不需要说明长度）。</p>
</li>
<li><p>初始化：</p>
<ol>
<li><code>var slice1 []type = arr1[start:end]</code>头闭尾开区间</li>
<li>类似数组的初始化：<code>var x = []int&#123;2, 3, 5, 7, 11&#125;</code>。这样就创建了一个长度为 5 的数组并且创建了一个相关切片。</li>
</ol>
</li>
<li><p>长度：存储的值的个数</p>
</li>
<li><p>容量：<code>cap()</code> 可以测量切片最长可以达到多少：它等于切片从第一个元素开始，到相关数组末尾的元素个数</p>
</li>
<li><p>对于每个切片，以下状态总是成立：</p>
<p><code>s == s[:i] + s[i:] // i是一个整数且: 0 &lt;= i &lt;= len(s) len(s) &lt;= cap(s)</code></p>
</li>
<li><p>切片的存储类似结构体：</p>
<ol>
<li>指向相关数组的指针</li>
<li>长度</li>
<li>容量</li>
</ol>
</li>
<li><p>将切片传递给函数：</p>
<p>`func sum(a []int) int {</p>
<pre><code>s := 0
for i := 0; i &lt; len(a); i++ &#123;
    s += a[i]
&#125;
return s
</code></pre>
<p>}</p>
<p>func main() {</p>
<pre><code>var arr = [5]int&#123;0, 1, 2, 3, 4&#125;
sum(arr[:])
</code></pre>
<p>}`</p>
</li>
<li><p>使用make创造一个切片：</p>
<ol>
<li><code>var slice1 []type = make([]type, len)</code>。</li>
<li>简写为：<code>slice1 := make([]type, len)</code></li>
<li>make 的使用方式是：<code>func make([]T, len, cap)</code>，其中 cap 是可选参数。</li>
<li>以下两种创建切片的方法等效：<ol>
<li><code>make([]int, 50, 100)</code></li>
<li><code>new([100]int)[0:50]</code></li>
</ol>
</li>
</ol>
</li>
<li><p>make和new的区别</p>
<ol>
<li>看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。</li>
<li>new (T) 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型为 * T 的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体（参见第 10 章）；它相当于 &amp;T{}。</li>
<li>make(T) 返回一个类型为 T 的初始值，它只适用于 3 种内建的引用类型：切片、map 和 channel</li>
<li>换言之，new 函数分配内存，make 函数初始化</li>
</ol>
</li>
<li><p>bytes包Buffer（类似于java里面的StringBuilder）</p>
<ol>
<li>申明方式：<code>var buffer bytes.Buffer</code></li>
<li>获取指针：<code>var r *bytes.Buffer = new(bytes.Buffer)</code></li>
<li>或者通过函数：<code>func NewBuffer(buf []byte) *Buffer</code></li>
</ol>
</li>
<li><p>切片的for-range</p>
<ol>
<li><p>单维切片：</p>
<p>`for ix, value := range slice1 {</p>
<pre><code>...
</code></pre>
<p>}`</p>
</li>
<li><p>多维切片：</p>
<p>`for row := range screen {</p>
<pre><code>for column := range screen[row] &#123;
    screen[row][column] = 1
&#125;
</code></pre>
<p>}`</p>
</li>
</ol>
</li>
<li><p>切片重组（扩容）</p>
<ol>
<li>扩展一位：<code>sl = sl[0:len(sl)+1]</code></li>
</ol>
</li>
<li><p>切片的复制与增加</p>
<ol>
<li><p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原切片的内容都拷贝过来。</p>
</li>
<li><p>通过<code>func append(s[]T, x ...T) []T</code>在切片中追加内容</p>
<ol>
<li>例子<code>sl3 := []int&#123;1, 2, 3&#125;    sl3 = append(sl3, 4, 5, 6)</code></li>
</ol>
</li>
<li><p>通过拷贝讲切片复制到新的切片中<code>func copy(dst, src []T) int</code>,返回拷贝的元素的个数</p>
<ol>
<li><p>例子：<code>sl_from := []int&#123;1, 2, 3&#125;  </code></p>
<p>​            <code> sl_to := make([]int, 10)   </code>  </p>
<p>​            <code>n := copy(sl_to, sl_from)</code></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Map</p>
<ol>
<li><p>声明：<code>var map1 map[keytype]valuetype</code></p>
</li>
<li><p>赋值：<code>map1[key1] = val1</code></p>
</li>
<li><p>取值：<code>v := map1[key1]</code></p>
</li>
<li><p>获取长度:<code>len(map1)</code></p>
</li>
<li><p>初始化：<code>&#123;key1:val1, key2:val2&#125;</code></p>
</li>
<li><p>make初始化：<code>map1 := make(map[keytype]valuetype)</code> 相当于``mapCreated := map[string]float32{}`</p>
</li>
<li><p>切片作为map的值：</p>
<p><code>mp1 := make(map[int][]int)  mp2 := make(map[int]*[]int)</code></p>
</li>
<li><p>检验key是否存在：</p>
<p>`if _, ok := map1[key1]; ok {</p>
<pre><code>// ...
</code></pre>
<p>}`</p>
</li>
<li><p>删除kv： <code>delete(map1, key1)</code></p>
</li>
<li><p>for-range遍历：</p>
<ol>
<li><p>kv：</p>
<p>`for key, value := range map1 {</p>
<pre><code>...
</code></pre>
<p>}`</p>
</li>
<li><p>只关心value</p>
<p>`for _, value := range map1 {</p>
<pre><code>...
</code></pre>
<p>}`</p>
</li>
<li><p>只关心key</p>
<p>`for key := range map1 {</p>
<pre><code>fmt.Printf(&quot;key is: %d\n&quot;, key)
</code></pre>
<p>}`</p>
</li>
</ol>
</li>
<li><p>切片：</p>
<ol>
<li><p>两次make，第一次分配切片，第二次分配切片中每个map元素</p>
<p>`items := make([]map[int]int, 5)<br>for i:= range items {</p>
<pre><code>items[i] = make(map[int]int, 1)
items[i][1] = 2
</code></pre>
<p>}`</p>
</li>
</ol>
</li>
<li><p>map排序</p>
<ol>
<li>拷贝出key，对key排序，然后顺序遍历key取出value（会不会效率太低了？）</li>
</ol>
</li>
<li><p>将kv对调：</p>
<ol>
<li>拷贝一个新的大小相同的map，遍历原始map，复制数据到新的map</li>
</ol>
</li>
</ol>
</li>
<li><p>包</p>
<ol>
<li>标准库</li>
<li>regexp包</li>
<li>sync包</li>
<li>紧密计算big包</li>
<li>自定义包和可见性：<ol>
<li>Import with . :import . “./pack1”，当使用. 来做为包的别名时，可以不通过包名来使用其中的项目。例如：test := ReturnStr()。在当前的命名空间导入 pack1 包，一般是为了具有更好的测试效果。</li>
<li>Import with _ :import _ “./pack1”，pack1 包只导入其副作用，也就是说，只执行它的 init 函数并初始化其中的全局变量。</li>
<li>导入外部安装包：先通过go install安装</li>
</ol>
</li>
</ol>
</li>
<li><p>结构体和方法（struct &amp; method）</p>
<ol>
<li><p>结构体：</p>
<ol>
<li><p>定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> identifier <span class="keyword">struct</span> &#123;</span><br><span class="line">    field1 type1</span><br><span class="line">    field2 type2</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用new</p>
<p><code> t := new(T)</code></p>
</li>
<li><p>使用声明：</p>
<p><code>var t T</code>:分配内存并零值化内存</p>
</li>
<li><p>使用<code>.</code>选择器来访问结构体的属性，无论变量是结构体还是结构体类型的指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span> &#123; i <span class="keyword">int</span> &#125;</span><br><span class="line"><span class="keyword">var</span> v myStruct    <span class="comment">// v是结构体类型变量</span></span><br><span class="line"><span class="keyword">var</span> p *myStruct   <span class="comment">// p是指向一个结构体类型变量的指针</span></span><br><span class="line">v.i</span><br><span class="line">p.i</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>&#123;&#125;</code>初始化一个结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ms := &amp;struct1&#123;<span class="number">10</span>, <span class="number">15.5</span>, <span class="string">&quot;Chris&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 此时ms的类型是 *struct1</span></span><br></pre></td></tr></table></figure>

<p>表达式 <code>new(Type)</code> 和 <code>&amp;Type&#123;&#125;</code> 是等价的。</p>
<p>或者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ms struct1</span><br><span class="line">ms = struct1&#123;<span class="number">10</span>, <span class="number">15.5</span>, <span class="string">&quot;Chris&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>或者制定字段key来初始化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intr := Interval&#123;<span class="number">0</span>, <span class="number">3</span>&#125;            (A)</span><br><span class="line">intr := Interval&#123;end:<span class="number">5</span>, start:<span class="number">1</span>&#125;  (B)</span><br><span class="line">intr := Interval&#123;end:<span class="number">5</span>&#125;           (C)</span><br></pre></td></tr></table></figure></li>
<li><p>结构体的内存布局：结构体和它所包含的数据在内存中是以连续快的形式存在的。</p>
</li>
<li><p>递归结构体：可以用来定义链表的节点或者二叉树的节点</p>
</li>
<li><p>make不能用于struct</p>
</li>
<li><p>结构体可以带Tag，通过反射获取</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TagType <span class="keyword">struct</span> &#123; <span class="comment">// tags</span></span><br><span class="line">    field1 <span class="keyword">bool</span>   <span class="string">&quot;An important answer&quot;</span></span><br><span class="line">    field2 <span class="keyword">string</span> <span class="string">&quot;The name of the thing&quot;</span></span><br><span class="line">    field3 <span class="keyword">int</span>    <span class="string">&quot;How much there are&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tt := TagType&#123;<span class="literal">true</span>, <span class="string">&quot;Barak Obama&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        refTag(tt, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">refTag</span><span class="params">(tt TagType, ix <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ttType := reflect.TypeOf(tt)</span><br><span class="line">    ixField := ttType.Field(ix)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, ixField.Tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>匿名字段和内嵌结构体</p>
<ol>
<li>匿名字段：通过<code>结构体名字.字段类型</code>来访问匿名字段，没个结构体针对每一种数据类型只能有一个匿名字段</li>
<li>内嵌结构体:结构体可以通过<code>结构体名字.内嵌结构体字段</code>来访问内嵌匿名结构体的字段，类似于软件工程领域的组合设计模式</li>
<li>命名冲突：外层结构体的相同命名字段会覆盖内层结构体的相同命名字段，访问外层结构体的相同命名字段<code>A.b</code>，访问内层结构体的相同命名字段<code>A.B.b</code></li>
</ol>
</li>
</ol>
</li>
<li><p>方法：</p>
<ol>
<li><p>在 Go 语言中，结构体就像是类的一种简化形式，那么面向对象程序员可能会问：类的方法在哪里呢？在 Go 中有一个概念，它和方法有着同样的名字，并且大体上意思相同：Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。一个类型加上它的方法等价于面向对象中的一个类。一个重要的区别是：在 Go 中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的。</p>
</li>
<li><p>类型 T（或 *T）上的所有方法的集合叫做类型 T（或 *T）的方法集。</p>
<p>因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法。但是如果基于接收者类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收者类型上存在，比如在同一个包里这么做是允许的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *denseMatrix)</span> <span class="title">Add</span><span class="params">(b Matrix)</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *sparseMatrix)</span> <span class="title">Add</span><span class="params">(b Matrix)</span> <span class="title">Matrix</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>定义方法的格式</p>
<p><code>func (recv receiver_type) methodName(parameter_list) (return_value_list) &#123; ... &#125;</code></p>
</li>
<li><p>方法的调用方式：</p>
<p><code>recv.methodName()</code>,recv类似于面向对象语言中的this或者self</p>
</li>
<li><p>一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TwoInts <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    two1 := <span class="built_in">new</span>(TwoInts)</span><br><span class="line">    two1.a = <span class="number">12</span></span><br><span class="line">    two1.b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;The sum is: %d\n&quot;</span>, two1.AddThem())</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Add them to the param: %d\n&quot;</span>, two1.AddToParam(<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">    two2 := TwoInts&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;The sum is: %d\n&quot;</span>, two2.AddThem())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tn *TwoInts)</span> <span class="title">AddThem</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tn.a + tn.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tn *TwoInts)</span> <span class="title">AddToParam</span><span class="params">(param <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tn.a + tn.b + param</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数和方法的区别：</p>
<ol>
<li><p>函数将变量作为参数：<strong>Function1(recv)</strong></p>
<p>方法在变量上被调用：<strong>recv.Method1()</strong></p>
</li>
<li><p><strong>方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。</strong></p>
</li>
</ol>
</li>
<li><p>指针作为接受者：</p>
<ol>
<li>传入指针或者值都是合法的，go会自动解引用</li>
<li>指针方法和值方法都可以在指针或者非指针上被调用</li>
</ol>
</li>
<li><p>获取或者设置对象的值使用getter和setter</p>
</li>
<li><p>多重继承可以通过一个类型内嵌多个匿名类型来实现，匿名类型的方法会被提升为此父类型的方法</p>
</li>
<li><p>总结：</p>
<ol>
<li>在Go中，类型就是类</li>
<li>Go拥有类似面向对象语言的嘞继承的概念以实现代码复用和多态</li>
<li>go中代码复用通过组合和委托实现，多态用接口来实现。</li>
<li>类型可以覆写内嵌匿名类型的方法</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>接口与反射</p>
<ol>
<li><p>接口</p>
<ol>
<li><p>定义：接口提供了一种方式来说明对象的行为：如果谁能搞定这件事，它就可以用在这儿。</p>
</li>
<li><p>接口定义了一组方法，但是这些方法不包含实现，接口内也不能拥有变量</p>
</li>
<li><p>接口定义语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Namer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Method1(param_list) return_type</span><br><span class="line">    Method2(param_list) return_type</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。</p>
<p>实现某个接口的类型（除了实现接口方法外）可以有其他的方法。</p>
<p>一个类型可以实现多个接口。</p>
<p>接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。</p>
</li>
<li><p>例子（go中的多态？）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">    side <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sq1 := <span class="built_in">new</span>(Square)</span><br><span class="line">    sq1.side = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> areaIntf Shaper</span><br><span class="line">    areaIntf = sq1</span><br><span class="line">    <span class="comment">// shorter,without separate declaration:</span></span><br><span class="line">    <span class="comment">// areaIntf := Shaper(sq1)</span></span><br><span class="line">    <span class="comment">// or even:</span></span><br><span class="line">    <span class="comment">// areaIntf := sq1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;The square has area: %f\n&quot;</span>, areaIntf.Area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接口嵌套接口</p>
<ol>
<li><p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b Buffer) <span class="keyword">bool</span></span><br><span class="line">    Write(b Buffer) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>类型断言：如何监测和转换接口变量的类型？</p>
<ol>
<li><p>定义：一个接口类型的变量varI中可以包含任何类型的值，必须有一种方式来检测它的动态类型，即运行时在变量中存储的值的实际类型。在执行过程中动态类型可能会有所不同，但是它总是可以分配给接口变量本身的类型。通常我们可以使用类型断言来测试某个时刻varI是否包含类型T的值：</p>
<p><code>v := varI.(T)</code></p>
<p>varI必须是一个接口类型变量。类型断言可能是无效的，虽然编译器会尽力检查转换是否有效，但是它不可能预见所有的可能性。如果转换在程序运行时失败会导致错误发生。更安全的方式是使用以下形式来进行类型断言：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := varI.(T); ok &#123;  <span class="comment">// checked type assertion</span></span><br><span class="line">    Process(v)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// varI is not of type T</span></span><br></pre></td></tr></table></figure>

<p>如果转换合法，<code>v</code> 是 <code>varI</code> 转换到类型 <code>T</code> 的值，<code>ok</code> 会是 <code>true</code>；否则 <code>v</code> 是类型 <code>T</code> 的零值，<code>ok</code> 是 <code>false</code>，也没有运行时错误发生。</p>
<p>例子：(暂时还不能明白这个的用处2021/12/2)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">    side <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> areaIntf Shaper</span><br><span class="line">    sq1 := <span class="built_in">new</span>(Square)</span><br><span class="line">    sq1.side = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    areaIntf = sq1</span><br><span class="line">    <span class="comment">// Is Square the type of areaIntf?</span></span><br><span class="line">    <span class="keyword">if</span> t, ok := areaIntf.(*Square); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;The type of areaIntf is: %T\n&quot;</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> u, ok := areaIntf.(*Circle); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;The type of areaIntf is: %T\n&quot;</span>, u)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;areaIntf does not contain a variable of type Circle&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *Circle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ci.radius * ci.radius * math.Pi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>类型判断：type-switch</p>
<ol>
<li><p>接口变量的类型也可以使用type-switch结构来判断</p>
</li>
<li><p>接口类型变量可以代表任何类型，所以需要有类型判断</p>
</li>
<li><p>例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">classifier</span><span class="params">(items ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> items &#123;</span><br><span class="line">        <span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is a bool\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is a float64\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">int64</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is a int\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is a nil\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is a string\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is unknown\n&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以这样调用此方法：classifier(13, -14.3, “BELGIUM”, complex(1, 2), nil, false) 。</p>
<p>在处理来自于外部的、类型未知的数据时，比如解析诸如 JSON 或 XML 编码的数据，类型测试和转换会非常有用。</p>
</li>
</ol>
</li>
<li><p>测试一个值是否实现了某个接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sv, ok := v.(Stringer); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;v implements String(): %s\n&quot;</span>, sv.String()) <span class="comment">// note: sv, not v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质。</p>
</li>
<li><p>使用方法集与接口（这节有点晦涩）</p>
<ol>
<li><p>总结</p>
<p>在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 P 直接可以辨识的：</p>
<ol>
<li>指针方法可以通过指针调用</li>
<li>值方法可以通过值调用</li>
<li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li>
<li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li>
</ol>
</li>
<li><p>Go 语言规范定义了接口方法集的调用规则：</p>
<ol>
<li>类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集</li>
<li>类型 T 的可调用方法集包含接受者为 T 的所有方法</li>
<li>类型 T 的可调用方法集不包含接受者为 *T 的方法</li>
</ol>
</li>
</ol>
</li>
<li><p>空接口</p>
<ol>
<li><p>概念：不包含任何方法，它对实现不做任何要求（类似于Java中的Object对象）</p>
</li>
<li><p>可以给一个空接口类型的变量<code>var val interface &#123;&#125;</code>赋值任何类型的值</p>
</li>
<li><p>复制数据切片到空接口切片是不允许的，因为内存布局不一致，需要用for-range逐个复制</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSlice []myType = FuncReturnSlice()</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(dataSlice))</span><br><span class="line"><span class="keyword">for</span> i, d := <span class="keyword">range</span> dataSlice &#123;</span><br><span class="line">    interfaceSlice[i] = d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>一个接口的值可以赋值给另一个接口变量，只要底层类型实现了必要的方法</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>反射</p>
<ol>
<li><p>概念：反射是用程序检查气所拥有的的结构，尤其是类型的一种能力；这是元编程的一种形式，反射可以在运行时检查类型和变量，例如大小方法和动态的调用这些方法。</p>
</li>
<li><p>Go中反射包Type用来表示一个Go类型，反射包Value为Go值提供了发射接口</p>
</li>
<li><p>两个函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>通过反射修改或者设置值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    <span class="comment">// setting a value:</span></span><br><span class="line">    <span class="comment">// v.SetFloat(3.1415) // Error: will panic: reflect.Value.SetFloat using unaddressable value</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br><span class="line">    v = reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;type of v:&quot;</span>, v.Type())</span><br><span class="line">    fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br><span class="line">    v = v.Elem()</span><br><span class="line">    fmt.Println(<span class="string">&quot;The Elem of v is: &quot;</span>, v)</span><br><span class="line">    fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br><span class="line">    v.SetFloat(<span class="number">3.1415</span>) <span class="comment">// this works!</span></span><br><span class="line">    fmt.Println(v.Interface())</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">settability of v: <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> of v: *<span class="keyword">float64</span></span><br><span class="line">settability of v: <span class="literal">false</span></span><br><span class="line">The Elem of v is:  &lt;<span class="keyword">float64</span> Value&gt;</span><br><span class="line">settability of v: <span class="literal">true</span></span><br><span class="line"><span class="number">3.1415</span></span><br><span class="line">&lt;<span class="keyword">float64</span> Value&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>反射结构体：</p>
<ol>
<li>``NumField()<code> </code>方法返回结构体内的字段数量</li>
<li>通过for循环用索引取得每个字段的值<code>Field(i)</code></li>
<li>用签名在结构体上的方法，例如，使用索引 n 来调用：<code>Method(n).Call(nil)</code></li>
</ol>
</li>
<li><p>接口与动态类型：</p>
<ol>
<li><p>Go 中的接口跟 Java/C# 类似：都是必须提供一个指定方法集的实现。但是更加灵活通用：任何提供了接口方法实现代码的类型都隐式地实现了该接口，而不用显式地声明。</p>
<p>和其它语言相比，Go 是唯一结合了接口值，静态类型检查（是否该类型实现了某个接口），运行时动态转换的语言，并且不需要显式地声明类型是否满足某个接口。该特性允许我们在不改变已有的代码的情况下定义和使用新接口。</p>
<p>接收一个（或多个）接口类型作为参数的函数，其实参可以是任何实现了该接口的类型。 实现了某个接口的类型可以被传给任何以此接口为参数的函数 。</p>
</li>
<li><p>接口的继承：</p>
<ol>
<li><p>当一个类型包含（内嵌）另一个类型（实现了一个或多个接口）的指针时，这个类型就可以使用（另一个类型）所有的接口方法。类型可以通过继承多个接口来提供像 <code>多重继承</code> 一样的特性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    *io.Reader</span><br><span class="line">    *io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Go中的面相对象总结：</p>
<ol>
<li>Go 没有类，而是松耦合的类型、方法对接口的实现。</li>
<li>封装：<ol>
<li>包范围内的：通过标识符首字母小写，<code>对象</code> 只在它所在的包内可见</li>
<li>可导出的：通过标识符首字母大写，<code>对象</code> 对所在包以外也可见</li>
</ol>
</li>
<li>继承：<ol>
<li>用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现</li>
</ol>
</li>
<li>多态：<ol>
<li>用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。Go 接口不是 Java 和 C# 接口的变体，而且：接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>错误处理与测试：</p>
<ol>
<li><p>Go中预定义的error类型接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义错误：</p>
<p><code>err := errors.New(“math - square root of negative number”)</code></p>
</li>
<li><p>运行时异常和Panic</p>
<ol>
<li><p>当发生像数组下标越界或类型断言失败这样的运行错误时，Go 运行时会触发运行时 panic，伴随着程序的崩溃抛出一个 runtime.Error 接口类型的值。这个错误值有个 RuntimeError() 方法用于区别普通错误。</p>
<p>panic 可以直接从代码初始化：当错误条件（我们所测试的代码）很严苛且不可恢复，程序不能继续运行时，可以使用 panic 函数产生一个中止程序的运行时错误。panic 接收一个做任意类型的参数，通常是字符串，在程序死亡时被打印出来。Go 运行时负责中止程序并给出调试信息。</p>
</li>
<li><p>Panic的调用方式：</p>
<p>在多层嵌套的函数调用中调用 panic，可以马上中止当前函数的执行，所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者。这样向上冒泡直到最顶层，并执行（每层的） defer，在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况：这个终止过程就是 panicking。</p>
</li>
</ol>
</li>
<li><p>从Panic中恢复</p>
<ol>
<li>panic 会导致栈被展开直到 defer 修饰的 recover () 被调用或者程序中止。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="The-Cargo-Book"><a href="#The-Cargo-Book" class="headerlink" title="The Cargo Book"></a>The Cargo Book</h2><ol>
<li><p>Cargo Guide</p>
<ol>
<li><p>What is cargo？</p>
<p><em>Cargo</em> is the Rust package manager. It is a tool that allows Rust <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/appendix/glossary.html#package"><em>packages</em></a> to declare their various dependencies and ensure that you’ll always get a repeatable build.</p>
</li>
<li><p>Creating a new package</p>
<ol>
<li><code>cargo new hello_world --bin</code></li>
<li><code>cargo build</code></li>
<li><code>cargo run</code></li>
<li><code>cargo build --release</code></li>
</ol>
</li>
<li><p>Working on an existing package</p>
<ol>
<li><code>git clone</code></li>
<li><code>cargo build</code>: fetch dependencies and build them</li>
</ol>
</li>
<li><p>Package layout</p>
<ol>
<li><code>Cargo.toml</code> and <code>Cargo.lock</code> are stored in the root of your package</li>
<li><code>src</code> for source code</li>
<li><code>src/lib.rs</code> for default library files</li>
<li>Other executables can be placed in <code>src/bin/</code>.</li>
<li>Benchmarks go in the <code>benches</code> directory.</li>
<li>Examples go in the <code>examples</code> directory.</li>
<li>Integration tests go in the <code>tests</code> directory.</li>
</ol>
</li>
<li><p>toml and lock</p>
<ol>
<li><code>Cargo.toml</code> is about describing your dependencies in a broad sense, and is written by you.</li>
<li><code>Cargo.lock</code> contains exact information about your dependencies. It is maintained by Cargo and should not be manually edited.</li>
<li><code>cargo update</code> will update dependencites to newest version</li>
</ol>
</li>
<li><p>Tests</p>
<ol>
<li>Command <code>cargo test</code></li>
<li>run unit tests in /src/tests dir</li>
<li>run integration-style  tests in /tests dir</li>
</ol>
</li>
</ol>
</li>
<li><p>Cargo Reference</p>
<ol>
<li>Specifying Dependencies<ol>
<li>specifying dependencites from crates.io:default choice</li>
<li>Caret requirements:an update is allowed if the new version number does not modify the lefct-most non-zero digit in the major,minor,patch grouping</li>
<li>Tilde requirements:specify a minimal version with some ability to update(not specified part can be modified)</li>
<li>Wildcard requirements：allow for any version where the wildcard is positioned</li>
<li>comparison requirements: allow manually specifying a version range or an exiact version to depend on</li>
<li>multiple requirements:eperated with comma</li>
<li>specifying dependencies from other registries</li>
<li>specifying depemdencies from git repositories</li>
<li>specifying path dependencies</li>
<li>Mutiple locations</li>
<li>Platform specified dependencies</li>
</ol>
</li>
</ol>
</li>
<li><p>Cargo commands</p>
<ol>
<li>General Commands<ol>
<li>cargo</li>
<li>cargo help</li>
<li>cargo version</li>
</ol>
</li>
<li>Build Commands<ol>
<li><code>cargo bench</code>:execute benchmarks of a package</li>
<li><code>cargo build</code>：Compile the current package</li>
<li><code>cargo check</code>: check a local package and all of its dependencies for errors</li>
<li><code>cargo clean</code>:remove artifacts feom the target directory that Cargo has generated in the past</li>
<li><code>cargo doc</code>:build the documentation for the local pakage and all dependencies.the output is placed in target/doc</li>
<li><code>cargo fetch</code>:fetch dependencies of a pakage from the network</li>
<li><code>cargo fix</code>:automatically fix lint warnings reported by rustc</li>
<li><code>cargo run</code>:run binary or exaple if local package</li>
<li><code>cargo rustc</code>:copile the current package</li>
<li><code>cargo rustdoc</code>:build a pakage’s documentation</li>
<li><code>cargo test</code>: execute unit and integration test of package</li>
</ol>
</li>
<li>Manifest Commands<ol>
<li><code>cargo generate-lockfile</code>：create cargo.lock file for the curren package or workspace.if already exists, rebuild the lastest avaliable version of every package</li>
<li><code>cargo locate-project</code>: print a JSON object to stdout with the full path to the Cargo.toml manifest</li>
<li><code>cargo metadata</code>:output JSON to stdout containning info about the memebers and resolved deoendencies of the current package,–format-version is recommended</li>
<li><code>cargo pkgid</code>: print out the fully qualified package ID specifier  for a package or dependency in the curren workspace</li>
<li><code>cargo tree</code>:display a tree of dependencies to the terminal</li>
<li><code>cargo update</code>:update dependencies as recorded in the local lock file</li>
<li><code>cargo vendor</code>:vendor all crates.io and git dependencies for a project into the specified directory at <code>&lt;path&gt;</code>. After this command completes the vendor directory specified by <code>&lt;path&gt;</code> will contain all remote sources from dependencies specified.</li>
<li><code>cargo verify-project</code>:parse the local manifest and check it’s validity</li>
</ol>
</li>
<li>Package commands<ol>
<li><code>cargo init</code>：create a new cargo manifest in the current directory.</li>
<li><code>cargo install</code>:This command manages Cargo’s local set of installed binary crates. Only packages which have executable <code>[[bin]]</code> or <code>[[example]]</code> targets can be installed, and all executables are installed into the installation root’s <code>bin</code> folder.</li>
<li><code>cargo new</code>:create a new cargo package in the given directory.</li>
<li><code>cargo search</code>:this performs a textual search for crates on cargo repository.The matching crates will be displayed along with their descriptioin in TOML format suitable for copying into a Cargo.html manifest.</li>
<li><code>cargo uninstall</code>:by default all binaries are removed for a crate but –bin and –example flags can be used to only remove particular binaries.</li>
</ol>
</li>
<li>Publishing Commands<ol>
<li><code>cargo login</code>:This command will save the API token to disk so that commands that require authentication, such as <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/commands/cargo-publish.html">cargo-publish(1)</a>, will be automatically authenticated. The token is saved in <code>$CARGO_HOME/credentials.toml</code>. <code>CARGO_HOME</code> defaults to <code>.cargo</code> in your home directory.</li>
<li><code>cargo owner</code>:This command will modify the owners for a crate on the registry. Owners of a crate can upload new versions and yank old versions. Non-team owners can also modify the set of owners, so take care!</li>
<li><code>cargo package</code>:This command will create a distributable, compressed <code>.crate</code> file with the source code of the package in the current directory. The resulting file will be stored in the <code>target/package</code> directory. </li>
<li><code>cargo publish</code>:This command will create a distributable, compressed <code>.crate</code> file with the source code of the package in the current directory and upload it to a registry. </li>
<li><code>cargo yank</code>:The yank command removes a previously published crate’s version from the server’s index. This command does not delete any data, and the crate will still be available for download via the registry’s download link.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="The-Rust-Programming-Language"><a href="#The-Rust-Programming-Language" class="headerlink" title="The Rust Programming Language"></a>The Rust Programming Language</h2><ol>
<li><p>Programming a Guessing Game</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> secret_number = rand::thread_rng().gen_range(<span class="number">1</span>..<span class="number">101</span>);</span><br><span class="line"><span class="comment">//      println!(&quot;The secret number is: &#123;&#125;&quot;, secret_number);</span></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> guess = <span class="built_in">String</span>::new();</span><br><span class="line">                io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line">                <span class="keyword">let</span> guess: <span class="built_in">u32</span> = <span class="keyword">match</span> guess.trim().parse() &#123;</span><br><span class="line">                                                <span class="literal">Ok</span>(num) =&gt; num,</span><br><span class="line">                                                <span class="literal">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">                                        &#125;;</span><br><span class="line">                <span class="keyword">match</span> guess.cmp(&amp;secret_number) &#123;</span><br><span class="line">                 Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">                 Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">                 Ordering::Equal =&gt; &#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You guessed :&#123;&#125;&quot;</span>, guess);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Common Programming Concepts</p>
<ol>
<li><p>Variables and Mutablity</p>
<ol>
<li>by default variables are immutable</li>
<li>if want mutable, use keyword <code>mut</code> before name of viariance</li>
<li>Difference between variables and constants<ol>
<li><code>mut</code> can not be used with constants</li>
<li>declare constants using <code>const</code> instead of <code>let</code></li>
<li>constants can be declared in any scope</li>
<li>constants may be set only to a constant expression</li>
<li>constants naming convention:use all upercase with underscores between words</li>
</ol>
</li>
<li>Shadowing<ol>
<li>we can shadow a variable by using the same variable’s name and repeating the use of <code>let</code> keyword</li>
<li>shadowing allow us using the same name for different types</li>
</ol>
</li>
</ol>
</li>
<li><p>Data types</p>
<ol>
<li><p>Scalar Types</p>
<ol>
<li><p>Integer Types</p>
<table>
<thead>
<tr>
<th>Length</th>
<th>Signed</th>
<th>Unsigned</th>
</tr>
</thead>
<tbody><tr>
<td>8-bit</td>
<td><code>i8</code></td>
<td><code>u8</code></td>
</tr>
<tr>
<td>16-bit</td>
<td><code>i16</code></td>
<td><code>u16</code></td>
</tr>
<tr>
<td>32-bit</td>
<td><code>i32</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>64-bit</td>
<td><code>i64</code></td>
<td><code>u64</code></td>
</tr>
<tr>
<td>128-bit</td>
<td><code>i128</code></td>
<td><code>u128</code></td>
</tr>
<tr>
<td>arch</td>
<td><code>isize</code></td>
<td><code>usize</code></td>
</tr>
</tbody></table>
<p>Range caculation: -(2^n - 1^) to 2^n - 1^ - 1</p>
<p>e.g. 1_000 = 1000, 57u8 = u8 type of value 57</p>
<p>more examples:</p>
<table>
<thead>
<tr>
<th>Number literals</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>Decimal</td>
<td><code>98_222</code></td>
</tr>
<tr>
<td>Hex</td>
<td><code>0xff</code></td>
</tr>
<tr>
<td>Octal</td>
<td><code>0o77</code></td>
</tr>
<tr>
<td>Binary</td>
<td><code>0b1111_0000</code></td>
</tr>
<tr>
<td>Byte (<code>u8</code> only)</td>
<td><code>b&#39;A&#39;</code></td>
</tr>
</tbody></table>
</li>
<li><p>Floating-Point Types</p>
<ol>
<li>single-percision:<code>f32</code></li>
<li>double-percision:<code>f64</code></li>
</ol>
</li>
<li><p>Boolean type</p>
<ol>
<li><code>bool</code></li>
</ol>
</li>
<li><p>Character Type</p>
<ol>
<li>size:4 bytes</li>
<li>Unicode</li>
<li><code>char</code></li>
</ol>
</li>
</ol>
</li>
<li><p>Compound Types</p>
<ol>
<li><p>The Tuple Type</p>
<ol>
<li><p>group together a number of values with a variety of types into one compound type</p>
</li>
<li><p>fix length</p>
</li>
<li><p>e.g.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>visited by index</p>
</li>
</ol>
</li>
<li><p>The Array Type</p>
<ol>
<li><p>every element of an array muse have the same type</p>
</li>
<li><p>fix length</p>
</li>
<li><p>e.g</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">3</span>; <span class="number">5</span>]<span class="comment">// size 5 with initial value 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>visited  by index</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Functions</p>
<ol>
<li>Coding stype: snake case. All letters are lowercase and underscores separate words</li>
<li>start with <code>fn</code></li>
<li>Function Parameters<ol>
<li>type of each parameter must be declared</li>
<li>multiple parameters separated with commas</li>
</ol>
</li>
<li>Function bodies contain statements and expressions<ol>
<li>Expressions do not include ending semicolons, if have, expression turns to statement,which will not return a value</li>
</ol>
</li>
<li>Functions with return values<ol>
<li>Declare return vlaue types after a <code>-&gt;</code></li>
<li> the return value of the function is synonymous with the value of the final expression in the block of the body of a function. </li>
</ol>
</li>
</ol>
</li>
<li><p>Comments</p>
<ol>
<li><code>//</code></li>
</ol>
</li>
<li><p>Control Flow</p>
<ol>
<li><p>If Expressions（if-else if-else）</p>
</li>
<li><p>Loop(loop)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    loop &#123;</span><br><span class="line">        println!(&quot;again!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>break &amp; continue can use lable to apply to the labled loop </p>
</li>
<li><p>you can add the calue you want returned after the <code>break</code> expression</p>
</li>
<li><p>conditional loop with <code>while</code></p>
</li>
<li><p>For loop:<code>for element in collection</code></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Understanding Ownership</p>
<ol>
<li><p>What is ownership?</p>
<ol>
<li>Memory is managed through a system of ownership with a set of rules that the compiler checks at compile time.</li>
<li>Stack and Heap<ol>
<li>stack for known, fixed size data at compile time</li>
<li>heap is less organized, freee space must be serached</li>
<li>hense stack is more efficiency</li>
<li>when code calls a function ,value passed into function and variables get pushed onto the stack , when the function is over, those values get poped off the stack</li>
<li>heap is controlled by ownership</li>
</ol>
</li>
<li>Ownership rules<ol>
<li>Each value in Rust has variable that’s called its owner</li>
<li>There can only be one owner at a time </li>
<li>When the owner goes out of scope,the value will be dropped</li>
</ol>
</li>
<li>Variable Scope<ol>
<li>When varianle comes into scope, it is valid</li>
<li>it remains valid until it goes out of scope</li>
</ol>
</li>
<li>The String type<ol>
<li>string is immutable but String not</li>
</ol>
</li>
<li>Memory and Allocation</li>
<li>Ways Variables and Data interact:Move<ol>
<li>primitive types allocated on stack</li>
<li>Reference allocated on stack</li>
<li>Data allocated on heap</li>
<li>For ptimitive types: s1 = s2 means copy on stack</li>
<li>For non-primitive types: s1 = s2 means referece copied on stack and data on heap did not do anything</li>
</ol>
</li>
<li>Ways Varianles and Data interact:Clone<ol>
<li>if we do want to deeply copy the heap data of the String, not just the stack data, we can use a common method called <code>clone</code></li>
</ol>
</li>
<li>Stack-Only data:copy<ol>
<li>Types such as integers that have a known size at compile time are strored entirely on the stack ,so copies of the actual values are quick to make.</li>
<li>if a type implements the <code>copy</code> trait, an doler variable is still usable after assignment.</li>
</ol>
</li>
<li>Ownership and functions<ol>
<li>The semantics for passing a value to a function are similar to those for assigning a value to a variable.Passing a variable to a funtion will move or Copy.For ptimitive types, after funciton calling, variable is still valid, but for other(e.g. String) types, calling function means ownership moving ,which meams s will be invalid after function call.</li>
</ol>
</li>
<li>Return values and scope<ol>
<li>returning values can also transfer ownership</li>
<li>The ownership of a variable follows the same pattern every time: assigning a vlaue to another variable moves it.When a variable that includes data on the heap goes out of scope,the value will be cleaned by <code>drop</code> unless the data has been moved to be owned by another variable.</li>
</ol>
</li>
</ol>
</li>
<li><p>References and Borrowing</p>
<ol>
<li><p>reference allow you to refer to some value without taking ownership of it.</p>
</li>
<li><p>The <code>&amp;s1</code> syntax lets us create a reference that <em>refers</em> to the value of <code>s1</code> but does not own it. Because it does not own it, the value it points to will not be dropped when the reference stops being used.</p>
</li>
<li><p>When functions have rederences as parameters intead of the actual values, we won’t need to return the values in order to give back ownership, because we never had ownership.We call the action of creating a reference  <em>borrowing</em>.</p>
</li>
<li><p>Modifying something borrowed is not allowed, just as variables are immutable by default, so are references.</p>
</li>
<li><p>Mutable references, e.g.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mutable references have one big restiction:you can have only one mutable reference to a particular piece of data at a time.The restriction preventing multiple mutable references to the same data at the same time allows for mutation but in a very controlled fashion.Rust prevents data races  even in compile time.Samelly, combining mutable and immutable references is also no permitted.(considered it is same as RW lock mechanism).Note that a reference’s scope starts from where it is introduced and continues through the last time that references is used.</p>
</li>
<li><p>Dangling References</p>
<p>In languages with pointers, it’s easy to erroneously create a <em>dangling pointer</em>, a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</p>
</li>
<li><p>The rules of References</p>
<ol>
<li>At any given time, you can have either one mutable references or any number of immutable references.</li>
<li>Referebces must always be valid.</li>
</ol>
</li>
</ol>
</li>
<li><p>The Slice Type</p>
<ol>
<li>A String Slice is a reference to part of a String.</li>
<li>We can create slices using a range within brackets by specifying <code>[starting_index..ending_index]</code>, where <code>starting_index</code> is the first position in the slice and <code>ending_index</code> is one more than the last position in the slice.</li>
<li>if starting_index omitted, which means start from zero, if ending_index omitted, which means end to last byte, if all ommited, which means reference the total string</li>
<li>The type that signifies “string slice” is written as <code>&amp;str</code></li>
<li>The compiler will ensure the references into the String remain valid.</li>
<li>String literals are slices：<code>let s = &quot;Hello, World&quot;</code>， the type of <code>s</code> here is <code>&amp;s</code>, it is a slice poting to that specified piont of the binary, This is also why string literals are immutable, <code>&amp;str</code> is an immutable reference.</li>
</ol>
</li>
</ol>
</li>
<li><p>Using structs to structure  related data</p>
<ol>
<li><p>Defining an instantiating structs</p>
<ol>
<li>Structs are similar to tuples, but unlike with tuple, you will name each piece of data so it is clear what the values mean.Structs are more flexible than tuples:you don’t have to rely on the order of the data so specify or access the value of an instance.</li>
<li>kv pairs visited(read or write) by dot<code>.</code></li>
</ol>
</li>
<li><p>Creating instances from other instances with struct update syntax</p>
<ol>
<li><p>Using struct update syntax, we can achieve the same effect with less code, as shown in Listing 5-7. The syntax <code>..</code> specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Using Tuple Structs Without Named Fields to Create Different Types</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>Unit-Like Structs Without Any Fields</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AlwaysEqual</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subject = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Method Syntax</p>
<ol>
<li><p>Method are similar to functions, but methods are different from functions in that they’re defined within the context of a struct and their first parameter is always <code>self</code>, which represents the instance of the stuct the method is being called on.</p>
</li>
<li><p>Where is the <code>-&gt;</code> Operator?</p>
<ol>
<li>Rust has a featured called automatic referencing and dereferencing.</li>
</ol>
</li>
<li><p>Associated Functions</p>
<ol>
<li><p>All functions defined within an <code>impl</code> block are called associaterd functions because they’re associated with the type name after the <code>impl</code></p>
</li>
<li><p>Associated functions that aren’t methods are often used for constructors that will return a new instance of the struct.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> sq = Rectangle::square(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Multiple imlp Blocks</p>
<ol>
<li>It is valid to seperate methods into multiple impl blocks but not recomended.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Enums and Pattern Matching</p>
<ol>
<li><p>Defining an Enum</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> four = IpAddrKind::V4;</span><br><span class="line">    <span class="keyword">let</span> six = IpAddrKind::V6;</span><br><span class="line"></span><br><span class="line">    route(IpAddrKind::V4);</span><br><span class="line">    route(IpAddrKind::V6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">route</span></span>(ip_kind: IpAddrKind) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Enum Values</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span>&#123;</span><br><span class="line">  v4(<span class="built_in">String</span>),</span><br><span class="line">  v6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="built_in">String</span>::from(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>Any type can be values for Enums.</p>
</li>
<li><p>Enum Methods</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">        Quit,</span><br><span class="line">        Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">        Write(<span class="built_in">String</span>),</span><br><span class="line">        ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Message &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="comment">// method body would be defined here</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> m = Message::Write(<span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    m.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>The <code>Option</code>Enum and it’s advantages over Null values</p>
<ol>
<li>When we have <code>Some</code>value,we know that a value is present and the value is held within the Some</li>
<li>When we have a <code>None</code>value,in some sense, it means the same thing as null</li>
<li>In other words, you have to convert an <code>Option&lt;T&gt;</code> to a <code>T</code> before you can perform <code>T</code> operations with it.Generally, this helps catch one of the most common issues with null: assuming that something isn’t null when it actually is.</li>
<li><code>match</code> expression is a control flow construct that does just this when used with enums.</li>
</ol>
</li>
<li><p>The match control flow operator</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">      <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">      <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">let</span> six = plus_one(five);</span><br><span class="line">  <span class="keyword">let</span> none = plus_one(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Matches Are Exhaustive</p>
<ol>
<li>Matches in Rust are exhaustive, we must exhaust every last possibility in order for the code to be valid.Especially inthe case of <code>Option&lt;T&gt;</code>, when Rust prevent us from forgetting to explicitly handle None case.</li>
</ol>
</li>
<li><p>Catch-all Patterns and the _ Placeholder</p>
<ol>
<li><p>for match default arm, we can use <code>other</code> and <code>_</code>to handle this.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let dice_roll = 9;</span><br><span class="line">    match dice_roll &#123;</span><br><span class="line">        3 =&gt; add_fancy_hat(),</span><br><span class="line">        7 =&gt; remove_fancy_hat(),</span><br><span class="line">        other =&gt; move_player(other),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_fancy_hat() &#123;&#125;</span><br><span class="line">    fn remove_fancy_hat() &#123;&#125;</span><br><span class="line">    fn move_player(num_spaces: u8) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let dice_roll = 9;</span><br><span class="line">    match dice_roll &#123;</span><br><span class="line">        3 =&gt; add_fancy_hat(),</span><br><span class="line">        7 =&gt; remove_fancy_hat(),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_fancy_hat() &#123;&#125;</span><br><span class="line">    fn remove_fancy_hat() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Concise Control Flow with if let</p>
<ol>
<li><p>The <code>if let</code>syntax lets you combine if and let into a less verbose way to handle values that match one pattern while ignoring the rest.</p>
</li>
<li><p>In other words, you can think of <code>if let</code> as syntax sugar for a <code>match</code> that runs code when the value matches one pattern and then ignores all other values.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let config_max = Some(3u8);</span><br><span class="line">    match config_max &#123;</span><br><span class="line">        Some(max) =&gt; println!(&quot;The maximum is configured to be &#123;&#125;&quot;, max),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let config_max = Some(3u8);</span><br><span class="line">    if let Some(max) = config_max &#123;</span><br><span class="line">        println!(&quot;The maximum is configured to be &#123;&#125;&quot;, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> coin = Coin::Penny;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Quarter(state) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state),</span><br><span class="line">        _ =&gt; count += <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> coin = Coin::Penny;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> Coin::Quarter(state) = coin &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>Managing Growing projects with packages,Crates,and Modules</p>
<p>(haven’t read)</p>
</li>
<li><p>Common Collections</p>
<ol>
<li><p>Types:</p>
<ol>
<li>A vector allows you to store a variable number of values next to each other</li>
<li>A string is a collection of characters</li>
<li>A hash map allows you to associate a value with a particular key</li>
</ol>
</li>
<li><p>Storing Lists of Values with Vectors</p>
<ol>
<li><p>Creating a new vector</p>
<p><code>let v: Vec&lt;i32&gt; = Vec::new()</code></p>
<p>Simply</p>
<p><code>let v = vec![1,2,3]</code></p>
</li>
<li><p>Update a vector</p>
<p><code>v.push(1)</code></p>
</li>
<li><p>Drop a vector Drops its elements</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do stuff with v</span></span><br><span class="line">    &#125; <span class="comment">// &lt;- v goes out of scope and is freed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Read elements of vectors</p>
<p>with index syntax or the <code>get</code> method</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> third: &amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="literal">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Iterating over the values in a vector</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">        *i += <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Using am Emum to store multiple Types</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</span><br><span class="line">        Int(<span class="built_in">i32</span>),</span><br><span class="line">        Float(<span class="built_in">f64</span>),</span><br><span class="line">        Text(<span class="built_in">String</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">        SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">        SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">        SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Storing UTF-8 Encoded Text with Strings</p>
<ol>
<li><p>Create a new String</p>
<p><code>let data = &quot;initial contents&quot;.to_string()</code></p>
<p><code>let s = String::from(&quot;initial contents&quot;)</code></p>
</li>
<li><p>Update a String</p>
<p><code>s.push_str(&quot;bar&quot;)</code></p>
<p><code>s.push(&#39;l&#39;)</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = s1 + &amp;s2;</span><br><span class="line"><span class="comment">// + use fn add(self, s: &amp;str) -&gt; String &#123;</span></span><br></pre></td></tr></table></figure>

<p>use <code>format!</code> Macro is recomended</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">String</span>::from(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br></pre></td></tr></table></figure>

<p><code>format!</code> macro works in the same way as <code>ptintln!</code> but instead of printing the output to the screen,it returns a <code>String</code> with the contents. The code generated by the <code>format!</code> macro uses references so that this call doesn’t take ownership of any of its parameters.</p>
</li>
<li><p>Index into Strings</p>
<ol>
<li>index to a String is not valid.</li>
</ol>
</li>
<li><p>Slice Strings</p>
<p><code>s[start..end]</code></p>
</li>
<li><p>Methods for Iterating Over Strings</p>
<p><code>for c in &quot;abcde&quot;.chars()</code></p>
<p><code>for b in &quot;abcde&quot;.bytes()</code></p>
</li>
</ol>
</li>
<li><p>Storing keys with associated values in hash maps</p>
<ol>
<li><p>Creating a hash map</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.inert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.indert(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>),<span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>Another way with two vec</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> teams = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> initial_scores = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores: HashMap&lt;_, _&gt; = teams.into_iter().zip(initial_scores.into_iter()).collect();</span><br></pre></td></tr></table></figure></li>
<li><p>HashMaps and ownership</p>
<ol>
<li>For types that implement the <code>copy</code> trait, the values are copied into the hashmap.For owned values like <code>String</code>, the values will be moved and the hashmao will be the owner of those values.</li>
</ol>
</li>
<li><p>Accessing values in a hashmap</p>
<p><code>let team_name = String::from(&quot;Blue&quot;)</code></p>
<p><code>let score = scores.get(&amp;team_name)</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std:collections::Hashmap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(key, value) int &amp;scores &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Updating a hashmap</p>
<ol>
<li><p>overwitring a value</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">20</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>Only inserting a value if the key has no value</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>)).or_insert(<span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>The <code>or_insert</code> method on <code>Entry</code> is defined to return a mutable reference to the value for the corresponding <code>Entry</code> key if that key exists, and if not ,inserts the parameter as the new value for this key and returns a mutable reference to the new value.</p>
</li>
<li><p>Updating a value based on the old value</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text,split_whitespcae() &#123;</span><br><span class="line">  <span class="keyword">let</span> count = map.entry(word).or_intsert(<span class="number">0</span>);</span><br><span class="line">  *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>or_insert</code> method actually returns a mutable reference(<code>&amp;mut v</code>) to the value for this key.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Error Handling</p>
<ol>
<li><p>Unrecoverable Erros with panic!</p>
</li>
<li><p>Recoverable Errors with Result</p>
<ol>
<li><p>Resuit Enum</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">	<span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">		OK(file) =&gt; file,</span><br><span class="line">		<span class="literal">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Mathcing on different errors</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>).unwrap_or_else(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.kind() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::create(<span class="string">&quot;hello.txt&quot;</span>).unwrap_or_else(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Shortcuts for panic on error:unwrap and expect</p>
<ol>
<li><p><code>unwrap</code> is a shortcut method that is implemented just like the <code>match</code>expression.if the <code>Result</code> value is <code>Ok</code> variant,<code>unwrap</code> will return the value inside the <code>Ok</code>.If the <code>Result</code> is the <code>Err</code> variant,<code>unwrap</code> will call the <code>panic!</code>macro for us.</p>
<p><code>let f = File::open(&quot;hello.txt&quot;).unwrap()</code></p>
</li>
<li><p>We use <code>expect</code> in the same way as <code>unwrap</code>: to return the file handle or call the <code>panic!</code> macro. The error message used by <code>expect</code> in its call to <code>panic!</code> will be the parameter that we pass to <code>expect</code>, rather than the default <code>panic!</code> message that <code>unwrap</code> uses.</p>
<p><code>let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open&quot;)</code></p>
</li>
</ol>
</li>
<li><p>Propagating Errors</p>
<p>A shortcut for prapagating errors:<code>?</code> operator</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">  f.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">  <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the value of the <code>Result</code> is an <code>OK</code>,tge value inside<code>Ok</code> will get returned from this expression, and the program will continue.if the value is an <code>Err</code>, the <code>Err</code> will be returned from the whole function as if we had used return keyword so the error value gets propagated to the calling code.</p>
<p>The <code>?</code> operator can be used in functions that have type of <code>Result</code>.</p>
</li>
</ol>
</li>
<li><p>To panic! Or Not To panic!</p>
<p>So how do you decide when you should call <code>panic!</code> and when you should return <code>Result</code>? When code panics, there’s no way to recover. You could call <code>panic!</code> for any error situation, whether there’s a possible way to recover or not, but then you’re making the decision on behalf of the code calling your code that a situation is unrecoverable. When you choose to return a <code>Result</code> value, you give the calling code options rather than making the decision for it. The calling code could choose to attempt to recover in a way that’s appropriate for its situation, or it could decide that an <code>Err</code> value in this case is unrecoverable, so it can call <code>panic!</code> and turn your recoverable error into an unrecoverable one. Therefore, returning <code>Result</code> is a good default choice when you’re defining a function that might fail.</p>
</li>
</ol>
</li>
<li><p>Generic Types, Traits, and LifeTImes</p>
<ol>
<li><p>Generic Data Types</p>
<ol>
<li><p>In Function Definitions</p>
<p>Before we use a para,eter in the body of the function, we have to declare the parameter name in the signature so the compiller knows what that name means.</p>
<p><code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;...&#125;</code></p>
</li>
<li><p>In Struct Definitions</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">  X: T,</span><br><span class="line">  y: T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T, U&gt; &#123;</span><br><span class="line">  x: T,</span><br><span class="line">  y: U,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>In Enum Definitions</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="literal">Some</span>(T),</span><br><span class="line">  <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">  <span class="literal">Ok</span>(T),</span><br><span class="line">  <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>In Method Definitions</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">  x: T,</span><br><span class="line">  y: T,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">    &amp;<span class="keyword">self</span>.x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Traits:Definning Shared Behavior</p>
<ol>
<li><p>A <em>trait</em> tells the Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior.</p>
</li>
<li><p>Defining a trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Imlementing a trait  on a type</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> </span><br><span class="line">	<span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">	<span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">	<span class="keyword">pub</span> author: <span class="built_in">String</span>,	</span><br><span class="line">	<span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Default Implementations</p>
<p>traits can have default implementations</p>
</li>
<li><p>Traits as parameters</p>
</li>
<li><p>We have implemented the <code>Summary</code> trait on the <code>NewsArticle</code> and <code>Tweet</code> types.We can define a <code>notify</code> function that calls the  summarize method on its <code>item</code> parameter,which is of some type that implements the <code>Summary</code> trait.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item : &amp;<span class="keyword">impl</span> Summary) &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Trait Bound Syntax</p>
<p>Code in item6 is straightforward but it is actually a syntax sugar for a longer form called trait bound.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T : Summary&gt;(item : &amp;T) &#123;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Specifying Multiple Trait Bounds with + Syntax</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item :&amp;(<span class="keyword">impl</span> Summary + Display)) &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T : Summary + Display&gt; (item: &amp;T) &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Clearer Trait bounds with where clauses</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; <span class="built_in">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure></li>
<li><p>Returning types that implement traits</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_summarizable</span></span>() -&gt; <span class="keyword">impl</span> Summary &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>Attention, you can only use <code>impl Trait</code> if you‘re returning a sigle type.</p>
</li>
<li><p>Using Trait Bounds to Conditionally Implement Methods</p>
<p>We can also conditinally implement a trait for any type that implements another trait.Implementations of a trait on any type that satisfies the trait bounds are called <em>blanket implementations</em>.</p>
</li>
</ol>
</li>
<li><p>Validating references with lifetimes</p>
<ol>
<li><p>Preventing dangling references with lifetimes</p>
</li>
<li><p>The Borrow checker</p>
</li>
<li><p>Generic Lifetimes in functions</p>
</li>
<li><p>Lifetime Annotation Syntax</p>
</li>
<li><p>Lifetime Annotations in function signatures</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> longest&lt;’a&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,y: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> x,len() &gt; y.len() &#123;</span><br><span class="line">    x</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The function signature now tells Rust that for some lifetime <code>&#39;a</code>, the function takes two parameters, both of which are string slices that live at least as long as lifetime <code>&#39;a</code>. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime <code>&#39;a</code>. In practice, it means that the lifetime of the reference returned by the <code>longest</code> function is the same as the smaller of the lifetimes of the references passed in. These constraints are what we want Rust to enforce. Remember, when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. Rather, we’re specifying that the borrow checker should reject any values that don’t adhere to these constraints. Note that the <code>longest</code>function doesn’t need to know exactly how long <code>x</code> and <code>y</code> will live, only that some scope can be substituted for <code>&#39;a</code> that will satisfy this signature.</p>
</li>
<li><p>Thinking in terms of lifetimes</p>
</li>
<li><p>Lifetime annotations in struct dedinitions</p>
<p>We have only defined structs to hold owned types.It is possible for structs to hold references, but in that case we would need to add a lifetime annotation on every reference in the struct’s definition.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> novel = <span class="built_in">String</span>::from(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> first_sentence = novel.split(<span class="string">&#x27;.&#x27;</span>).next().expect(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> i = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This annotation means an instance of ImportantExcerpt can not outlive the reference it holds in its part field.</p>
</li>
<li><p>Lifetime Elision</p>
<p>Lifetimes on function or method parameters are called <em>input lifetimes</em>, and lifetimes on return values are called <em>output lifetimes</em>.</p>
<p>Three rules for lifetime:</p>
<ol>
<li>Each parameter that is a reference gets its own lifetime parameter</li>
<li>If there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters</li>
<li>There are multiple input lifetime parameters, but one of them is <code>&amp;selft</code> or <code>&amp;mut self</code> because this is a method, the lifetime of <code>self</code> is assigned to all output lifetime parameters.</li>
</ol>
</li>
<li><p>Lifetime Annotations in Method Definitions</p>
<p>Lifetime names for struct fields always need to be declared after the <code>impl</code> keyword and then used after the struct’s name, because those lifetimes are part of the struct’s type</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">level</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>The static lifetime</p>
<p>Static reference can live for the entire duration of the program</p>
<p><code>let s: &amp;&#39;static str = &quot;I have a static lifetime&quot;&#39;</code></p>
</li>
<li><p>Generic Type parameters, Trait Bounds, and lifetimes Together</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = longest_with_an_announcement(</span><br><span class="line">        string1.as_str(),</span><br><span class="line">        string2,</span><br><span class="line">        <span class="string">&quot;Today is someone&#x27;s birthday!&quot;</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest_with_an_announcement</span></span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">    y: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">    ann: T,</span><br><span class="line">) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>Writing Automated Tests</p>
<ol>
<li><p>How to Write Tests？</p>
<ol>
<li><p>Checking resutls with the <code>assert!</code> Macro</p>
<p>We give the <code>!assert</code> Marco an argument that avaluates to a Boolean,if the value is true, assert! does nothing an the test passes,if the value is false, the assert! Macro calls the panic! macro.</p>
</li>
<li><p>Testing equality with the <code>assert_eq!</code> And <code>assert_ne!</code> marcos</p>
</li>
<li><p>Adding custom failure messages</p>
</li>
<li><p>Checking for panics with <code>should_panic</code></p>
<p>To our test function, this attribute makes a test pass if the code inside the function panics, thet test will fial if the code inside the function doesn’t panic.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Guess</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Guess &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(value: <span class="built_in">i32</span>) -&gt; Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;&#125;.&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greater_than_100</span></span>() &#123;</span><br><span class="line">        Guess::new(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Test orgnization</p>
<p>The <code>#[cfg(test)]</code> annotation on the tests module tells Rust to compile and run the test code only when you run <code>cargo test</code>, not when you run <code>cargo build</code>. </p>
</li>
</ol>
</li>
<li><p>Function Language features:iterators and closures</p>
<ol>
<li><p>Closures:aninymous functions that can capture their environment</p>
<ol>
<li><p>To define a closure, we start with a pair of vertical pipes<code>|</code>，after the parameters,we place curly brackets that hold the body of the closure,which is optinal if the closure body is a sigle expression.</p>
</li>
<li><p>Closures don’t require  you to annotate the types of the parameters or the return value like functions do.The compiler is reliably able to infer the types if the paramaters and the return value, similar to how it’s able to infer types of most variables.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span>  <span class="title">add_one_v1</span>   </span>(x: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> add_one_v2 = |x: <span class="built_in">u32</span>| -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> add_one_v3 = |x|             &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> add_one_v4 = |x|               x + <span class="number">1</span>  ;</span><br></pre></td></tr></table></figure></li>
<li><p>Once user calling a closure, compiler refers the type of closure paramaters, and types are then locked into the closure,and we get a type error if we try to use a difference type with the same closure.</p>
</li>
<li><p>Cloures have an additional capability that functions don’t have: they can capture their environment and access variables from the scope in which they’re defined.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">equal_to_x</span></span>(z: <span class="built_in">i32</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        z == x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(equal_to_x(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Closures can capture value from their environment in three ways,which directly map to the three ways a function can take a parameter:taking ownership, borrowing mutably, and borrowing immutably.These are encoded in three <code>Fn</code> traits as follows:</p>
<ul>
<li><p><code>FnOnce</code>:consumes the variables it captures from its enclosing scope, known as the closure’s environment.To consume the captured variables, the closure must take ownership of these variables and move them into the closure when it is defined.The once part of the name represents the fact that the closure can’t take ownership of the same variables more than once, so it can be called only once.</p>
</li>
<li><p><code>FnMut</code>:can change the environment because it mutably borrows values.</p>
</li>
<li><p><code>Fn</code>:borrows values from the environment immutably</p>
</li>
</ul>
<p>When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement <code>FnOnce</code> because they can all be called at least once. Closures that don’t move the captured variables also implement <code>FnMut</code>, and closures that don’t need mutable access to the captured variables also implement <code>Fn</code>. In Listing 13-12, the <code>equal_to_x</code>closure borrows <code>x</code> immutably (so <code>equal_to_x</code> has the <code>Fn</code> trait) because the body of the closure only needs to read the value in <code>x</code>.</p>
<p>If you want to force the closure to take ownership of the values it uses in the environment, you can use the <code>move</code> keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it’s owned by the new thread.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> equal_to_x = <span class="keyword">move</span> |z| z == x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;can&#x27;t use x here: &#123;:?&#125;&quot;</span>, x);</span><br><span class="line">  <span class="comment">// move this line, the code can be compiled</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(equal_to_x(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Processing a series of items with iterators</p>
<ol>
<li><p>Iterators are lazy</p>
</li>
<li><p>The Iterator trait an next method</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// methods with default implementations elided</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The valuies we get from the calls to <code>next</code> are immutable references to the values in the vector.The <code>iter</code>  method produces an iterator over immutable references.If we want to create an iterator that takes ownership of vector and returns owned values, we can call <code>into_iter</code> instead of <code>iter</code>.Similarly， if we want to iterate over mutable references, we can call <code>iter_mut</code> instead of <code>iter</code>.</p>
</li>
<li><p>Methods that consume the iterator</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">iterator_sum</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">let</span> v1_iter = v1.iter();</span><br><span class="line">  <span class="keyword">let</span> total:<span class="built_in">i32</span> = v1.iter.sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Methods that produce other iterators</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> v2: <span class="built_in">Vec</span>&lt;_&gt; = v1.iter().map(|x| x+<span class="number">1</span>).collect();</span><br></pre></td></tr></table></figure>

<p>We use collect method to consume the iterator because iterators are lazy, we collect the results of iterating over the iterator that’s returned from the call to <code>map</code> into a vector.</p>
</li>
<li><p>Using closures that capture their environment</p>
<p><code>filter</code> iterator adaptor:The <code>filter</code> method on an iterator takes a closure that takes each item from the iterator and returns a boolean.If the closure returns true, the value will be included in the iterator produced by filter, if the closure returns false, the value won’t be included in the resulting iterator.</p>
<p><code>shoes.into_iter().filter(|s| s.size == shoe_size).collect()</code></p>
</li>
<li><p>Comparing performance:Loops and iterators</p>
<p>Closures and iterators are Rust features inspired by functional programming language ideas. They contribute to Rust’s capability to clearly express high-level ideas at low-level performance. The implementations of closures and iterators are such that runtime performance is not affected. This is part of Rust’s goal to strive to provide zero-cost abstractions.</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>More about Cargo and Crates.io (Not covered)</p>
</li>
<li><p>Smart Pointers</p>
<ol>
<li><p>In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that the reference are pointers that only borrow data; in contrast, in many cases, smart pointers own the data they point to.</p>
</li>
<li><p>Using Box<T> to point to data on the heap</T></p>
<p>Boxes allow you to store data on the heap rather than the stack, what remains on the stack is the pointer to the heap data.</p>
<ol>
<li>Enabling recursive types with boxes</li>
</ol>
</li>
<li><p>Treating smart pointers like regular references with the Deref trait</p>
<p>Implementing the <code>Deref</code> trait allows you to customize the behavior of the <em>dereference operator</em>, <code>*</code>(as opposed to the multiplication or glob operator). By implementing <code>Deref</code> in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</p>
<p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references.The <code>deref</code> method gives the compiller the ability to take value of any type that implements <code>Deref</code> and call the <code>deref</code> method to get a <code>&amp;</code> reference that it knows how to dereference.</p>
</li>
<li><p>Implicit deref coercions with functions and methods</p>
<p><em>Deref coercion</em> is a convenience that Rust performs on arguments to functions and methods. Deref coercion works only on types that implement the <code>Deref</code> trait. Deref coercion converts such a type into a reference to another type. For example, deref coercion can convert <code>&amp;String</code> to <code>&amp;str</code> because <code>String</code> implements the <code>Deref</code> trait such that it returns <code>&amp;str</code>. Deref coercion happens automatically when we pass a reference to a particular type’s value as an argument to a function or method that doesn’t match the parameter type in the function or method definition. A sequence of calls to the <code>deref</code> method converts the type we provided into the type the parameter needs.</p>
<p>Deref coercion was added to Rust so that programmers writing function and method calls don’t need to add as many explicit references and dereferences with <code>&amp;</code> and <code>*</code>. The deref coercion feature also lets us write more code that can work for either references or smart pointers.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(name: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    hello(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>with rust deref coercions, the code is equal to</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    hello(&amp;(*m)[..]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>How deref coercion interacts with mutability</p>
<p>rust does deref coercion when it finds types and trait implementions in three cases:</p>
<ul>
<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
</li>
<li><p>Running code on cleanup with the drop trait</p>
<p>The second trait important to the smart pointer pattern is <code>Drop</code>, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the <code>Drop</code>trait on any type, and the code you specify can be used to release resources like files or network connections. We’re introducing <code>Drop</code> in the context of smart pointers because the functionality of the <code>Drop</code> trait is almost always used when implementing a smart pointer. For example, when a <code>Box&lt;T&gt;</code> is dropped it will deallocate the space on the heap that the box points to.</p>
<p>Programmer do not have to free memory in code when finishing using an instance of a data type.In rust, when a value goes out of scope,the compiler will insert ‘free memory’ code automatically.</p>
<p>Most of time, programmers do not have to drop memory of one instance before the scope ending, if have to, rust provides a method <code>std::mem::drop</code> to do this.</p>
</li>
<li><p>Rc<T>, the reference counted smart pointer</T></p>
<p>To enable multiple ownership, Rust has a type called <code>Rc&lt;T&gt;</code>, which is an abbreviation for <em>reference counting</em>. The <code>Rc&lt;T&gt;</code> type keeps track of the number of references to a value to determine whether or not the value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</p>
<p>We use the <code>Rc&lt;T&gt;</code> type when we want to allocate some data on the heap for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data’s owner, and the normal ownership rules enforced at compile time would take effect.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RefCell<T> and the interior mutability pattern </T></p>
<p>……..(TODO)</p>
<p>reference:<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">https://doc.rust-lang.org/book/ch15-05-interior-mutability.html</a></p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/Linux%20core/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saturn">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/Linux%20core/" class="post-title-link" itemprop="url">Something about linux core</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-04 10:41:13" itemprop="dateCreated datePublished" datetime="2022-01-04T10:41:13+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-17 14:24:46" itemprop="dateModified" datetime="2023-04-17T14:24:46+08:00">2023-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/knowledge/" itemprop="url" rel="index"><span itemprop="name">knowledge</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ol>
<li><p>页：MMU管理的基本单位</p>
</li>
<li><p>区：</p>
<ol>
<li><p>ZONE_DMA</p>
</li>
<li><p>ZONE_DMA32</p>
</li>
<li><p>ZONE_NORMAL</p>
</li>
<li><p>ZONE_HIGHEM</p>
<p>![image-20211227135455605](/Users/chenjiawei/Library/Application Support/typora-user-images/image-20211227135455605.png)</p>
</li>
</ol>
</li>
</ol>
<h1 id="块IO"><a href="#块IO" class="headerlink" title="块IO"></a>块IO</h1><ol>
<li>块设备中最小的可寻址单元是山区们一般为512字节。块设备无法对比扇区还小的单元进行寻址和操作。因为各种软件的用途不同，所以它们都会用到自己的最小逻辑可寻址单元–块。块是文件系统的一种抽象–只能基于块来访问文件系统。虽然物理磁盘寻址是按照扇区进行的，但是内核执行的所有磁盘操作都是按照块进行的。对块大小的最终要求是必须是扇区大小的2的整数倍，并且要小于页面的大小，所以通常块大小是512字节，1KB或者4KB。；</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@kuhan-server:/home/kuhan/daos# dmg -i -l 172.20.18.168 storage scan</span><br><span class="line">Hosts         SCM Total       NVMe Total</span><br><span class="line">-----         ---------       ----------</span><br><span class="line">172.20.18.168 0 B (0 modules) 0 B (0 controllers)</span><br><span class="line">root@kuhan-server:/home/kuhan/daos# dmg -i -l 172.20.18.168 storage format</span><br><span class="line">Formatting scm storage for DAOS I/O Engine instance 0 (reformat: false)</span><br><span class="line">Instance 0: starting format of SCM (ram:/mnt/daos)</span><br><span class="line">Instance 0: finished format of SCM (ram:/mnt/daos)</span><br><span class="line">Formatting nvme storage for DAOS I/O Engine instance 0</span><br><span class="line">Instance 0: starting format of file block devices [/tmp/daos-bdev]</span><br><span class="line">Instance 0: finished format of file block devices [/tmp/daos-bdev]</span><br><span class="line">Writing nvme config file for DAOS I/O Engine instance 0</span><br><span class="line">DAOS I/O Engine instance 0 storage ready</span><br><span class="line">Format Summary:</span><br><span class="line">  Hosts         SCM Devices NVMe Devices</span><br><span class="line">  -----         ----------- ------------</span><br><span class="line">  172.20.18.168 1           1</span><br><span class="line">SCM @ /mnt/daos: 4.3 GB Total/4.3 GB Avail</span><br><span class="line">Starting I/O Engine instance 0: /home/kuhan/daos/install/bin/daos_engine</span><br><span class="line">root@kuhan-server:/home/kuhan/daos# daos_engine:0 Using legacy core allocation algorithm</span><br><span class="line">MS leader running on kuhan-server</span><br><span class="line">daos_engine:0 DAOS I/O Engine (v2.0.0) process 6930 started on rank 0 with 1 target, 0 helper XS, firstcore 0, host kuhan-server.</span><br></pre></td></tr></table></figure>



<h2 id="commands"><a href="#commands" class="headerlink" title="commands"></a>commands</h2><h3 id="Storage-Operations"><a href="#Storage-Operations" class="headerlink" title="Storage Operations"></a>Storage Operations</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmg storage query usage</span><br></pre></td></tr></table></figure>

<h3 id="NMMe-SSD-Health-Monitoring"><a href="#NMMe-SSD-Health-Monitoring" class="headerlink" title="NMMe SSD Health Monitoring"></a>NMMe SSD Health Monitoring</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">3.3  DAOS系统管理命令</span><br><span class="line">1） 存储空间占用查询</span><br><span class="line">dmg -i storage query usage</span><br><span class="line">2） 健康检查</span><br><span class="line">dmg -i storage query list-devices</span><br><span class="line">dmg -i storage query list-pools</span><br><span class="line">dmg -i storage query device-health -u 038a6076-a2e9-48ff-b4b2-1859d319c928</span><br><span class="line">dmg -i storage scan --nvme-meta</span><br><span class="line">dmg -i storage scan --nvme-health</span><br><span class="line">3） NVMe SSD Eviction and Hotplug</span><br><span class="line">dmg -i storage set nvme-faulty –uuid=</span><br><span class="line">dmg -i storage replace nvme --old-uuid= --new-uuid=</span><br><span class="line"></span><br><span class="line">4） NVMe SSD点灯</span><br><span class="line">dmg -i storage identify vmd -h --uuid=</span><br><span class="line"></span><br><span class="line">3.4  Benchmark</span><br><span class="line">1）创建pool</span><br><span class="line">dmg -i pool create --size=50GB</span><br><span class="line">dmg -i pool list</span><br><span class="line">dmg -i pool list -v</span><br><span class="line">dmg -i pool query --pool=115d5112-e4db-4364-9821-48b661cef7bc</span><br><span class="line">daos pool autotest --pool=115d5112-e4db-4364-9821-48b661cef7bc</span><br><span class="line">2）创建container</span><br><span class="line">daos cont create --pool=115d5112-e4db-4364-9821-48b661cef7bc</span><br><span class="line">Successfully created container f5d39d5d-c352-4538-8a28-54d75c76c0ac</span><br><span class="line">daos cont create --pool=115d5112-e4db-4364-9821-48b661cef7bc --path=/tmp/mycontainer --type=POSIX</span><br><span class="line">Successfully created container 529c9361-65b3-4d7a-ba1f-b306390dcdea type POSIX</span><br><span class="line">daos cont query --path /tmp/mycontainer</span><br><span class="line">3）测试</span><br><span class="line">export POOL=115d5112-e4db-4364-9821-48b661cef7bc</span><br><span class="line">export CONT=529c9361-65b3-4d7a-ba1f-b306390dcdea</span><br><span class="line">fio ./examples/dfs.fio</span><br></pre></td></tr></table></figure>

<h3 id="create-pool"><a href="#create-pool" class="headerlink" title="create pool"></a>create pool</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@kuhan-server:/home/kuhan/daos# dmg -i pool create --size=10GB --label=test</span><br><span class="line">Creating DAOS pool with automatic storage allocation: 10 GB total, 6,94 tier ratio</span><br><span class="line">daos_engine:0 3f085ef1: pool/cont hdl uuid 2366bb3f/a41283be</span><br><span class="line">3f085ef1: rank 0 became pool service leader 0</span><br><span class="line">Pool created with 6.00%,94.00% storage tier ratio</span><br><span class="line">-------------------------------------------------</span><br><span class="line">  UUID                 : 3f085ef1-eddb-47ed-b68f-c05cb1f7c7b7</span><br><span class="line">  Service Ranks        : 0</span><br><span class="line">  Storage Ranks        : 0</span><br><span class="line">  Total Size           : 10 GB</span><br><span class="line">  Storage tier 0 (SCM) : 600 MB (600 MB / rank)</span><br><span class="line">  Storage tier 1 (NVMe): 9.4 GB (9.4 GB / rank)</span><br><span class="line"></span><br><span class="line">root@kuhan-server:/home/kuhan/daos# dmg -i storage scan</span><br><span class="line">Hosts     SCM Total       NVMe Total</span><br><span class="line">-----     ---------       ----------</span><br><span class="line">localhost 0 B (0 modules) 0 B (0 controllers)</span><br><span class="line">root@kuhan-server:/home/kuhan/daos# daos cont create --pool=3f085ef1-eddb-47ed-b68f-c05cb1f7c7b7</span><br><span class="line">  Container UUID : a1c04e93-26e9-4453-9a59-72e1a33b7667</span><br><span class="line">  Container Type : unknown</span><br><span class="line"></span><br><span class="line">Successfully created container a1c04e93-26e9-4453-9a59-72e1a33b7667</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/Distributed-protocol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saturn">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/Distributed-protocol/" class="post-title-link" itemprop="url">Distributed protocol</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-04 10:39:58" itemprop="dateCreated datePublished" datetime="2022-01-04T10:39:58+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-17 14:26:02" itemprop="dateModified" datetime="2023-04-17T14:26:02+08:00">2023-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/knowledge/" itemprop="url" rel="index"><span itemprop="name">knowledge</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Distributed-protocol"><a href="#Distributed-protocol" class="headerlink" title="Distributed protocol"></a>Distributed protocol</h1><h2 id="Consensus-Algorithm"><a href="#Consensus-Algorithm" class="headerlink" title="Consensus Algorithm"></a>Consensus Algorithm</h2><p>满足三个条件：</p>
<p>non-triviality:if the value v is decided,then v must have been proposed by a proposer</p>
<p>safety &amp; safe learning:任意两个proposr，得知decided value is a andf b,必有a=b</p>
<h3 id="classic-paxos"><a href="#classic-paxos" class="headerlink" title="classic paxos"></a>classic paxos</h3><p>two phase：</p>
<ol>
<li>reading phase</li>
<li>writing phase</li>
</ol>
<p>properties for proposer</p>
<ol>
<li>epoch</li>
<li>proppser只在收到大部分acceptor的promise后开始提议</li>
<li>proposer只在收到大部分acceptor的accepts后返回最终的决议值</li>
<li>如果之前没有确定value，任何value可以被propose，如果有，则epoch最高的value被propose</li>
<li>被proposer使用的epoch大于之前所有被使用过得epoch</li>
</ol>
<p>properties for acceptor：</p>
<ol>
<li>acceptor只处理收到的的prepare或者propose中epoch&gt;= last promised epoch的消息</li>
<li>For each prepare or propose message received, the acceptor’s last promised epoch is set to the epoch received. This is after Property 6 has been satisfied.</li>
<li>For each prepare message received, the acceptor replies with promise. This is after Properties 6 &amp; 7 have been satisfied.</li>
<li>For each propose message received, the acceptor replies with accept after updating its last accepted proposal. This is after Properties 6 &amp; 7 have been satisfied.</li>
<li>Last promised epoch and last accepted proposal are persistent and only updated by Properties 7 &amp; 9</li>
</ol>
<h2 id="classic-paxos的改进"><a href="#classic-paxos的改进" class="headerlink" title="classic paxos的改进"></a>classic paxos的改进</h2><ol>
<li>对于epoch号比较小的prepare或者proposal，acceptor不会做响应，只能由proposer等待超时并重试，此处可以改进为acceptor发送no—prepare或者no-accept消息。</li>
<li>在prepare阶段，如果proposer收到的大部分ack中的value和第二阶段的proposal value相同，则可以跳过第二阶段，直接返回value？算法如何知道确定的值就是第二阶段需要propose的值呢？</li>
<li>在一个acceptor收到确认消息后，就返回decided给proposer，proposer不必等大多数acceptor返回确认就可以直接返回确认值。（这样做真的没问题吗）Mencius</li>
</ol>
<h2 id="proposal-copying"><a href="#proposal-copying" class="headerlink" title="proposal copying"></a>proposal copying</h2><p>（Unique proposer uses each epoch）一个epoch内只有一个proposal能被接受，若proposer在phase one接受到了NACK中，发现max Epoch等于prepare中发送的epoch且已有了promised的值，则做proposal copying并跳到phase 2（为了更快的收敛？）</p>
<h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><ol>
<li>三种状态<ol>
<li>leader</li>
<li>follower</li>
<li>candidate</li>
</ol>
</li>
<li>每个server存储一个current term number</li>
<li>使用RPC通信：<ol>
<li>RequestVote RPC （initiated by candidates during elections）</li>
<li>Append_entries RPCS(initiated by leaders to replicate log entries and to provide a form of heartbeat</li>
</ol>
</li>
<li>leader election<ol>
<li>时机：只要follower能从leader或者candidate收到rpc，remain 状态，如果在election  timeout时间内没有收到rpc，认为leader死亡，开始leader election</li>
<li>选举流程：follower increments current term(term += 1) 并且转换为candidate状态，vote for self并且并行的发送requestVote RPC给集群中的其他server</li>
<li>candidate保持状态直到：<ol>
<li>赢得选举</li>
<li>其他server赢得选举</li>
<li>一段时间过去了没有胜出者</li>
</ol>
</li>
<li>candidate赢得选举的条件：在 same term的条件下获取集群内大部分server的votes。一个server只能为一个candidate vote，first-come-first-serverd。一旦赢得选举则向其他的节点发送heartbeat to prevent new election</li>
<li>如何解决split votes（每个server同时开始选举并为自己投票）<ol>
<li>random election timeout（150-300ms）</li>
</ol>
</li>
<li>followers只为log entry大于自己的candidate投票</li>
<li>candidate 收到 leader的request，比较其term和自己的term，若大于自己的则变为follower，否则reject request继续保持candidate状态</li>
</ol>
</li>
<li>Term（逻辑时钟）<ol>
<li>特性：连续数字，每个server都会有一个term</li>
<li>term changes whenever servers communitacte</li>
<li>If server a‘s term smaller than b’s, a change it’s term to b’s</li>
<li>candidate of leader founds larger term, trun itself to follower</li>
<li>if server recieved stale term request , reject it</li>
</ol>
</li>
<li>Log replication<ol>
<li>流程<ol>
<li>command come</li>
<li>leader append command to it’s log </li>
<li>Sent log to other servers to replicate the entry</li>
<li>recieved most servers reply, leader apply this comand to it’s state machine</li>
<li>return result to client</li>
<li>(if followers crash or run slowlly, or network issues, leader send rpc infinitely until all followers store all log)</li>
</ol>
</li>
<li>log structure<ol>
<li>state machine command</li>
<li>term number<ol>
<li>to detect inconsistencies between logs</li>
</ol>
</li>
<li>integer index <ol>
<li>to identify its position in the log</li>
</ol>
</li>
</ol>
</li>
<li>commited log entries<ol>
<li>when ont entry has replicated it on a majority of servers</li>
<li>leader includs highest index it knows to be commietted int appedEntries RPCs so other followers learns that and then commite that entry to its state machine</li>
</ol>
</li>
<li>how to handle inconsistencies?<ol>
<li>by forcing the follower’s logs to duplicate it’s own(follower overrited)</li>
<li>leader 存储每个follower的nextIndex array，此array初始值为last one of leader index + 1，然后向follower发送AppendEntries RPC用于指针探测，如果探测失败则以1步距回退，直到找到一个agree point。（Leader Append-Only确保了leader不会删除或者覆盖他自己的log）</li>
</ol>
</li>
<li>log被复制到大多数节点上之后leader crush但是log未commit，仍有可能被覆盖掉</li>
<li>Raft 通过 up-to-date vote 来确保新leader有所有commited logs<ol>
<li>if tyhe logs have last entries with different terms, the the log with the later term is more up-to-date</li>
<li>if the logs end up with the same term ,then whicheve log is longer is more up-to-date</li>
</ol>
</li>
</ol>
</li>
<li>Timing and availability<ol>
<li>broadcastTIme(heartBeat) &lt;&lt; electionTimeOut&lt;&lt;MTBF</li>
</ol>
</li>
<li>Raft 图解<ol>
<li><a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></li>
<li><a target="_blank" rel="noopener" href="https://raft.github.io/">https://raft.github.io</a></li>
</ol>
</li>
</ol>
<h2 id="Chain-replication"><a href="#Chain-replication" class="headerlink" title="Chain replication"></a>Chain replication</h2><ol>
<li>request processing<ol>
<li>reply generation:<ol>
<li>reply is generated and sent by tail</li>
</ol>
</li>
<li>Query processing<ol>
<li>Query processed by tail</li>
</ol>
</li>
<li>Update processing<ol>
<li>update processed by head and delevered on chain</li>
</ol>
</li>
</ol>
</li>
<li>Advantages &amp; disadvantages<ol>
<li>Read:cheap beacause only tail reply the query</li>
<li>Write:more heavy beacause all nodes need to participate, but compution only need once because head compute the value and other nodes only need to do once write.</li>
</ol>
</li>
<li>Coping with server failures<ol>
<li>直接删掉？</li>
</ol>
</li>
<li>……(没看，失去兴趣)</li>
<li>参考：<a target="_blank" rel="noopener" href="https://www.dazhuanlan.com/andyblack/topics/1098082">https://www.dazhuanlan.com/andyblack/topics/1098082</a></li>
</ol>
<h2 id="FaceBook-F4-system"><a href="#FaceBook-F4-system" class="headerlink" title="FaceBook F4 system"></a>FaceBook F4 system</h2><ol>
<li><p>Design details</p>
<ol>
<li><p>Volumes:</p>
<ol>
<li>state：    <ol>
<li>Unlocked: under 100GB, allow read/write/delete</li>
<li>Locked: only read/delete is allowed</li>
</ol>
</li>
<li>类别：<ol>
<li>dataFile: BLOB + metadata(key,size or checksum)</li>
<li>index FIle:aimed to allow rebuild when rebooting</li>
<li>Journal File:tracks BLOBS that have been deleted</li>
</ol>
</li>
</ol>
</li>
<li><p>System overall</p>
<ol>
<li>路由<ol>
<li>Create to Hot storage</li>
<li>delete on hot or warm storage</li>
<li>read on cache or hot or warm storage</li>
</ol>
</li>
<li>controller<ol>
<li>provision new machines</li>
<li>Maintain pool of unlocked volumes</li>
<li>ensure all logical volumes have enough physical volumes backing them</li>
<li>create new physical volumes if necessary</li>
<li>perform compaction and garbage clean</li>
</ol>
</li>
<li>Router tier<ol>
<li>存储了逻辑volume到物理volume的映射</li>
</ol>
</li>
<li>Transformer Tier<ol>
<li>讲计算和存储分离，计算节点用来计算，存储节点仅仅用来存取数据</li>
</ol>
</li>
</ol>
<p>……..(未读完)</p>
</li>
</ol>
</li>
</ol>
<h2 id="可靠性策略"><a href="#可靠性策略" class="headerlink" title="可靠性策略"></a>可靠性策略</h2><ol>
<li>副本策略：不同节点/不同机架/不同DC</li>
<li>一致性hash</li>
<li>CRUSH（Controlled Replication Under Scalable Hashing）：CRUSH 算法的设置目的是使数据能够根<strong>据设备的存储能力和宽带资源加权平均地分布，</strong>并保持一个相对的概率平衡。 副本放置在具有层次结构的存储设备中，这对数据安全也有重要影响。 通过反射系统的物理安装组织，CRUSH算法可以将系统模块化，从而定位潜在的设备故障。</li>
<li>EC(Erasure Code) 纠删码<ol>
<li>特点：<ol>
<li>低冗余，高磁盘利用率</li>
<li>数据恢复代价高</li>
<li>数据更新代价高</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="分布式事务协议"><a href="#分布式事务协议" class="headerlink" title="分布式事务协议"></a>分布式事务协议</h2><ol>
<li>2PC<ol>
<li>阶段：<ol>
<li>Prepare(询问):master发送prepare给参与节点，参与节点执行事务中的操作，并返回yes or no给master</li>
<li>Commit（提交或者Abort):master 收到所有节点的yes信息，则进入commit流程，发送commit给所有的参与节点。若收到任意节点的no，则进行abort流程，参与者返回执行结果给master</li>
</ol>
</li>
<li>存在的问题：<ol>
<li>同步阻塞问题：若参与者共享同步资源，参与者访问临界资源存在阻塞</li>
<li>协调者故障导致参与者长期阻塞</li>
<li>数据不一致：协调者在发送commit阶段故障，部分参与者收到了commit</li>
<li>协调者发送commit的时候宕机，唯一收到此消息的参与者此时也宕机，事务状态未可知</li>
</ol>
</li>
</ol>
</li>
<li>3PC<ol>
<li>阶段：<ol>
<li>can-commit<ol>
<li>协调者询问参与者是否可以commit</li>
<li>参与者回复yes or no</li>
</ol>
</li>
<li>pre-commit<ol>
<li>如果参与者全都是yes，则协调者执行：<ol>
<li>协调者发送预提交请求</li>
<li>参与者预提交，记录undo和redo日志，锁定记录，返回执行响应</li>
</ol>
</li>
<li>如果任意一个参与者发送了no或者等待超时，协调者执行：<ol>
<li>发送abort请求</li>
<li>参与者收到abort或者等待超时执行中断</li>
</ol>
</li>
</ol>
</li>
<li>do-commit<ol>
<li>收到全部回复都是yes：<ol>
<li>发送commit</li>
<li>参与者提交事务，释放资源</li>
<li>参与者回复响应</li>
<li>协调者收到全部响应，事务完成</li>
</ol>
</li>
<li>收到任意no<ol>
<li>发送abort</li>
<li>参与者回滚，释放资源</li>
<li>参与者回复响应</li>
<li>协调者收到所有回复，abort完成</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>如何解决协调者超时？<ol>
<li>超时机制</li>
</ol>
</li>
<li>如何解决同步阻塞？<ol>
<li>无法解决</li>
</ol>
</li>
<li>如何解决不一致？<ol>
<li>无法解决</li>
</ol>
</li>
<li>相较于2pc的优点？<ol>
<li>超时机制一定程度上解决协调者宕机问题</li>
<li>第一阶段一分为二，canCommit阶段尽早可以判断事务是否可以执行，占用资源少，提高了吞吐量。</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Javie Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Javie Chen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
