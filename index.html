<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Mars">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Mars">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Javie Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Mars</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mars</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Make the world better place.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/13/GDB-HELLO-WORLD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/13/GDB-HELLO-WORLD/" class="post-title-link" itemprop="url">GDB_HELLO_WORLD</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-13 09:32:05 / Modified: 09:34:20" itemprop="dateCreated datePublished" datetime="2022-05-13T09:32:05+08:00">2022-05-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="GDB单步跟踪"><a href="#GDB单步跟踪" class="headerlink" title="GDB单步跟踪"></a>GDB单步跟踪</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">gdb + 可执行二进制程序</span><br><span class="line">r   + 参数列表</span><br><span class="line">b   + 断点行数</span><br><span class="line">bt 显示堆栈信息</span><br><span class="line">print 打印表达式值</span><br><span class="line">continue 在一个断点之后继续执行</span><br><span class="line">list 列出源码的一部分</span><br><span class="line">next 在停止之后单步执行</span><br><span class="line">set 设置变量的值</span><br><span class="line">step 进入函数调用</span><br><span class="line">watch 监视一个函数的值</span><br><span class="line">rwatch 监视变量被读暂停程序</span><br><span class="line">awatch 监视变量被读写暂停程序</span><br><span class="line">disable 消除断点</span><br><span class="line">display 在断点停止的地方显示表达式的值</span><br><span class="line">enable 允许断点</span><br><span class="line">finish 继续执行直到函数返回</span><br><span class="line">ignore 忽略断点的次数</span><br><span class="line">info 查看信息</span><br><span class="line">load 动态加载程序到调试器</span><br><span class="line">whatis显示变量的值和类型</span><br><span class="line">ptype 显示变量的类型</span><br><span class="line">return 强制从当前函数返回</span><br><span class="line">make 不退出gdb即可重新产生可执行文件</span><br><span class="line">shel 不退出gdb即可执行linux shell命令</span><br><span class="line">help</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><table>
<thead>
<tr>
<th>参数</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>指定可执行文件名</td>
</tr>
<tr>
<td>-c</td>
<td>指定coredump文件</td>
</tr>
<tr>
<td>-d</td>
<td>指定目录加入到源文件搜索路径</td>
</tr>
<tr>
<td>–cd</td>
<td>指定目录作为路径运行gdb</td>
</tr>
<tr>
<td>-s</td>
<td>指定文件读取符号表</td>
</tr>
<tr>
<td>-p</td>
<td>指定attach进程</td>
</tr>
</tbody></table>
<h2 id="调试进程"><a href="#调试进程" class="headerlink" title="调试进程"></a>调试进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb -p 进程名</span><br><span class="line">gdb attach 进程名</span><br></pre></td></tr></table></figure>

<h2 id="调试线程"><a href="#调试线程" class="headerlink" title="调试线程"></a>调试线程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info thread //列出已允许的进程下的线程</span><br><span class="line">thread 线程号 //切换到线程</span><br></pre></td></tr></table></figure>

<h2 id="查看相关信息"><a href="#查看相关信息" class="headerlink" title="查看相关信息"></a>查看相关信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info　　thread　　  //列出线程</span><br><span class="line">(gdb) info　　register　 //列出寄存器</span><br><span class="line">(gdb) info　　frame　   //列出栈帧</span><br><span class="line">(gdb) info　　files　　//列出当前文件</span><br><span class="line">(gdb) info　　share　 //列出当前共享库</span><br></pre></td></tr></table></figure>

<h2 id="指定程序允许参数"><a href="#指定程序允许参数" class="headerlink" title="指定程序允许参数"></a>指定程序允许参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set args 1 2 3 4</span><br><span class="line">show args</span><br></pre></td></tr></table></figure>

<h2 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">path 设定程序的允许路径</span><br><span class="line">show path</span><br><span class="line">set environment K=v 设置环境变量</span><br><span class="line">show environment 查看环境变量</span><br><span class="line">show language 查看语言环境</span><br><span class="line">info frame 查看函数的程序语言</span><br><span class="line">info source 查看当前文件的程序语言</span><br><span class="line">info breakpoints 显示所有断点</span><br><span class="line">info terminal 显示程序用到的终端模式</span><br></pre></td></tr></table></figure>

<h2 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">break function 进入指定函数时停住</span><br><span class="line">break n 在指定行号停住</span><br><span class="line">break +offset / -offset 在行号后offset行停住或者前offset行停住</span><br><span class="line">break filename:linenum filename的linenum行停住</span><br><span class="line">break filename:function 同理</span><br><span class="line">break *address 在程序运行的内存地址处停住</span><br><span class="line">break 没有参数时表示在下一条指令处停住</span><br></pre></td></tr></table></figure>

<h2 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delte n 删除n号断点</span><br><span class="line">delte 删除所有断点</span><br><span class="line">clear 删除行n上面的所有断点</span><br></pre></td></tr></table></figure>

<h2 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">run/r 程序执行直到遇到断点</span><br><span class="line">continue/c 程序执行直到遇到下个断点</span><br><span class="line">next/n 执行下条语句</span><br><span class="line">step/s 单步进入</span><br><span class="line">finish 跳出当前函数</span><br><span class="line">jump location 直到下一条语句的运行点</span><br><span class="line">print/p 输出变量值</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print num</span><br><span class="line">(gdb) p num</span><br><span class="line">(gdb) print file::variable</span><br><span class="line">(gdb) print function::variable</span><br><span class="line">(gdb) p *array@len</span><br><span class="line"><span class="meta">$</span><span class="bash">1 = &#123;2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">静态数组直接<span class="built_in">print</span> + 数组名就可以打印内容</span></span><br></pre></td></tr></table></figure>

<h2 id="源代码显示"><a href="#源代码显示" class="headerlink" title="源代码显示"></a>源代码显示</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">命令	解析</span><br><span class="line">list n	显示程序第n行的周围的源程序。</span><br><span class="line">list function	显示函数名为function的函数的源程序。</span><br><span class="line">list +n	显示当前行n后面的源程序。</span><br><span class="line">list -n	显示当前行n前面的源程序。</span><br><span class="line">set listsize	设置一次显示源代码的行数。</span><br><span class="line">show listsize	查看当前listsize的设置。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看源代码的内存地址</span></span><br><span class="line">(gdb) info line tst.c:func</span><br><span class="line">Line 5 of &quot;tst.c&quot; starts at address 0x8048456 and ends at 0x804845d .</span><br></pre></td></tr></table></figure>

<h2 id="查看内存地址保存的值"><a href="#查看内存地址保存的值" class="headerlink" title="查看内存地址保存的值"></a>查看内存地址保存的值</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：</span><br><span class="line"></span><br><span class="line">(gdb) x/nfu addr</span><br><span class="line">1</span><br><span class="line">n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。</span><br><span class="line">f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是</span><br><span class="line">指令地址，那么格式可以是i。</span><br><span class="line">u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可</span><br><span class="line">以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当</span><br><span class="line">我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作</span><br><span class="line">一个值取出来。</span><br><span class="line">addr表示一个内存地址。</span><br><span class="line">n/f/u三个参数可以一起使用。例如：</span><br><span class="line"></span><br><span class="line">(gdb) x/3uh 0x54320 //从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。</span><br></pre></td></tr></table></figure>

<h2 id="查看寄存器"><a href="#查看寄存器" class="headerlink" title="查看寄存器"></a>查看寄存器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info registers</span><br><span class="line">info all-registers</span><br></pre></td></tr></table></figure>

<h2 id="显示堆栈"><a href="#显示堆栈" class="headerlink" title="显示堆栈"></a>显示堆栈</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) backtrace [-full] [n]</span><br><span class="line">/*命令产生一张列表，包含着从最近的过程开始的所有有效过程和调用这些过程的参数。</span><br><span class="line">n：一个整数值，当为正整数时，表示打印最里层的 n 个栈帧的信息；n为负整数时，那么表示打印最外层n个栈帧的信息；</span><br><span class="line">-full：打印栈帧信息的同时，打印出局部变量的值</span><br><span class="line">注意，当调试多线程程序时，该命令仅用于打印当前线程中所有栈帧的信息。</span><br><span class="line">如果想要打印所有线程的栈帧信息，应执行thread apply all backtrace命令*/</span><br></pre></td></tr></table></figure>

<h2 id="显示栈帧"><a href="#显示栈帧" class="headerlink" title="显示栈帧"></a>显示栈帧</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">frame 或 f 会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。</span><br><span class="line">查看当前栈帧中存储的信息</span><br><span class="line"></span><br><span class="line">(gdb) info frame</span><br><span class="line">Stack level 0, frame at 0x7ffc1da10e80:</span><br><span class="line"> rip = 0x7f800008b4e3 in __epoll_wait_nocancel; saved rip = 0x5560eac8b902</span><br><span class="line"> called by frame at 0x7ffc1da11280</span><br><span class="line"> Arglist at 0x7ffc1da10e70, args:</span><br><span class="line"> Locals at 0x7ffc1da10e70, Previous frame&#x27;s sp is 0x7ffc1da10e80</span><br><span class="line"> Saved registers:</span><br><span class="line">  rip at 0x7ffc1da10e78</span><br><span class="line"></span><br><span class="line">该命令会依次打印出当前栈帧的如下信息：</span><br><span class="line">1、当前栈帧的编号，以及栈帧的地址；</span><br><span class="line">2、当前栈帧对应函数的存储地址，以及该函数被调用时的代码存储的地址</span><br><span class="line">3、当前函数的调用者，对应的栈帧的地址；</span><br><span class="line">4、编写此栈帧所用的编程语言；</span><br><span class="line">5、函数参数的存储地址以及值；</span><br><span class="line">6、函数中局部变量的存储地址；</span><br><span class="line">7、栈帧中存储的寄存器变量，例如指令寄存器（64位环境中用 rip 表示，32为环境中用eip 表示）、</span><br><span class="line">堆栈基指针寄存器（64位环境用 rbp表示，32位环境用 ebp表示）等。</span><br></pre></td></tr></table></figure>

<h2 id="搜索源代码"><a href="#搜索源代码" class="headerlink" title="搜索源代码"></a>搜索源代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward-search</span><br><span class="line">reverse-search</span><br></pre></td></tr></table></figure>

<h2 id="设置观察点"><a href="#设置观察点" class="headerlink" title="设置观察点"></a>设置观察点</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch 	为表达式(变量)expr设置一个观察点。一旦表达式值有变化时，马上停住程序</span><br><span class="line">(gdb) watch i != 10</span><br><span class="line">//这里，i != 10这个表达式一旦变化，则停住。watch &lt;expr&gt; 为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序(也是一种断点)。</span><br></pre></td></tr></table></figure>

<h2 id="设置捕捉点"><a href="#设置捕捉点" class="headerlink" title="设置捕捉点"></a>设置捕捉点</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可设置捕捉点来补捉程序运行时的一些事件。如载入共享库(动态链接库)或是C++的异常。设置捕捉点的格式为：</span><br><span class="line">//catch 	当event发生时，停住程序</span><br><span class="line">(gdb) info catch</span><br><span class="line">//打印出当前的函数中的异常处理信息。</span><br><span class="line">(gdb) info locals</span><br><span class="line">//打印出当前函数中所有局部变量及其值。</span><br></pre></td></tr></table></figure>

<h2 id="强制调用函数"><a href="#强制调用函数" class="headerlink" title="强制调用函数"></a>强制调用函数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) call &lt;expr&gt;</span><br><span class="line">/*这里,&lt;expr&gt;可以是一个函数，这样就会返回函数的返回值，如果函数的返回类型是void那么就不会打印函数的返回值,但是实践发现，函数运行过程中的打印语句还是没有被打印出来。</span><br><span class="line">表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返</span><br><span class="line">回值是void，那么就不显示。*/</span><br></pre></td></tr></table></figure>

<h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill 终止正在调试的程序</span><br><span class="line">detach 将gdb和程序分离</span><br><span class="line">q 退出gdb</span><br></pre></td></tr></table></figure>

<h2 id="打印美化"><a href="#打印美化" class="headerlink" title="打印美化"></a>打印美化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set print pretty on</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/26/Bloom-Filter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/26/Bloom-Filter/" class="post-title-link" itemprop="url">Bloom_Filter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-26 17:13:33 / Modified: 17:13:58" itemprop="dateCreated datePublished" datetime="2022-01-26T17:13:33+08:00">2022-01-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>可以告诉程序，某个值一定不存在或者可能存在。带有概率性的结论</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>高效、占用空间小</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>结论是概率性的，存在false positive的可能，即有个值实际上不存在，但是BF告诉我，值存在。</p>
<h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyr6lp0apij30rl0g4aat.jpg" alt="image-20220126170232622"></p>
<p>使用一个bitMap和若干个hash函数。</p>
<ul>
<li>put Key A：A key 进来时，使用提供的若干hash函数算的几个位置的值，将这些位置的值置为1。</li>
<li>check key A existence: 检查A key是否存在，使用提供的若干hash函数算出若干index，检查这些index上的值是否都为1。<ul>
<li>如果都为1：key A可能存在，因为存在其他key将key A的位置都置为了1的可能性</li>
<li>如果有任何一个index上不为1：key A一定不存在</li>
</ul>
</li>
</ul>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ol>
<li>利用BF减少磁盘IO或者网络请求，如果key不存在，则直接短路返回</li>
<li>利用BF查找key是否存在，可能会返回错误的预判</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/05/DAOS-simple-obj-example/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/05/DAOS-simple-obj-example/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-05 14:51:03 / Modified: 15:03:10" itemprop="dateCreated datePublished" datetime="2022-01-05T14:51:03+08:00">2022-01-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Daos-simple-Obj"><a href="#Daos-simple-Obj" class="headerlink" title="Daos simple Obj"></a>Daos simple Obj</h1><h2 id="Connect-Pool"><a href="#Connect-Pool" class="headerlink" title="Connect Pool"></a>Connect Pool</h2><h2 id="Create-Container"><a href="#Create-Container" class="headerlink" title="Create Container"></a>Create Container</h2><h2 id="Example-daos-key-array"><a href="#Example-daos-key-array" class="headerlink" title="Example_daos_key_array"></a>Example_daos_key_array</h2><ol>
<li><p>daos_obj_generate_oid</p>
<ol>
<li>poh = dc_cont_hdl2pool_hdl(coh); // 获取cookie</li>
<li>pool = dc_hdl2pool(poh); //获取pool<ol>
<li>获取plmap，一个双向链表</li>
<li>获取pool</li>
</ol>
</li>
</ol>
</li>
<li><p>daos_obj_open(coh, oid, DAOS_OO_RW, &amp;oh, NULL);</p>
<ol>
<li>rc = dc_obj_open_task_create(coh, oid, mode, oh, ev, NULL, &amp;task); //创建task</li>
<li>dc_task_schedule(tse_task_t *task, bool instant)//执行task</li>
</ol>
</li>
<li><p>dts_buf_render//创建buffer</p>
</li>
<li><p>循环创建十个Dkey：</p>
<ol>
<li><p>d_iov_set(&amp;dkey, dkey_str, strlen(dkey_str));//初始化dkey</p>
</li>
<li><p>rc = daos_obj_update(oh, DAOS_TX_NONE, 0, &amp;dkey, 1, &amp;iod, &amp;sgl,NULL);//更新dkey，一个dkey下只有一个akey，因此只有1个oid和一个sgl.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">iod // iovec for memory buffer</span><br><span class="line">&#123;...&#125;</span><br><span class="line">iod_name</span><br><span class="line">iov_buf:0x5555555596e4</span><br><span class="line">iov_buf_len:4</span><br><span class="line">iov_len:4</span><br><span class="line">iod_type:DAOS_IOD_ARRAY</span><br><span class="line">iod_size:1</span><br><span class="line">iod_flags:0</span><br><span class="line">iod_nr:1</span><br><span class="line">iod_recxs:0x7fffffffd710</span><br><span class="line">rx_idx:0</span><br><span class="line">rx_nr:1024</span><br><span class="line">------------</span><br><span class="line">sgl  // scatter and gather list for memory buffers</span><br><span class="line">&#123;...&#125;</span><br><span class="line">sg_nr:1</span><br><span class="line">sg_nr_out:0</span><br><span class="line">sg_iovs:0x7fffffffd740</span><br><span class="line">iov_buf:0x7fffffffd7c0</span><br><span class="line">iov_buf_len:1024</span><br><span class="line">iov_len:1024</span><br><span class="line">------------</span><br><span class="line">daos_recx_t // 记录array的第一个元素地址和其中的元素个数</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>循环fetch 10个dkey</p>
</li>
<li><p>遍历所有的dkey</p>
</li>
<li><p>删除一个dkey</p>
</li>
<li><p>遍历所有dkey，现在只有9个dkey了</p>
</li>
<li><p>daos_obj_close(oh, NULL);//关闭obj</p>
</li>
</ol>
<h2 id="example-daos-key-sv"><a href="#example-daos-key-sv" class="headerlink" title="example_daos_key_sv()"></a>example_daos_key_sv()</h2><ol>
<li><p>daos_obj_generate_oid(coh, &amp;oid, 0, OC_SX, 0, 0);</p>
</li>
<li><p>rc = daos_obj_open(coh, oid, DAOS_OO_RW, &amp;oh, NULL);</p>
</li>
<li><p>dts_buf_render(buf, BUFLEN);</p>
</li>
<li><p>rc = daos_obj_update(oh, DAOS_TX_NONE, 0, &amp;dkey, 1, &amp;iod, &amp;sgl,NULL);</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">oh</span><br><span class="line">&#123;...&#125;</span><br><span class="line">cookie:71</span><br><span class="line">dkey</span><br><span class="line">&#123;...&#125;</span><br><span class="line">iov_buf:0x7fffffffd780</span><br><span class="line">iov_buf_len:6</span><br><span class="line">iov_len:6</span><br><span class="line">iod</span><br><span class="line">&#123;...&#125;</span><br><span class="line">iod_name</span><br><span class="line">iod_type:DAOS_IOD_SINGLE</span><br><span class="line">iod_size:1024</span><br><span class="line">iod_flags:4</span><br><span class="line">iod_nr:1</span><br><span class="line">iod_recxs:0x0</span><br><span class="line">rx_idx</span><br><span class="line">rx_nr</span><br><span class="line">&#123;...&#125;</span><br><span class="line">sg_nr:1</span><br><span class="line">sg_nr_out:0</span><br><span class="line">sg_iovs:0x7fffffffd720</span><br><span class="line">iov_buf:0x7fffffffd7c0</span><br><span class="line">iov_buf_len:1024</span><br><span class="line">iov_len:1024</span><br></pre></td></tr></table></figure></li>
<li><p>循环10次，创建10个dkey，每个dkey有一个akey和一个1k的single value：</p>
<ol>
<li>初始化参数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> iod.iod_nr	= <span class="number">1</span>; <span class="comment">/** has to be 1 for single value */</span></span><br><span class="line">iod.iod_size	= BUFLEN; <span class="comment">/** size of the single value */</span></span><br><span class="line">iod.iod_recxs	= <span class="literal">NULL</span>; <span class="comment">/** recx is ignored for single value */</span></span><br><span class="line">iod.iod_type	= DAOS_IOD_SINGLE; <span class="comment">/** value type of the akey */</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>rc = daos_obj_update(oh, DAOS_TX_NONE, 0, &amp;dkey, 1, &amp;iod, &amp;sgl,<br>NULL);</li>
</ol>
</li>
<li><p>循环10次update：</p>
<ol>
<li>rc = daos_obj_update(oh, DAOS_TX_NONE, 0, &amp;dkey, 1, &amp;iod, &amp;sgl, NULL);</li>
</ol>
</li>
<li><p>循环10次fetch：</p>
<ol>
<li>rc = daos_obj_fetch(oh, DAOS_TX_NONE, 0, &amp;dkey, 1, &amp;iod, &amp;sgl, NULL, NULL);</li>
</ol>
</li>
</ol>
<h2 id="example-daos-array"><a href="#example-daos-array" class="headerlink" title="example_daos_array()"></a>example_daos_array()</h2><ol>
<li><p>daos_array_generate_oid(coh, &amp;oid, true, 0, 0, 0);</p>
</li>
<li><p>Create the array object with cell size 1 (byte array) and 1m chunk size (similar to stripe size in Lustre). Both are configurable by the user of course :</p>
<p>rc = daos_array_create(coh, oid, DAOS_TX_NONE, 1, 1048576, &amp;oh,<br>NULL);</p>
</li>
<li><p>rc = daos_array_write(oh, DAOS_TX_NONE, &amp;iod, &amp;sgl, NULL);</p>
</li>
<li><p>rc = daos_array_get_size(oh, DAOS_TX_NONE, &amp;array_size, NULL); // check size</p>
</li>
<li><p>rc = daos_array_read(oh, DAOS_TX_NONE, &amp;iod, &amp;sgl, NULL); // read &amp; verify</p>
</li>
<li><p>daos_array_close(oh, NULL); //close</p>
</li>
</ol>
<h2 id="example-daos-kv"><a href="#example-daos-kv" class="headerlink" title="example_daos_kv()"></a>example_daos_kv()</h2><p>Abstract iyt the 2-level keys and exposes a single Key and atomic value to represent a more traditional KV API.</p>
<ol>
<li>daos_obj_generate_oid(coh, &amp;oid, DAOS_OT_KV_HASHED, OC_SX, 0, 0);</li>
<li>rc = daos_kv_open(coh, oid, DAOS_OO_RW, &amp;oh, NULL);</li>
<li>dts_buf_render(buf, BUFLEN);</li>
<li>循环10次，为rank0 put 10个key：<ol>
<li>rc = daos_kv_put(oh, DAOS_TX_NONE, 0, key, BUFLEN, buf, NULL);</li>
</ol>
</li>
<li>循环10次：<ol>
<li>rc = daos_kv_get(oh, DAOS_TX_NONE, 0, key, &amp;size, NULL, NULL); // query size &amp; verify</li>
<li>rc = daos_kv_get(oh, DAOS_TX_NONE, 0, key, &amp;size, rbuf, NULL); // get data write into rbuf</li>
<li>memcmp(buf, rbuf, BUFLEN) // verify</li>
</ol>
</li>
<li>list_keys(oh, &amp;num_keys); // 10个key</li>
<li>rc = daos_kv_remove(oh, DAOS_TX_NONE, 0, key, NULL); // remove a key</li>
<li>list_keys(oh, &amp;num_keys); // 9个key</li>
<li>daos_kv_close(oh, NULL);</li>
</ol>
<h2 id="daos-cont-close-coh-NULL"><a href="#daos-cont-close-coh-NULL" class="headerlink" title="daos_cont_close(coh, NULL);"></a>daos_cont_close(coh, NULL);</h2><h2 id="daos-pool-disconnect-poh-NULL"><a href="#daos-pool-disconnect-poh-NULL" class="headerlink" title="daos_pool_disconnect(poh, NULL)"></a>daos_pool_disconnect(poh, NULL)</h2><h2 id="daos-fini"><a href="#daos-fini" class="headerlink" title="daos_fini();"></a>daos_fini();</h2><h2 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h2><h3 id="daos-obj-generate-oid"><a href="#daos-obj-generate-oid" class="headerlink" title="daos_obj_generate_oid"></a>daos_obj_generate_oid</h3><ol>
<li>输入：<ul>
<li>daos_handle_t oh ： 存储了一个unsigned int 64的cookie</li>
<li>daos_obj_id_t  oid : daos object id, 用两个64位int 存储 lo（low）和 high （high）</li>
<li>enum DAOS_OT_KV_HASHED :  flat KV (no akey) with integer dkey </li>
<li>OC_SX ：OC策略</li>
<li>0 ：边长参数</li>
<li>0 ：变长参数</li>
</ul>
</li>
<li>实现，内部调用了<code>daos_obj_generate_oid2</code><ul>
<li>输入：<ul>
<li>daos_handle_t</li>
<li>daos_obj_id_t</li>
<li>daos_otype_t</li>
<li>daos_oclass_id_t ： object class id， 32位int</li>
<li>daos_oclass_hints_t  ：object class hint， 16位int</li>
<li>args : 其他int参数</li>
</ul>
</li>
<li>dc_cont_hdl2pool_hdl<ul>
<li>根据cookie获取pool handler</li>
</ul>
</li>
<li>rc = pl_map_query(pool-&gt;dp_pool, &amp;attr)</li>
<li>dc_pool_put(struct dc_pool *pool) // 将pool-&gt;dp_hlink放入了一个双向队列中？</li>
<li>按照选定的OC策略做相应的操作</li>
<li>daos_obj_set_oid(oid, type, ord, nr_grp, args); // 就生成好了？</li>
</ul>
</li>
</ol>
<h3 id="daos-kv-open"><a href="#daos-kv-open" class="headerlink" title="daos_kv_open"></a>daos_kv_open</h3><ol>
<li>输入：<ul>
<li>daos_handle_t</li>
<li>daos_obj_id_t</li>
<li>mode : int 类型</li>
<li>daos_handle_t</li>
<li>daos_event_t : event and event queue, maybe used for debug</li>
</ul>
</li>
<li>调用<code>rc = dc_task_create(dc_kv_open, NULL, ev, &amp;task)</code><ul>
<li>将参数包装成dc_kv_open结构体</li>
<li>生成一个kvOpen的task并调度</li>
</ul>
</li>
</ol>
<h3 id="dts-buf-render-buf-BUFLEN"><a href="#dts-buf-render-buf-BUFLEN" class="headerlink" title="dts_buf_render(buf, BUFLEN)"></a>dts_buf_render(buf, BUFLEN)</h3><ol>
<li>输入buf和len</li>
<li>利用随机生成的字符填满buf</li>
</ol>
<h3 id="daos-kev-put"><a href="#daos-kev-put" class="headerlink" title="daos_kev_put"></a>daos_kev_put</h3><ol>
<li>输入：<ul>
<li>daos_handle_t oh</li>
<li>daos_handle_t th</li>
<li>uint64_t flag</li>
<li>char * key</li>
<li>daos_size_t buf_size</li>
<li>void * buf</li>
<li>daos_event_t * ev</li>
</ul>
</li>
<li>调用rc = dc_task_create(dc_kv_put, NULL, ev, &amp;task);</li>
<li>将参数包装到task的args中</li>
<li>调用dc_task_schedule(task, true);<ol>
<li>task_is_valid(task)</li>
<li>ev = task_ptr2args(task)-&gt;ta_ev;</li>
<li>rc = daos_event_launch(ev);<ul>
<li>输入：daos_event *ev</li>
</ul>
</li>
<li>rc = tse_task_schedule(task, instant);</li>
</ol>
</li>
</ol>
<h3 id="kv-update"><a href="#kv-update" class="headerlink" title="kv_update"></a>kv_update</h3><ol>
<li><p>daos_io_0线程接收到io请求，crt_handle_rpc(void *arg)处理rpc</p>
</li>
<li><p>ds_obj_rw_handler(crt_rpc_t *rpc)处理rpc</p>
<ul>
<li><p>obj_ioc_begin(orw-&gt;orw_oid.id_pub, orw-&gt;orw_map_ver,</p>
<p>​               orw-&gt;orw_pool_uuid, orw-&gt;orw_co_hdl,</p>
<p>​               orw-&gt;orw_co_uuid, opc_get(rpc-&gt;cr_opc),</p>
<p>​               orw-&gt;orw_flags, &amp;ioc); // various check before access VOS</p>
</li>
</ul>
</li>
<li><p>​    rc = process_epoch(&amp;orw-&gt;orw_epoch, &amp;orw-&gt;orw_epoch_first,</p>
<p>​               &amp;orw-&gt;orw_flags); // 处理epoch相关</p>
</li>
</ol>
<h2 id="Object-Update"><a href="#Object-Update" class="headerlink" title="Object_Update"></a>Object_Update</h2><ol>
<li><p>callstack</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">libvos_srv.so!dkey_update(<span class="keyword">daos_key_t</span> * dkey, <span class="keyword">uint32_t</span> pm_ver, struct vos_io_context * ioc) (/home/kuhan/daos/src/vos/vos_io.c:<span class="number">1803</span>)</span><br><span class="line">libvos_srv.so!vos_update_end(<span class="keyword">daos_handle_t</span> ioh, <span class="keyword">uint32_t</span> pm_ver, <span class="keyword">daos_key_t</span> * dkey, <span class="keyword">int</span> err, <span class="keyword">daos_size_t</span> * size, struct dtx_handle * dth) (/home/kuhan/daos/src/vos/vos_io.c:<span class="number">2278</span>)</span><br><span class="line">libobj.so!obj_rw_complete(struct dtx_handle * dth, <span class="keyword">int</span> status, <span class="keyword">daos_handle_t</span> ioh, struct obj_io_context * ioc, <span class="keyword">crt_rpc_t</span> * rpc) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">128</span>)</span><br><span class="line">libobj.so!obj_local_rw_internal(struct dtx_handle * dth, <span class="keyword">uint64_t</span> * split_offs, struct dcs_iod_csums * split_csums, <span class="keyword">daos_iod_t</span> * split_iods, struct obj_io_context * ioc, <span class="keyword">crt_rpc_t</span> * rpc) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">1677</span>)</span><br><span class="line">libobj.so!obj_local_rw(<span class="keyword">crt_rpc_t</span> * rpc, struct obj_io_context * ioc, <span class="keyword">daos_iod_t</span> * split_iods, struct dcs_iod_csums * split_csums, <span class="keyword">uint64_t</span> * split_offs, struct dtx_handle * dth, <span class="built_in">_Bool</span> pin) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">1697</span>)</span><br><span class="line">libobj.so!obj_tgt_update(<span class="keyword">dtx_sub_comp_cb_t</span> comp_cb, <span class="keyword">void</span> * arg, struct dtx_leader_handle * dlh) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">2425</span>)</span><br><span class="line">libobj.so!obj_tgt_update(struct dtx_leader_handle * dlh, <span class="keyword">void</span> * arg, <span class="keyword">int</span> idx, <span class="keyword">dtx_sub_comp_cb_t</span> comp_cb) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">2356</span>)</span><br><span class="line">libobj.so!ds_obj_rw_handler(<span class="keyword">crt_rpc_t</span> * rpc) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">2664</span>)</span><br><span class="line">libcart.so<span class="number">.4</span>!crt_handle_rpc(<span class="keyword">void</span> * arg) (/home/kuhan/daos/src/cart/crt_rpc.c:<span class="number">1638</span>)</span><br><span class="line">libabt.so<span class="number">.1</span>!ABTD_ythread_func_wrapper (未知源:<span class="number">0</span>)</span><br><span class="line">libabt.so<span class="number">.1</span>!make_fcontext (未知源:<span class="number">0</span>)</span><br><span class="line">[Unknown/Just-In-Time compiled code] (未知源:<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="obj-local-rw-internal"><a href="#obj-local-rw-internal" class="headerlink" title="obj_local_rw_internal"></a>obj_local_rw_internal</h3><ol>
<li><p>​        rc = vos_update_begin(ioc-&gt;ioc_vos_coh, orw-&gt;orw_oid,</p>
<p>​                  orw-&gt;orw_epoch, cond_flags, dkey,</p>
<p>​                  orw-&gt;orw_nr, iods, iod_csums,</p>
<p>​                  ioc-&gt;ioc_coc-&gt;sc_props.dcp_dedup_size,</p>
<p>​                  &amp;ioh, dth);</p>
<ul>
<li><p>rc = vos_check_akeys(iod_nr, iods);</p>
</li>
<li><p>vos_ioc_create</p>
</li>
<li><p> rc = vos_space_hold(vos_cont2pool(ioc-&gt;ic_cont), flags, dkey, iod_nr,</p>
</li>
</ul>
<p>  ​                iods, iods_csums, &amp;ioc-&gt;ic_space_held[0]);</p>
<ul>
<li><p>rc = dkey_update_begin(ioc);</p>
<ul>
<li><p>循环rc = akey_update_begin(ioc);</p>
<ul>
<li><p>获取dcs_csum_info</p>
</li>
<li><p>获取daos_iod_t,1k</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iod</span><br><span class="line"><span class="number">0x7f9a07a4dee0</span></span><br><span class="line">iod_name</span><br><span class="line">iod_type:DAOS_IOD_ARRAY</span><br><span class="line">iod_size:<span class="number">1</span></span><br><span class="line">iod_flags:<span class="number">0</span></span><br><span class="line">iod_nr:<span class="number">1</span></span><br><span class="line">iod_recxs:<span class="number">0x7f9a07e9fbf0</span></span><br><span class="line">rx_idx:<span class="number">0</span></span><br><span class="line">rx_nr:<span class="number">1024</span></span><br></pre></td></tr></table></figure></li>
<li><p>for (i = 0; i &lt; iod-&gt;iod_nr; i++) //循环</p>
<ul>
<li><p>size = (iod-&gt;iod_type == DAOS_IOD_SINGLE) ? iod-&gt;iod_size :</p>
<p>​                iod-&gt;iod_recxs[i].rx_nr * iod-&gt;iod_size; //获取size，1k–1024</p>
</li>
<li><p>media = vos_media_select(vos_cont2pool(ioc-&gt;ic_cont),</p>
<p>​                     iod-&gt;iod_type, size); //决定往哪个media上写，0 –&gt; scm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A simple media selection policy embedded in VOS, which select media by</span></span><br><span class="line"><span class="comment"> * akey type and record size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint16_t</span></span></span><br><span class="line"><span class="function"><span class="title">vos_media_select</span><span class="params">(struct vos_pool *pool, <span class="keyword">daos_iod_type_t</span> type, <span class="keyword">daos_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;vp_vea_info == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> DAOS_MEDIA_SCM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (size &gt;= VOS_BLK_SZ) ? DAOS_MEDIA_NVME : DAOS_MEDIA_SCM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首先做特判</span></span><br><span class="line"><span class="comment">// 如果大于等于4k，写到NVME上，否则写到SCM</span></span><br></pre></td></tr></table></figure></li>
<li><p>iod-&gt;iod_type<br>为 DAOS_IOD_ARRAY类型：</p>
<ul>
<li><p>rc = vos_reserve_recx(ioc, media, size, recx_csum, csum_len);</p>
<ul>
<li><p>为    struct bio_iov  biov 分配内存</p>
</li>
<li><p>rc = reserve_space(ioc, media, size, &amp;off);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">oc</span><br><span class="line"><span class="number">0x7f9a0724ef00</span></span><br><span class="line">ic_ent_array_alloc</span><br><span class="line">ea_data</span><br><span class="line">ea_ents:<span class="number">0x0</span></span><br><span class="line">ea_ent_nr:<span class="number">0</span></span><br><span class="line">ea_size:<span class="number">0</span></span><br><span class="line">ea_max:<span class="number">0</span></span><br><span class="line">ea_inob:<span class="number">0</span></span><br><span class="line">ea_first_delete:<span class="number">0</span></span><br><span class="line">ea_delete_nr:<span class="number">0</span></span><br><span class="line">ea_embedded_ents</span><br><span class="line">ea_embedded</span><br><span class="line">ic_ent_array:<span class="number">0x0</span></span><br><span class="line">ic_bound:<span class="number">509171074455830528</span></span><br><span class="line">ic_epr</span><br><span class="line">ic_oid</span><br><span class="line">ic_cont:<span class="number">0x7f9a07e9eb60</span></span><br><span class="line">ic_iods:<span class="number">0x7f9a07a4dee0</span></span><br><span class="line">iod_csums:<span class="number">0x0</span></span><br><span class="line">ic_obj:<span class="number">0x0</span></span><br><span class="line">ic_biod:<span class="number">0x7f99c89c63b0</span></span><br><span class="line">ic_ts_set:<span class="number">0x7f99c89c6f90</span></span><br><span class="line">ic_biov_csums:<span class="number">0x7f99c87c76e0</span></span><br><span class="line">ic_biov_csums_at:<span class="number">0</span></span><br><span class="line">ic_biov_csums_nr:<span class="number">1</span></span><br><span class="line">ic_dkey_info</span><br><span class="line">ic_akey_info</span><br><span class="line">ic_sgl_at:<span class="number">0</span></span><br><span class="line">ic_iov_at:<span class="number">0</span></span><br><span class="line">ic_rsrvd_scm:<span class="number">0x7f9a07e86980</span></span><br><span class="line">ic_umoffs:<span class="number">0x7f9a07e9e6a0</span></span><br><span class="line">ic_umoffs_cnt:<span class="number">0</span></span><br><span class="line">ic_umoffs_at:<span class="number">0</span></span><br><span class="line">  ic_blk_exts</span><br><span class="line">next:<span class="number">0x7f9a0724fb38</span></span><br><span class="line">prev:<span class="number">0x7f9a0724fb38</span></span><br><span class="line">ic_space_held</span><br><span class="line">ic_iod_nr:<span class="number">1</span></span><br><span class="line">ic_dedup_th:<span class="number">4096</span></span><br><span class="line">ic_dedup_entries</span><br><span class="line">ic_dedup_bsgls:<span class="number">0x0</span></span><br><span class="line">ic_dedup_bufs:<span class="number">0x0</span></span><br><span class="line">ic_io_size:<span class="number">0</span></span><br><span class="line">ic_update:<span class="number">1</span></span><br><span class="line">ic_size_fetch:<span class="number">0</span></span><br><span class="line">ic_save_recx:<span class="number">0</span></span><br><span class="line">ic_dedup:<span class="number">0</span></span><br><span class="line">ic_dedup_verify:<span class="number">0</span></span><br><span class="line">ic_read_ts_only:<span class="number">0</span></span><br><span class="line">ic_check_existence:<span class="number">0</span></span><br><span class="line">ic_remove:<span class="number">0</span></span><br><span class="line">ic_skip_fetch:<span class="number">0</span></span><br><span class="line">ic_ec:<span class="number">0</span></span><br><span class="line">ic_shadows:<span class="number">0x0</span></span><br><span class="line">re_nr</span><br><span class="line">re_total</span><br><span class="line">re_snapshot</span><br><span class="line">re_ep_valid</span><br><span class="line">re_items</span><br><span class="line">ic_recx_lists:<span class="number">0x0</span></span><br><span class="line">re_nr</span><br><span class="line">re_total</span><br><span class="line">re_snapshot</span><br><span class="line">re_ep_valid</span><br><span class="line">re_items</span><br></pre></td></tr></table></figure>

<ul>
<li>在SCM上申请内存</li>
</ul>
</li>
<li><p>bio_addr_set(&amp;biov.bi_addr, media, off);//设置偏移量</p>
</li>
<li><p>bio_iov_set_len(&amp;biov, size); //设置长度</p>
</li>
<li><p>rc = iod_reserve(ioc, &amp;biov);</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>*ioh = vos_ioc2ioh(ioc); //获取cookie？</p>
</li>
</ul>
</li>
<li><p>biod = vos_ioh2desc(ioh); //获取io descriptor？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7f99c89c63b0</span></span><br><span class="line">bd_ctxt:<span class="number">0x7f99c89b0650</span></span><br><span class="line">bic_link</span><br><span class="line">bic_umem:<span class="number">0x7f99c860ab58</span></span><br><span class="line">bic_pmempool_uuid:<span class="number">12137328209446634291</span></span><br><span class="line">bic_blob:<span class="number">0x7f99c89b1530</span></span><br><span class="line">bic_xs_ctxt:<span class="number">0x7f9a04427370</span></span><br><span class="line">bic_inflight_dmas:<span class="number">0</span></span><br><span class="line">bic_io_unit:<span class="number">4096</span></span><br><span class="line">bic_pool_id</span><br><span class="line">bic_opening:<span class="number">0</span></span><br><span class="line">bic_closing:<span class="number">0</span></span><br><span class="line">bd_rsrvd</span><br><span class="line">brd_regions:<span class="number">0x0</span></span><br><span class="line">brd_rg_max:<span class="number">0</span></span><br><span class="line">brd_rg_cnt:<span class="number">0</span></span><br><span class="line">brd_dma_chks:<span class="number">0x0</span></span><br><span class="line">brd_chk_max:<span class="number">0</span></span><br><span class="line">brd_chk_cnt:<span class="number">0</span></span><br><span class="line">bd_dma_done:<span class="number">0x10</span></span><br><span class="line">bd_inflights:<span class="number">0</span></span><br><span class="line">bd_result:<span class="number">0</span></span><br><span class="line">bd_chk_type:<span class="number">0</span></span><br><span class="line">bd_type:<span class="number">0</span></span><br><span class="line">bd_buffer_prep:<span class="number">0</span></span><br><span class="line">bd_dma_issued:<span class="number">0</span></span><br><span class="line">bd_retry:<span class="number">0</span></span><br><span class="line">bd_rdma:<span class="number">0</span></span><br><span class="line">bd_bulk_hdls:<span class="number">0x0</span></span><br><span class="line">bd_bulk_max:<span class="number">0</span></span><br><span class="line">bd_bulk_cnt:<span class="number">0</span></span><br><span class="line">bd_sgl_cnt:<span class="number">1</span></span><br><span class="line">bd_sgls</span><br></pre></td></tr></table></figure></li>
<li><p>rc = bio_iod_prep(biod, BIO_CHK_TYPE_IO, rma ? rpc-&gt;cr_ctx : NULL,CRT_BULK_RW);</p>
<ul>
<li><p>rc = iterate_biov(biod, arg ? bulk_map_one : dma_map_one, arg);</p>
<ul>
<li><p>for循环：rc = cb_fn(biod, biov, data);  // 函数指针调用，此处写SCM</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">biod</span><br><span class="line"><span class="number">0x7f99c89c63b0</span></span><br><span class="line">bd_ctxt:<span class="number">0x7f99c89b0650</span></span><br><span class="line">bic_link</span><br><span class="line">bic_umem:<span class="number">0x7f99c860ab58</span></span><br><span class="line">bic_pmempool_uuid:<span class="number">12137328209446634291</span></span><br><span class="line">bic_blob:<span class="number">0x7f99c89b1530</span></span><br><span class="line">bic_xs_ctxt:<span class="number">0x7f9a04427370</span></span><br><span class="line">bic_inflight_dmas:<span class="number">0</span></span><br><span class="line">bic_io_unit:<span class="number">4096</span></span><br><span class="line">bic_pool_id</span><br><span class="line">bic_opening:<span class="number">0</span></span><br><span class="line">bic_closing:<span class="number">0</span></span><br><span class="line">bd_rsrvd</span><br><span class="line">bd_dma_done:<span class="number">0x10</span></span><br><span class="line">bd_inflights:<span class="number">0</span></span><br><span class="line">bd_result:<span class="number">0</span></span><br><span class="line">bd_chk_type:<span class="number">0</span></span><br><span class="line">bd_type:<span class="number">0</span></span><br><span class="line">bd_buffer_prep:<span class="number">0</span></span><br><span class="line">bd_dma_issued:<span class="number">0</span></span><br><span class="line">bd_retry:<span class="number">0</span></span><br><span class="line">bd_rdma:<span class="number">0</span></span><br><span class="line">bd_bulk_hdls:<span class="number">0x0</span></span><br><span class="line">bd_bulk_max:<span class="number">0</span></span><br><span class="line">bd_bulk_cnt:<span class="number">0</span></span><br><span class="line">bd_sgl_cnt:<span class="number">1</span></span><br><span class="line">bd_sgls</span><br><span class="line">--------------</span><br><span class="line">biov</span><br><span class="line"><span class="number">0x7f9a07e9eeb0</span></span><br><span class="line">bi_buf:<span class="number">0x0</span></span><br><span class="line">bi_data_len:<span class="number">1024</span></span><br><span class="line">bi_addr</span><br><span class="line">ba_off:<span class="number">4576720</span></span><br><span class="line">ba_type:<span class="number">0</span> <span class="string">&#x27;\000&#x27;</span></span><br><span class="line">ba_pad1:<span class="number">0</span> <span class="string">&#x27;\000&#x27;</span></span><br><span class="line">ba_flags:<span class="number">0</span></span><br><span class="line">ba_pad2:<span class="number">0</span></span><br><span class="line">bi_prefix_len:<span class="number">0</span></span><br><span class="line">bi_suffix_len:<span class="number">0</span></span><br><span class="line">--------------</span><br><span class="line">data</span><br><span class="line"><span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>函数指针调用dma_map_one(struct bio_desc *biod, struct bio_iov *biov, void *arg)</p>
<p>// /* Convert offset of @biov into memory pointer */</p>
<ul>
<li>direct_scm_access(biod, biov):<ul>
<li>bio_iov_set_raw_buf(biov,umem_off2ptr(umem, bio_iov2raw_off(biov)));</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>rc = bio_iod_copy(biod, orw-&gt;orw_sgls.ca_arrays, orw-&gt;orw_nr);</p>
<ul>
<li>将参数包装成bio_copy_args结构体</li>
<li>iterate_biov(biod, copy_one, &amp;arg);</li>
</ul>
</li>
<li><p>rc = vos_dedup_verify(ioh);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check if the dedup data is identical to the RDMA data in a temporal</span></span><br><span class="line"><span class="comment"> * allocated DRAM extent, if memcmp fails, allocate a new SCM extent and</span></span><br><span class="line"><span class="comment"> * update it&#x27;s address in VOS tree, otherwise, keep using the original</span></span><br><span class="line"><span class="comment"> * dedup data address in VOS tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
<li><p>rc = obj_verify_bio_csum(orw-&gt;orw_oid.id_pub, iods, iod_csums,biod, ioc-&gt;ioc_coc-&gt;sc_csummer,orw-&gt;orw_iod_array.oia_iod_nr); //verify CSUM</p>
</li>
<li><p>rc = obj_rw_complete(rpc, ioc, ioh, rc, dth); // the callstack is deep inside this function…</p>
<ul>
<li><p>rc = vos_update_end(ioh, ioc-&gt;ioc_map_ver,&amp;orwi-&gt;orw_dkey, status,&amp;ioc-&gt;ioc_io_size, dth);</p>
<ul>
<li><p>一些dtx commit逻辑？</p>
</li>
<li><p>err = dkey_update(ioc, pm_ver, dkey, dtx_is_valid_handle(dth) ? dth-&gt;dth_op_seq : VOS_SUB_OP_MAX); // update tree index</p>
<ul>
<li><p>rc = obj_tree_init(obj); // initialize tree for an object</p>
</li>
<li><p>rc = key_tree_prepare(obj, obj-&gt;obj_toh, VOS_BTR_DKEY, dkey,SUBTR_CREATE, DAOS_INTENT_UPDATE, &amp;krec, &amp;ak_toh,ioc-&gt;ic_ts_set);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the subtree roots embedded in the parent tree record.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * akey tree	: all akeys under the same dkey</span></span><br><span class="line"><span class="comment"> * recx tree	: all record extents under the same akey, this function will</span></span><br><span class="line"><span class="comment"> *		  load both btree and evtree root.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="comment">/* NB: In order to avoid complexities of passing parameters to the</span></span><br><span class="line"><span class="comment">	 * multi-nested tree, tree operations are not nested, instead:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * - In the case of fetch, we load the subtree root stored in the</span></span><br><span class="line"><span class="comment">	 *   parent tree leaf.</span></span><br><span class="line"><span class="comment">	 * - In the case of update/insert, we call dbtree_update() which may</span></span><br><span class="line"><span class="comment">	 *   create the root for the subtree, or just return it if it&#x27;s already</span></span><br><span class="line"><span class="comment">	 *   there.</span></span><br><span class="line"><span class="comment">	 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>rc = dbtree_fetch(toh, BTR_PROBE_EQ, intent, key,NULL, &amp;riov);</p>
</li>
<li><p>/* use BTR_PROBE_BYPASS to avoid probe again */</p>
<p>rc = dbtree_upsert(toh, BTR_PROBE_BYPASS, intent, key, &amp;riov);</p>
<ul>
<li><pre><code class="c">Update the value of the provided key, or insert it as a new key if
 * there is no match.
</code></pre>
</li>
<li><p>tcx = btr_hdl2tcx(toh); ///** find the tree context of the handle */</p>
</li>
<li><p>rc = btr_tx_begin(tcx); // begin transaction？</p>
</li>
<li><p>rc = btr_upsert(tcx, opc, intent, key, val);</p>
<ul>
<li>rc = btr_insert(tcx, key, val); // bypass策略，直接取前一次probe的结果，create a new record, insert it into tree leaf node.<ul>
<li>btr_hkey_gen(tcx, key, &amp;rec-&gt;rec_hkey[0]); //生成hkey</li>
<li>rc = btr_node_insert_rec(tcx, trace, rec);<ul>
<li>btr_node_insert_rec_only(tcx, trace, rec);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>btr_tx_end(tcx, rc);</p>
<ul>
<li>rc = umem_tx_commit(btr_umm(tcx));</li>
</ul>
</li>
</ul>
</li>
<li><p>vos_ilog_ts_ignore(vos_obj2umm(obj), &amp;krec-&gt;kr_ilog);</p>
</li>
<li><p>vos_ilog_ts_mark(ts_set, &amp;krec-&gt;kr_ilog);</p>
</li>
</ul>
</li>
<li><p>rc = vos_ilog_update(ioc-&gt;ic_cont, &amp;krec-&gt;kr_ilog, &amp;ioc-&gt;ic_epr,</p>
<p>​                 ioc-&gt;ic_bound, &amp;obj-&gt;obj_ilog_info,</p>
<p>​                 &amp;ioc-&gt;ic_dkey_info, update_cond, ioc-&gt;ic_ts_set); // update dkey log ？</p>
</li>
<li><p>for循环：rc = akey_update(ioc, pm_ver, ak_toh, minor_epc);</p>
<ul>
<li><p>​    rc = key_tree_prepare(obj, ak_toh, VOS_BTR_AKEY,</p>
<p>​                  &amp;iod-&gt;iod_name, flags, DAOS_INTENT_UPDATE,</p>
<p>​                  &amp;krec, &amp;toh, ioc-&gt;ic_ts_set);</p>
</li>
<li><p>….</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>vos_ts_set_check_conflict(ioc-&gt;ic_ts_set, ioc-&gt;ic_epr.epr_hi) // Now that we are past the existence checks, ensure there isn’t a read conflict</p>
</li>
<li><p>err = vos_tx_end(ioc-&gt;ic_cont, dth, &amp;ioc-&gt;ic_rsrvd_scm,&amp;ioc-&gt;ic_blk_exts, tx_started, err); // dtx operations，on scm</p>
</li>
<li><p>vos_ts_set_upgrade(ioc-&gt;ic_ts_set);</p>
</li>
<li><p>vos_space_unhold(vos_cont2pool(ioc-&gt;ic_cont), &amp;ioc-&gt;ic_space_held[0]);</p>
</li>
<li><p>vos_ioc_destroy(ioc, err != 0); // memory free</p>
<ul>
<li>bio_iod_free(ioc-&gt;ic_biod);</li>
<li>vos_obj_release(vos_obj_cache_current(), ioc-&gt;ic_obj, evict);</li>
<li>vos_ioc_reserve_fini(ioc);</li>
<li>vos_ilog_fetch_finish(&amp;ioc-&gt;ic_dkey_info);</li>
<li> vos_ilog_fetch_finish(&amp;ioc-&gt;ic_akey_info);</li>
<li> vos_cont_decref(ioc-&gt;ic_cont);</li>
<li>vos_ts_set_free(ioc-&gt;ic_ts_set);</li>
<li>D_FREE(ioc);</li>
</ul>
</li>
<li><p>vos_dth_set(NULL);</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="update流程"><a href="#update流程" class="headerlink" title="update流程"></a>update流程</h2><ul>
<li>client端：<ul>
<li>调用daos_obj_update</li>
<li>create_task</li>
<li>schedule_task</li>
<li>发RPC</li>
</ul>
</li>
<li>Server端：<ul>
<li>收到rpc</li>
<li>调用rw_handler</li>
<li>leader开始执行</li>
<li>前置检查</li>
<li>预估空间</li>
<li>申请空间</li>
<li>更新Dkey</li>
<li>更新AKey</li>
<li>更新Index</li>
<li>释放空间</li>
<li>reply rpc</li>
</ul>
</li>
</ul>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy2t2613s2j30pl3upn23.jpg" alt="Canvas 1"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/Dkey-Array-Object-update/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/Dkey-Array-Object-update/" class="post-title-link" itemprop="url">Dkey-Array Object update</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-04 17:50:56 / Modified: 17:51:09" itemprop="dateCreated datePublished" datetime="2022-01-04T17:50:56+08:00">2022-01-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="daos-obj-generate-oid"><a href="#daos-obj-generate-oid" class="headerlink" title="daos_obj_generate_oid"></a>daos_obj_generate_oid</h3><ol>
<li>输入：<ul>
<li>daos_handle_t oh ： 存储了一个unsigned int 64的cookie</li>
<li>daos_obj_id_t  oid : daos object id, 用两个64位int 存储 lo（low）和 high （high）</li>
<li>enum DAOS_OT_KV_HASHED :  flat KV (no akey) with integer dkey </li>
<li>OC_SX ：OC策略</li>
<li>0 ：边长参数</li>
<li>0 ：变长参数</li>
</ul>
</li>
<li>实现，内部调用了<code>daos_obj_generate_oid2</code><ul>
<li>输入：<ul>
<li>daos_handle_t</li>
<li>daos_obj_id_t</li>
<li>daos_otype_t</li>
<li>daos_oclass_id_t ： object class id， 32位int</li>
<li>daos_oclass_hints_t  ：object class hint， 16位int</li>
<li>args : 其他int参数</li>
</ul>
</li>
<li>dc_cont_hdl2pool_hdl<ul>
<li>根据cookie获取pool handler</li>
</ul>
</li>
<li>rc = pl_map_query(pool-&gt;dp_pool, &amp;attr)</li>
<li>dc_pool_put(struct dc_pool *pool) // 将pool-&gt;dp_hlink放入了一个双向队列中？</li>
<li>按照选定的OC策略做相应的操作</li>
<li>daos_obj_set_oid(oid, type, ord, nr_grp, args); // 就生成好了？</li>
</ul>
</li>
</ol>
<h3 id="daos-kv-open"><a href="#daos-kv-open" class="headerlink" title="daos_kv_open"></a>daos_kv_open</h3><ol>
<li>输入：<ul>
<li>daos_handle_t</li>
<li>daos_obj_id_t</li>
<li>mode : int 类型</li>
<li>daos_handle_t</li>
<li>daos_event_t : event and event queue, maybe used for debug</li>
</ul>
</li>
<li>调用<code>rc = dc_task_create(dc_kv_open, NULL, ev, &amp;task)</code><ul>
<li>将参数包装成dc_kv_open结构体</li>
<li>生成一个kvOpen的task并调度</li>
</ul>
</li>
</ol>
<h3 id="dts-buf-render-buf-BUFLEN"><a href="#dts-buf-render-buf-BUFLEN" class="headerlink" title="dts_buf_render(buf, BUFLEN)"></a>dts_buf_render(buf, BUFLEN)</h3><ol>
<li>输入buf和len</li>
<li>利用随机生成的字符填满buf</li>
</ol>
<h3 id="daos-kev-put"><a href="#daos-kev-put" class="headerlink" title="daos_kev_put"></a>daos_kev_put</h3><ol>
<li>输入：<ul>
<li>daos_handle_t oh</li>
<li>daos_handle_t th</li>
<li>uint64_t flag</li>
<li>char * key</li>
<li>daos_size_t buf_size</li>
<li>void * buf</li>
<li>daos_event_t * ev</li>
</ul>
</li>
<li>调用rc = dc_task_create(dc_kv_put, NULL, ev, &amp;task);</li>
<li>将参数包装到task的args中</li>
<li>调用dc_task_schedule(task, true);<ol>
<li>task_is_valid(task)</li>
<li>ev = task_ptr2args(task)-&gt;ta_ev;</li>
<li>rc = daos_event_launch(ev);<ul>
<li>输入：daos_event *ev</li>
</ul>
</li>
<li>rc = tse_task_schedule(task, instant);</li>
</ol>
</li>
</ol>
<h2 id="kv-update"><a href="#kv-update" class="headerlink" title="kv_update"></a>kv_update</h2><ol>
<li><p>daos_io_0线程接收到io请求，crt_handle_rpc(void *arg)处理rpc</p>
</li>
<li><p>ds_obj_rw_handler(crt_rpc_t *rpc)处理rpc</p>
<ul>
<li><p>obj_ioc_begin(orw-&gt;orw_oid.id_pub, orw-&gt;orw_map_ver,</p>
<p>​               orw-&gt;orw_pool_uuid, orw-&gt;orw_co_hdl,</p>
<p>​               orw-&gt;orw_co_uuid, opc_get(rpc-&gt;cr_opc),</p>
<p>​               orw-&gt;orw_flags, &amp;ioc); // various check before access VOS</p>
</li>
</ul>
</li>
<li><p>​    rc = process_epoch(&amp;orw-&gt;orw_epoch, &amp;orw-&gt;orw_epoch_first,</p>
<p>​               &amp;orw-&gt;orw_flags); // 处理epoch相关</p>
</li>
</ol>
<h2 id="Object-Update"><a href="#Object-Update" class="headerlink" title="Object_Update"></a>Object_Update</h2><ol>
<li><p>callstack</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">libvos_srv.so!dkey_update(<span class="keyword">daos_key_t</span> * dkey, <span class="keyword">uint32_t</span> pm_ver, struct vos_io_context * ioc) (/home/kuhan/daos/src/vos/vos_io.c:<span class="number">1803</span>)</span><br><span class="line">libvos_srv.so!vos_update_end(<span class="keyword">daos_handle_t</span> ioh, <span class="keyword">uint32_t</span> pm_ver, <span class="keyword">daos_key_t</span> * dkey, <span class="keyword">int</span> err, <span class="keyword">daos_size_t</span> * size, struct dtx_handle * dth) (/home/kuhan/daos/src/vos/vos_io.c:<span class="number">2278</span>)</span><br><span class="line">libobj.so!obj_rw_complete(struct dtx_handle * dth, <span class="keyword">int</span> status, <span class="keyword">daos_handle_t</span> ioh, struct obj_io_context * ioc, <span class="keyword">crt_rpc_t</span> * rpc) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">128</span>)</span><br><span class="line">libobj.so!obj_local_rw_internal(struct dtx_handle * dth, <span class="keyword">uint64_t</span> * split_offs, struct dcs_iod_csums * split_csums, <span class="keyword">daos_iod_t</span> * split_iods, struct obj_io_context * ioc, <span class="keyword">crt_rpc_t</span> * rpc) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">1677</span>)</span><br><span class="line">libobj.so!obj_local_rw(<span class="keyword">crt_rpc_t</span> * rpc, struct obj_io_context * ioc, <span class="keyword">daos_iod_t</span> * split_iods, struct dcs_iod_csums * split_csums, <span class="keyword">uint64_t</span> * split_offs, struct dtx_handle * dth, <span class="built_in">_Bool</span> pin) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">1697</span>)</span><br><span class="line">libobj.so!obj_tgt_update(<span class="keyword">dtx_sub_comp_cb_t</span> comp_cb, <span class="keyword">void</span> * arg, struct dtx_leader_handle * dlh) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">2425</span>)</span><br><span class="line">libobj.so!obj_tgt_update(struct dtx_leader_handle * dlh, <span class="keyword">void</span> * arg, <span class="keyword">int</span> idx, <span class="keyword">dtx_sub_comp_cb_t</span> comp_cb) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">2356</span>)</span><br><span class="line">libobj.so!ds_obj_rw_handler(<span class="keyword">crt_rpc_t</span> * rpc) (/home/kuhan/daos/src/object/srv_obj.c:<span class="number">2664</span>)</span><br><span class="line">libcart.so<span class="number">.4</span>!crt_handle_rpc(<span class="keyword">void</span> * arg) (/home/kuhan/daos/src/cart/crt_rpc.c:<span class="number">1638</span>)</span><br><span class="line">libabt.so<span class="number">.1</span>!ABTD_ythread_func_wrapper (未知源:<span class="number">0</span>)</span><br><span class="line">libabt.so<span class="number">.1</span>!make_fcontext (未知源:<span class="number">0</span>)</span><br><span class="line">[Unknown/Just-In-Time compiled code] (未知源:<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="obj-local-rw-internal"><a href="#obj-local-rw-internal" class="headerlink" title="obj_local_rw_internal"></a>obj_local_rw_internal</h3><ol>
<li><p>​        rc = vos_update_begin(ioc-&gt;ioc_vos_coh, orw-&gt;orw_oid,</p>
<p>​                  orw-&gt;orw_epoch, cond_flags, dkey,</p>
<p>​                  orw-&gt;orw_nr, iods, iod_csums,</p>
<p>​                  ioc-&gt;ioc_coc-&gt;sc_props.dcp_dedup_size,</p>
<p>​                  &amp;ioh, dth);</p>
<ul>
<li><p>rc = vos_check_akeys(iod_nr, iods);</p>
</li>
<li><p>vos_ioc_create</p>
</li>
<li><p> rc = vos_space_hold(vos_cont2pool(ioc-&gt;ic_cont), flags, dkey, iod_nr,</p>
</li>
</ul>
<p>  ​                iods, iods_csums, &amp;ioc-&gt;ic_space_held[0]);</p>
<ul>
<li><p>rc = dkey_update_begin(ioc);</p>
<ul>
<li><p>循环rc = akey_update_begin(ioc);</p>
<ul>
<li><p>获取dcs_csum_info</p>
</li>
<li><p>获取daos_iod_t,1k</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iod</span><br><span class="line"><span class="number">0x7f9a07a4dee0</span></span><br><span class="line">iod_name</span><br><span class="line">iod_type:DAOS_IOD_ARRAY</span><br><span class="line">iod_size:<span class="number">1</span></span><br><span class="line">iod_flags:<span class="number">0</span></span><br><span class="line">iod_nr:<span class="number">1</span></span><br><span class="line">iod_recxs:<span class="number">0x7f9a07e9fbf0</span></span><br><span class="line">rx_idx:<span class="number">0</span></span><br><span class="line">rx_nr:<span class="number">1024</span></span><br></pre></td></tr></table></figure></li>
<li><p>for (i = 0; i &lt; iod-&gt;iod_nr; i++) //循环</p>
<ul>
<li><p>size = (iod-&gt;iod_type == DAOS_IOD_SINGLE) ? iod-&gt;iod_size :</p>
<p>​                iod-&gt;iod_recxs[i].rx_nr * iod-&gt;iod_size; //获取size，1k–1024</p>
</li>
<li><p>media = vos_media_select(vos_cont2pool(ioc-&gt;ic_cont),</p>
<p>​                     iod-&gt;iod_type, size); //决定往哪个media上写，0 –&gt; scm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A simple media selection policy embedded in VOS, which select media by</span></span><br><span class="line"><span class="comment"> * akey type and record size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint16_t</span></span></span><br><span class="line"><span class="function"><span class="title">vos_media_select</span><span class="params">(struct vos_pool *pool, <span class="keyword">daos_iod_type_t</span> type, <span class="keyword">daos_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;vp_vea_info == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> DAOS_MEDIA_SCM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (size &gt;= VOS_BLK_SZ) ? DAOS_MEDIA_NVME : DAOS_MEDIA_SCM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首先做特判</span></span><br><span class="line"><span class="comment">// 如果大于等于4k，写到NVME上，否则写到SCM</span></span><br></pre></td></tr></table></figure></li>
<li><p>iod-&gt;iod_type<br>为 DAOS_IOD_ARRAY类型：</p>
<ul>
<li><p>rc = vos_reserve_recx(ioc, media, size, recx_csum, csum_len);</p>
<ul>
<li><p>为    struct bio_iov  biov 分配内存</p>
</li>
<li><p>rc = reserve_space(ioc, media, size, &amp;off);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">oc</span><br><span class="line"><span class="number">0x7f9a0724ef00</span></span><br><span class="line">ic_ent_array_alloc</span><br><span class="line">ea_data</span><br><span class="line">ea_ents:<span class="number">0x0</span></span><br><span class="line">ea_ent_nr:<span class="number">0</span></span><br><span class="line">ea_size:<span class="number">0</span></span><br><span class="line">ea_max:<span class="number">0</span></span><br><span class="line">ea_inob:<span class="number">0</span></span><br><span class="line">ea_first_delete:<span class="number">0</span></span><br><span class="line">ea_delete_nr:<span class="number">0</span></span><br><span class="line">ea_embedded_ents</span><br><span class="line">ea_embedded</span><br><span class="line">ic_ent_array:<span class="number">0x0</span></span><br><span class="line">ic_bound:<span class="number">509171074455830528</span></span><br><span class="line">ic_epr</span><br><span class="line">ic_oid</span><br><span class="line">ic_cont:<span class="number">0x7f9a07e9eb60</span></span><br><span class="line">ic_iods:<span class="number">0x7f9a07a4dee0</span></span><br><span class="line">iod_csums:<span class="number">0x0</span></span><br><span class="line">ic_obj:<span class="number">0x0</span></span><br><span class="line">ic_biod:<span class="number">0x7f99c89c63b0</span></span><br><span class="line">ic_ts_set:<span class="number">0x7f99c89c6f90</span></span><br><span class="line">ic_biov_csums:<span class="number">0x7f99c87c76e0</span></span><br><span class="line">ic_biov_csums_at:<span class="number">0</span></span><br><span class="line">ic_biov_csums_nr:<span class="number">1</span></span><br><span class="line">ic_dkey_info</span><br><span class="line">ic_akey_info</span><br><span class="line">ic_sgl_at:<span class="number">0</span></span><br><span class="line">ic_iov_at:<span class="number">0</span></span><br><span class="line">ic_rsrvd_scm:<span class="number">0x7f9a07e86980</span></span><br><span class="line">ic_umoffs:<span class="number">0x7f9a07e9e6a0</span></span><br><span class="line">ic_umoffs_cnt:<span class="number">0</span></span><br><span class="line">ic_umoffs_at:<span class="number">0</span></span><br><span class="line">  ic_blk_exts</span><br><span class="line">next:<span class="number">0x7f9a0724fb38</span></span><br><span class="line">prev:<span class="number">0x7f9a0724fb38</span></span><br><span class="line">ic_space_held</span><br><span class="line">ic_iod_nr:<span class="number">1</span></span><br><span class="line">ic_dedup_th:<span class="number">4096</span></span><br><span class="line">ic_dedup_entries</span><br><span class="line">ic_dedup_bsgls:<span class="number">0x0</span></span><br><span class="line">ic_dedup_bufs:<span class="number">0x0</span></span><br><span class="line">ic_io_size:<span class="number">0</span></span><br><span class="line">ic_update:<span class="number">1</span></span><br><span class="line">ic_size_fetch:<span class="number">0</span></span><br><span class="line">ic_save_recx:<span class="number">0</span></span><br><span class="line">ic_dedup:<span class="number">0</span></span><br><span class="line">ic_dedup_verify:<span class="number">0</span></span><br><span class="line">ic_read_ts_only:<span class="number">0</span></span><br><span class="line">ic_check_existence:<span class="number">0</span></span><br><span class="line">ic_remove:<span class="number">0</span></span><br><span class="line">ic_skip_fetch:<span class="number">0</span></span><br><span class="line">ic_ec:<span class="number">0</span></span><br><span class="line">ic_shadows:<span class="number">0x0</span></span><br><span class="line">re_nr</span><br><span class="line">re_total</span><br><span class="line">re_snapshot</span><br><span class="line">re_ep_valid</span><br><span class="line">re_items</span><br><span class="line">ic_recx_lists:<span class="number">0x0</span></span><br><span class="line">re_nr</span><br><span class="line">re_total</span><br><span class="line">re_snapshot</span><br><span class="line">re_ep_valid</span><br><span class="line">re_items</span><br></pre></td></tr></table></figure>

<ul>
<li>在SCM上申请内存</li>
</ul>
</li>
<li><p>bio_addr_set(&amp;biov.bi_addr, media, off);//设置偏移量</p>
</li>
<li><p>bio_iov_set_len(&amp;biov, size); //设置长度</p>
</li>
<li><p>rc = iod_reserve(ioc, &amp;biov);</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>*ioh = vos_ioc2ioh(ioc); //获取cookie？</p>
</li>
</ul>
</li>
<li><p>biod = vos_ioh2desc(ioh); //获取io descriptor？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7f99c89c63b0</span></span><br><span class="line">bd_ctxt:<span class="number">0x7f99c89b0650</span></span><br><span class="line">bic_link</span><br><span class="line">bic_umem:<span class="number">0x7f99c860ab58</span></span><br><span class="line">bic_pmempool_uuid:<span class="number">12137328209446634291</span></span><br><span class="line">bic_blob:<span class="number">0x7f99c89b1530</span></span><br><span class="line">bic_xs_ctxt:<span class="number">0x7f9a04427370</span></span><br><span class="line">bic_inflight_dmas:<span class="number">0</span></span><br><span class="line">bic_io_unit:<span class="number">4096</span></span><br><span class="line">bic_pool_id</span><br><span class="line">bic_opening:<span class="number">0</span></span><br><span class="line">bic_closing:<span class="number">0</span></span><br><span class="line">bd_rsrvd</span><br><span class="line">brd_regions:<span class="number">0x0</span></span><br><span class="line">brd_rg_max:<span class="number">0</span></span><br><span class="line">brd_rg_cnt:<span class="number">0</span></span><br><span class="line">brd_dma_chks:<span class="number">0x0</span></span><br><span class="line">brd_chk_max:<span class="number">0</span></span><br><span class="line">brd_chk_cnt:<span class="number">0</span></span><br><span class="line">bd_dma_done:<span class="number">0x10</span></span><br><span class="line">bd_inflights:<span class="number">0</span></span><br><span class="line">bd_result:<span class="number">0</span></span><br><span class="line">bd_chk_type:<span class="number">0</span></span><br><span class="line">bd_type:<span class="number">0</span></span><br><span class="line">bd_buffer_prep:<span class="number">0</span></span><br><span class="line">bd_dma_issued:<span class="number">0</span></span><br><span class="line">bd_retry:<span class="number">0</span></span><br><span class="line">bd_rdma:<span class="number">0</span></span><br><span class="line">bd_bulk_hdls:<span class="number">0x0</span></span><br><span class="line">bd_bulk_max:<span class="number">0</span></span><br><span class="line">bd_bulk_cnt:<span class="number">0</span></span><br><span class="line">bd_sgl_cnt:<span class="number">1</span></span><br><span class="line">bd_sgls</span><br></pre></td></tr></table></figure></li>
<li><p>rc = bio_iod_prep(biod, BIO_CHK_TYPE_IO, rma ? rpc-&gt;cr_ctx : NULL,CRT_BULK_RW);</p>
<ul>
<li><p>rc = iterate_biov(biod, arg ? bulk_map_one : dma_map_one, arg);</p>
<ul>
<li><p>for循环：rc = cb_fn(biod, biov, data);  // 函数指针调用，此处写SCM</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">biod</span><br><span class="line"><span class="number">0x7f99c89c63b0</span></span><br><span class="line">bd_ctxt:<span class="number">0x7f99c89b0650</span></span><br><span class="line">bic_link</span><br><span class="line">bic_umem:<span class="number">0x7f99c860ab58</span></span><br><span class="line">bic_pmempool_uuid:<span class="number">12137328209446634291</span></span><br><span class="line">bic_blob:<span class="number">0x7f99c89b1530</span></span><br><span class="line">bic_xs_ctxt:<span class="number">0x7f9a04427370</span></span><br><span class="line">bic_inflight_dmas:<span class="number">0</span></span><br><span class="line">bic_io_unit:<span class="number">4096</span></span><br><span class="line">bic_pool_id</span><br><span class="line">bic_opening:<span class="number">0</span></span><br><span class="line">bic_closing:<span class="number">0</span></span><br><span class="line">bd_rsrvd</span><br><span class="line">bd_dma_done:<span class="number">0x10</span></span><br><span class="line">bd_inflights:<span class="number">0</span></span><br><span class="line">bd_result:<span class="number">0</span></span><br><span class="line">bd_chk_type:<span class="number">0</span></span><br><span class="line">bd_type:<span class="number">0</span></span><br><span class="line">bd_buffer_prep:<span class="number">0</span></span><br><span class="line">bd_dma_issued:<span class="number">0</span></span><br><span class="line">bd_retry:<span class="number">0</span></span><br><span class="line">bd_rdma:<span class="number">0</span></span><br><span class="line">bd_bulk_hdls:<span class="number">0x0</span></span><br><span class="line">bd_bulk_max:<span class="number">0</span></span><br><span class="line">bd_bulk_cnt:<span class="number">0</span></span><br><span class="line">bd_sgl_cnt:<span class="number">1</span></span><br><span class="line">bd_sgls</span><br><span class="line">--------------</span><br><span class="line">biov</span><br><span class="line"><span class="number">0x7f9a07e9eeb0</span></span><br><span class="line">bi_buf:<span class="number">0x0</span></span><br><span class="line">bi_data_len:<span class="number">1024</span></span><br><span class="line">bi_addr</span><br><span class="line">ba_off:<span class="number">4576720</span></span><br><span class="line">ba_type:<span class="number">0</span> <span class="string">&#x27;\000&#x27;</span></span><br><span class="line">ba_pad1:<span class="number">0</span> <span class="string">&#x27;\000&#x27;</span></span><br><span class="line">ba_flags:<span class="number">0</span></span><br><span class="line">ba_pad2:<span class="number">0</span></span><br><span class="line">bi_prefix_len:<span class="number">0</span></span><br><span class="line">bi_suffix_len:<span class="number">0</span></span><br><span class="line">--------------</span><br><span class="line">data</span><br><span class="line"><span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>函数指针调用dma_map_one(struct bio_desc *biod, struct bio_iov *biov, void *arg)</p>
<p>// /* Convert offset of @biov into memory pointer */</p>
<ul>
<li>direct_scm_access(biod, biov):<ul>
<li>bio_iov_set_raw_buf(biov,umem_off2ptr(umem, bio_iov2raw_off(biov)));</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>rc = bio_iod_copy(biod, orw-&gt;orw_sgls.ca_arrays, orw-&gt;orw_nr);</p>
<ul>
<li>将参数包装成bio_copy_args结构体</li>
<li>iterate_biov(biod, copy_one, &amp;arg);</li>
</ul>
</li>
<li><p>rc = vos_dedup_verify(ioh);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check if the dedup data is identical to the RDMA data in a temporal</span></span><br><span class="line"><span class="comment"> * allocated DRAM extent, if memcmp fails, allocate a new SCM extent and</span></span><br><span class="line"><span class="comment"> * update it&#x27;s address in VOS tree, otherwise, keep using the original</span></span><br><span class="line"><span class="comment"> * dedup data address in VOS tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
<li><p>rc = obj_verify_bio_csum(orw-&gt;orw_oid.id_pub, iods, iod_csums,biod, ioc-&gt;ioc_coc-&gt;sc_csummer,orw-&gt;orw_iod_array.oia_iod_nr); //verify CSUM</p>
</li>
<li><p>rc = obj_rw_complete(rpc, ioc, ioh, rc, dth); // the callstack is deep inside this function…</p>
<ul>
<li><p>rc = vos_update_end(ioh, ioc-&gt;ioc_map_ver,&amp;orwi-&gt;orw_dkey, status,&amp;ioc-&gt;ioc_io_size, dth);</p>
<ul>
<li><p>一些dtx commit逻辑？</p>
</li>
<li><p>err = dkey_update(ioc, pm_ver, dkey, dtx_is_valid_handle(dth) ? dth-&gt;dth_op_seq : VOS_SUB_OP_MAX); // update tree index</p>
<ul>
<li><p>rc = obj_tree_init(obj); // initialize tree for an object</p>
</li>
<li><p>rc = key_tree_prepare(obj, obj-&gt;obj_toh, VOS_BTR_DKEY, dkey,SUBTR_CREATE, DAOS_INTENT_UPDATE, &amp;krec, &amp;ak_toh,ioc-&gt;ic_ts_set);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the subtree roots embedded in the parent tree record.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * akey tree	: all akeys under the same dkey</span></span><br><span class="line"><span class="comment"> * recx tree	: all record extents under the same akey, this function will</span></span><br><span class="line"><span class="comment"> *		  load both btree and evtree root.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="comment">/* NB: In order to avoid complexities of passing parameters to the</span></span><br><span class="line"><span class="comment">	 * multi-nested tree, tree operations are not nested, instead:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * - In the case of fetch, we load the subtree root stored in the</span></span><br><span class="line"><span class="comment">	 *   parent tree leaf.</span></span><br><span class="line"><span class="comment">	 * - In the case of update/insert, we call dbtree_update() which may</span></span><br><span class="line"><span class="comment">	 *   create the root for the subtree, or just return it if it&#x27;s already</span></span><br><span class="line"><span class="comment">	 *   there.</span></span><br><span class="line"><span class="comment">	 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>rc = dbtree_fetch(toh, BTR_PROBE_EQ, intent, key,NULL, &amp;riov);</p>
</li>
<li><p>/* use BTR_PROBE_BYPASS to avoid probe again */</p>
<p>rc = dbtree_upsert(toh, BTR_PROBE_BYPASS, intent, key, &amp;riov);</p>
<ul>
<li><pre><code class="c">Update the value of the provided key, or insert it as a new key if
 * there is no match.
</code></pre>
</li>
<li><p>tcx = btr_hdl2tcx(toh); ///** find the tree context of the handle */</p>
</li>
<li><p>rc = btr_tx_begin(tcx); // begin transaction？</p>
</li>
<li><p>rc = btr_upsert(tcx, opc, intent, key, val);</p>
<ul>
<li>rc = btr_insert(tcx, key, val); // bypass策略，直接取前一次probe的结果，create a new record, insert it into tree leaf node.<ul>
<li>btr_hkey_gen(tcx, key, &amp;rec-&gt;rec_hkey[0]); //生成hkey</li>
<li>rc = btr_node_insert_rec(tcx, trace, rec);<ul>
<li>btr_node_insert_rec_only(tcx, trace, rec);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>btr_tx_end(tcx, rc);</p>
<ul>
<li>rc = umem_tx_commit(btr_umm(tcx));</li>
</ul>
</li>
</ul>
</li>
<li><p>vos_ilog_ts_ignore(vos_obj2umm(obj), &amp;krec-&gt;kr_ilog);</p>
</li>
<li><p>vos_ilog_ts_mark(ts_set, &amp;krec-&gt;kr_ilog);</p>
</li>
</ul>
</li>
<li><p>rc = vos_ilog_update(ioc-&gt;ic_cont, &amp;krec-&gt;kr_ilog, &amp;ioc-&gt;ic_epr,</p>
<p>​                 ioc-&gt;ic_bound, &amp;obj-&gt;obj_ilog_info,</p>
<p>​                 &amp;ioc-&gt;ic_dkey_info, update_cond, ioc-&gt;ic_ts_set); // update dkey log ？</p>
</li>
<li><p>for循环：rc = akey_update(ioc, pm_ver, ak_toh, minor_epc);</p>
<ul>
<li><p>​    rc = key_tree_prepare(obj, ak_toh, VOS_BTR_AKEY,</p>
<p>​                  &amp;iod-&gt;iod_name, flags, DAOS_INTENT_UPDATE,</p>
<p>​                  &amp;krec, &amp;toh, ioc-&gt;ic_ts_set);</p>
</li>
<li><p>….</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>vos_ts_set_check_conflict(ioc-&gt;ic_ts_set, ioc-&gt;ic_epr.epr_hi) // Now that we are past the existence checks, ensure there isn’t a read conflict</p>
</li>
<li><p>err = vos_tx_end(ioc-&gt;ic_cont, dth, &amp;ioc-&gt;ic_rsrvd_scm,&amp;ioc-&gt;ic_blk_exts, tx_started, err); // dtx operations，on scm</p>
</li>
<li><p>vos_ts_set_upgrade(ioc-&gt;ic_ts_set);</p>
</li>
<li><p>vos_space_unhold(vos_cont2pool(ioc-&gt;ic_cont), &amp;ioc-&gt;ic_space_held[0]);</p>
</li>
<li><p>vos_ioc_destroy(ioc, err != 0); // memory free</p>
<ul>
<li>bio_iod_free(ioc-&gt;ic_biod);</li>
<li>vos_obj_release(vos_obj_cache_current(), ioc-&gt;ic_obj, evict);</li>
<li>vos_ioc_reserve_fini(ioc);</li>
<li>vos_ilog_fetch_finish(&amp;ioc-&gt;ic_dkey_info);</li>
<li> vos_ilog_fetch_finish(&amp;ioc-&gt;ic_akey_info);</li>
<li> vos_cont_decref(ioc-&gt;ic_cont);</li>
<li>vos_ts_set_free(ioc-&gt;ic_ts_set);</li>
<li>D_FREE(ioc);</li>
</ul>
</li>
<li><p>vos_dth_set(NULL);</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="update流程"><a href="#update流程" class="headerlink" title="update流程"></a>update流程</h2><p>api调用–&gt;task generate –&gt; client rpc call –&gt; server accept –&gt; handle rpc –&gt; decide type –&gt; allocate memory –&gt; write data –&gt; update index –&gt; free memory</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/Programming-language-GO-RUST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/Programming-language-GO-RUST/" class="post-title-link" itemprop="url">Programming language GO & RUST</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-04 10:41:13 / Modified: 10:41:30" itemprop="dateCreated datePublished" datetime="2022-01-04T10:41:13+08:00">2022-01-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><ol>
<li><p>常量</p>
<ol>
<li>定义格式 const Name [Type] = Value</li>
</ol>
</li>
<li><p>变量</p>
<ol>
<li>定义格式 var Name [Type]</li>
<li>系统自动赋予初值</li>
<li>全局变量希望能被外部包所使用，则需要将变量首字母大写</li>
<li>函数体内定义的变量为局部变量，否则为全局变量</li>
<li>可以省去Type，变量在被赋值时编辑器会在编译阶段做类型推断</li>
<li>当你在函数体内声明局部变量时，应使用简短声明语法 <code>:=</code></li>
<li>值类型和引用类型<ol>
<li>值类型用等号赋值的时候，实际上是在内存中做了值拷贝<ol>
<li>int float bool string 数组 struct</li>
<li>存储在栈内</li>
</ol>
</li>
<li>引用类型变量存储的是值所在的内存地址<ol>
<li>指针 slices maps channel</li>
<li>存储在堆中</li>
<li>局部变量的简短化创建形式a := 50</li>
<li>局部变量不可以声明了但却不使用，全局变量可以</li>
</ol>
</li>
<li>init函数<ol>
<li>变量可以在init函数中被初始化，init函数在每个包完成初始化后自动执行，优先级比main高</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>基本类型和运算符</p>
<ol>
<li>bool 格式化输出时，可以用%t来表示要输出的类型为bool</li>
<li>数值类型：<ol>
<li>int和uint根据操作系统的位数，决定数值的长度（4位或者8位）</li>
<li>uintptr长度被设定为足够放一个指针即可</li>
<li>整数：<ol>
<li>int8（-128 -&gt; 127）</li>
<li>int16（-32768 -&gt; 32767）</li>
<li>int32（-2,147,483,648 -&gt; 2,147,483,647）</li>
<li>int64（-9,223,372,036,854,775,808 -&gt; 9,223,372,036,854,775,807）</li>
</ol>
</li>
<li>无符号整数：<ol>
<li>uint8（0 -&gt; 255）</li>
<li>uint16（0 -&gt; 65,535）</li>
<li>uint32（0 -&gt; 4,294,967,295）</li>
<li>uint64（0 -&gt; 18,446,744,073,709,551,615）</li>
</ol>
</li>
<li>浮点数：<ol>
<li>float32（+- 1e-45 -&gt; +- 3.4 * 1e38）：小数点后7位</li>
<li>float64（+- 5 <em>1e-324 -&gt; 107</em> 1e308）：小数点后15位</li>
</ol>
</li>
<li>复数：<ol>
<li>complex64(32位实数和虚数)</li>
<li>Complex128(64位实数和虚数)</li>
</ol>
</li>
<li>随机数：<ol>
<li>rand包</li>
</ol>
</li>
<li>类型别名：<ol>
<li>type 别名 类型</li>
</ol>
</li>
<li>字符类型<ol>
<li>char</li>
<li>实际存储了整型</li>
</ol>
</li>
</ol>
</li>
<li>字符串<ol>
<li>字符串是字节的定长数组</li>
<li>解释字符串，用双引号括起来</li>
<li>非解释字符串，反引号括起来</li>
<li>字符串的二元运算符比较，逐个字节对比</li>
<li>获取字符串中某个字节的地址是非法的$str[i]</li>
<li>字符串使用+拼接</li>
</ol>
</li>
<li>strings和strconv包（String 库函数的使用）</li>
<li>指针：<ol>
<li>一个指针变量可以指向任何一个值得内存地址</li>
</ol>
</li>
</ol>
</li>
<li><p>控制结构（省去了condition两侧的括号，使得代码更加整洁,执行语句中的括号在任何情况下都不能被省略）</p>
<ol>
<li>if-else</li>
<li>if-else if-else</li>
<li>测试多返回值函数的错误<ol>
<li>方法可以返回多个返回值，第二个返回值可以是错误的详细信息，如果第二个返回值不为Nil，则代表发生了错误。</li>
</ol>
</li>
<li>switch case：<ol>
<li>不需要写break</li>
<li>如果希望匹配到之后还继续执行后面的分支，用“fallthrough”关键字</li>
<li>switch 语句的第二种形式是不提供任何被判断的值（实际上默认为判断是否为 true），然后在每个 case 分支中进行测试不同的条件。当任一分支的测试结果为 true 时，该分支的代码会被执行。这看起来非常像链式的 if-else 语句，但是在测试条件非常多的情况下，提供了可读性更好的书写方式。</li>
<li>switch的第三种形式是condition中可以对两个变量进行计算赋值。随后在case分支中根据变量的值进行具体的行为</li>
</ol>
</li>
<li>循环：for结构<ol>
<li>基本形式：for 初始化语句;条件语句;修饰语句{}</li>
<li>第二种形式，类似于while循环。没有初始化语句和index更新语句</li>
<li>第三种形式，无限循环。for {}</li>
<li>for-range结构：<code>for ix, val := range coll &#123; &#125;</code></li>
</ol>
</li>
<li>Break 和 continue</li>
<li>label和goto（不推荐使用，没看）</li>
</ol>
</li>
<li><p>函数</p>
<ol>
<li><p>分类：普通的带有名字的函数、匿名函数、方法</p>
</li>
<li><p>go里面函数重载是不允许的，没有泛型，为了效率</p>
</li>
<li><p>函数的一般定义：<code>func f(name1 type1,name 2type2) 返回值类型</code>,参数可以没有参数名。</p>
</li>
<li><p>函数都是按照值传递的</p>
</li>
<li><p>带命名的返回值，只需要在函数尾部直接return</p>
</li>
<li><p>不带命名的返回值，需要用（）装起来写在return后面</p>
</li>
<li><p>空白符<code>_</code>匹配一些不需要的值，然后丢掉</p>
</li>
<li><p>通过传递指针来改变函数外部变量的值</p>
</li>
<li><p>变长参数函数</p>
<ol>
<li><p>形式：<code>func myFunc(a,b,arg ...int)&#123;&#125;</code></p>
</li>
<li><p>如果一个变长参数的类型没有被指定，则可以使用默认的空接口 <code>interface&#123;&#125;</code>，这样就可以接受任何类型的参数</p>
<p>`func typecheck(..,..,values … interface{}) {</p>
<pre><code>for _, value := range values &#123;
    switch v := value.(type) &#123;
        case int: …
        case float: …
        case string: …
        case bool: …
        default: …
    &#125;
&#125;
</code></pre>
<p>}`</p>
</li>
</ol>
</li>
<li><p>defer和追踪</p>
<ol>
<li>defer作用：类似于finally，用于一些资源的释放</li>
<li>使用defer来记录函数的参数和返回值</li>
</ol>
</li>
<li><p>将函数作为参数</p>
<ol>
<li><code>func IndexFunc(s string, f func(c int) bool) int</code></li>
</ol>
</li>
<li><p>闭包</p>
<ol>
<li>匿名函数赋值给变量：<code>fplus := func(x, y int) int &#123; return x + y &#125;</code></li>
<li>直接调用匿名函数：<code>func(x, y int) int &#123; return x + y &#125; (3, 4)</code></li>
<li>匿名函数的调用，在匿名函数后加一对（）表示对其的调用</li>
</ol>
</li>
<li><p>应用闭包：将函数作为返回值</p>
<ol>
<li><p>闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。</p>
</li>
<li><p>在闭包中使用到的变量可以是在闭包函数体内声明的，也可以是在外部函数声明的：</p>
<p>`var g int<br>go func(i int) {</p>
<pre><code>s := 0
for j := 0; j &lt; i; j++ &#123; s += j &#125;
g = s
</code></pre>
<p>}(1000) // Passes argument 1000 to the function literal.`</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数组与切片</p>
<ol>
<li><p>数组</p>
<ol>
<li>声明语句：<code>var identifier [len]type</code></li>
<li>使用for循环遍历</li>
</ol>
<p>`for i:=0; i &lt; len(arr1); i++｛</p>
<pre><code>arr1[i] = ...
</code></pre>
<p>}`</p>
<ol start="3">
<li>使用for-range遍历</li>
</ol>
<p>`for i:=0; i &lt; len(arr1); i++｛</p>
<pre><code>arr1[i] = ...
</code></pre>
<p>}`</p>
<ol start="4">
<li>Go 语言中的数组是一种 <strong>值类型</strong>（不像 C/C++ 中是指向首元素的指针），所以可以通过 <code>new()</code> 来创建： <code>var arr1 = new([5]int)</code>。arr1的类型是*[5]int，把arr1赋值给另一个时，需要做一次数组内存的拷贝。</li>
<li>讲数组作为函数参数时，会做一次数组的拷贝，如果需要修改传入数组的值，需要用引用传递的方式</li>
<li>数组可以在声明时使用{}来初始化</li>
</ol>
</li>
<li><p>切片</p>
<ol>
<li><p>定义和相关特性</p>
<ol>
<li>切片（slice）是对数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以切片是一个引用类型</li>
<li>和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个 <strong>长度可变的数组</strong>。</li>
<li>多个切片如果表示同一个数组的片段，它们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。</li>
</ol>
</li>
<li><p>优点：</p>
<ol>
<li>因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go 代码中 切片比数组更常用。</li>
</ol>
</li>
<li><p>声明：<code>var identifier []type</code>（不需要说明长度）。</p>
</li>
<li><p>初始化：</p>
<ol>
<li><code>var slice1 []type = arr1[start:end]</code>头闭尾开区间</li>
<li>类似数组的初始化：<code>var x = []int&#123;2, 3, 5, 7, 11&#125;</code>。这样就创建了一个长度为 5 的数组并且创建了一个相关切片。</li>
</ol>
</li>
<li><p>长度：存储的值的个数</p>
</li>
<li><p>容量：<code>cap()</code> 可以测量切片最长可以达到多少：它等于切片从第一个元素开始，到相关数组末尾的元素个数</p>
</li>
<li><p>对于每个切片，以下状态总是成立：</p>
<p><code>s == s[:i] + s[i:] // i是一个整数且: 0 &lt;= i &lt;= len(s) len(s) &lt;= cap(s)</code></p>
</li>
<li><p>切片的存储类似结构体：</p>
<ol>
<li>指向相关数组的指针</li>
<li>长度</li>
<li>容量</li>
</ol>
</li>
<li><p>将切片传递给函数：</p>
<p>`func sum(a []int) int {</p>
<pre><code>s := 0
for i := 0; i &lt; len(a); i++ &#123;
    s += a[i]
&#125;
return s
</code></pre>
<p>}</p>
<p>func main() {</p>
<pre><code>var arr = [5]int&#123;0, 1, 2, 3, 4&#125;
sum(arr[:])
</code></pre>
<p>}`</p>
</li>
<li><p>使用make创造一个切片：</p>
<ol>
<li><code>var slice1 []type = make([]type, len)</code>。</li>
<li>简写为：<code>slice1 := make([]type, len)</code></li>
<li>make 的使用方式是：<code>func make([]T, len, cap)</code>，其中 cap 是可选参数。</li>
<li>以下两种创建切片的方法等效：<ol>
<li><code>make([]int, 50, 100)</code></li>
<li><code>new([100]int)[0:50]</code></li>
</ol>
</li>
</ol>
</li>
<li><p>make和new的区别</p>
<ol>
<li>看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。</li>
<li>new (T) 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型为 * T 的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体（参见第 10 章）；它相当于 &amp;T{}。</li>
<li>make(T) 返回一个类型为 T 的初始值，它只适用于 3 种内建的引用类型：切片、map 和 channel</li>
<li>换言之，new 函数分配内存，make 函数初始化</li>
</ol>
</li>
<li><p>bytes包Buffer（类似于java里面的StringBuilder）</p>
<ol>
<li>申明方式：<code>var buffer bytes.Buffer</code></li>
<li>获取指针：<code>var r *bytes.Buffer = new(bytes.Buffer)</code></li>
<li>或者通过函数：<code>func NewBuffer(buf []byte) *Buffer</code></li>
</ol>
</li>
<li><p>切片的for-range</p>
<ol>
<li><p>单维切片：</p>
<p>`for ix, value := range slice1 {</p>
<pre><code>...
</code></pre>
<p>}`</p>
</li>
<li><p>多维切片：</p>
<p>`for row := range screen {</p>
<pre><code>for column := range screen[row] &#123;
    screen[row][column] = 1
&#125;
</code></pre>
<p>}`</p>
</li>
</ol>
</li>
<li><p>切片重组（扩容）</p>
<ol>
<li>扩展一位：<code>sl = sl[0:len(sl)+1]</code></li>
</ol>
</li>
<li><p>切片的复制与增加</p>
<ol>
<li><p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原切片的内容都拷贝过来。</p>
</li>
<li><p>通过<code>func append(s[]T, x ...T) []T</code>在切片中追加内容</p>
<ol>
<li>例子<code>sl3 := []int&#123;1, 2, 3&#125;    sl3 = append(sl3, 4, 5, 6)</code></li>
</ol>
</li>
<li><p>通过拷贝讲切片复制到新的切片中<code>func copy(dst, src []T) int</code>,返回拷贝的元素的个数</p>
<ol>
<li><p>例子：<code>sl_from := []int&#123;1, 2, 3&#125;  </code></p>
<p>​            <code> sl_to := make([]int, 10)   </code>  </p>
<p>​            <code>n := copy(sl_to, sl_from)</code></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Map</p>
<ol>
<li><p>声明：<code>var map1 map[keytype]valuetype</code></p>
</li>
<li><p>赋值：<code>map1[key1] = val1</code></p>
</li>
<li><p>取值：<code>v := map1[key1]</code></p>
</li>
<li><p>获取长度:<code>len(map1)</code></p>
</li>
<li><p>初始化：<code>&#123;key1:val1, key2:val2&#125;</code></p>
</li>
<li><p>make初始化：<code>map1 := make(map[keytype]valuetype)</code> 相当于``mapCreated := map[string]float32{}`</p>
</li>
<li><p>切片作为map的值：</p>
<p><code>mp1 := make(map[int][]int)  mp2 := make(map[int]*[]int)</code></p>
</li>
<li><p>检验key是否存在：</p>
<p>`if _, ok := map1[key1]; ok {</p>
<pre><code>// ...
</code></pre>
<p>}`</p>
</li>
<li><p>删除kv： <code>delete(map1, key1)</code></p>
</li>
<li><p>for-range遍历：</p>
<ol>
<li><p>kv：</p>
<p>`for key, value := range map1 {</p>
<pre><code>...
</code></pre>
<p>}`</p>
</li>
<li><p>只关心value</p>
<p>`for _, value := range map1 {</p>
<pre><code>...
</code></pre>
<p>}`</p>
</li>
<li><p>只关心key</p>
<p>`for key := range map1 {</p>
<pre><code>fmt.Printf(&quot;key is: %d\n&quot;, key)
</code></pre>
<p>}`</p>
</li>
</ol>
</li>
<li><p>切片：</p>
<ol>
<li><p>两次make，第一次分配切片，第二次分配切片中每个map元素</p>
<p>`items := make([]map[int]int, 5)<br>for i:= range items {</p>
<pre><code>items[i] = make(map[int]int, 1)
items[i][1] = 2
</code></pre>
<p>}`</p>
</li>
</ol>
</li>
<li><p>map排序</p>
<ol>
<li>拷贝出key，对key排序，然后顺序遍历key取出value（会不会效率太低了？）</li>
</ol>
</li>
<li><p>将kv对调：</p>
<ol>
<li>拷贝一个新的大小相同的map，遍历原始map，复制数据到新的map</li>
</ol>
</li>
</ol>
</li>
<li><p>包</p>
<ol>
<li>标准库</li>
<li>regexp包</li>
<li>sync包</li>
<li>紧密计算big包</li>
<li>自定义包和可见性：<ol>
<li>Import with . :import . “./pack1”，当使用. 来做为包的别名时，可以不通过包名来使用其中的项目。例如：test := ReturnStr()。在当前的命名空间导入 pack1 包，一般是为了具有更好的测试效果。</li>
<li>Import with _ :import _ “./pack1”，pack1 包只导入其副作用，也就是说，只执行它的 init 函数并初始化其中的全局变量。</li>
<li>导入外部安装包：先通过go install安装</li>
</ol>
</li>
</ol>
</li>
<li><p>结构体和方法（struct &amp; method）</p>
<ol>
<li><p>结构体：</p>
<ol>
<li><p>定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> identifier <span class="keyword">struct</span> &#123;</span><br><span class="line">    field1 type1</span><br><span class="line">    field2 type2</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用new</p>
<p><code> t := new(T)</code></p>
</li>
<li><p>使用声明：</p>
<p><code>var t T</code>:分配内存并零值化内存</p>
</li>
<li><p>使用<code>.</code>选择器来访问结构体的属性，无论变量是结构体还是结构体类型的指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span> &#123; i <span class="keyword">int</span> &#125;</span><br><span class="line"><span class="keyword">var</span> v myStruct    <span class="comment">// v是结构体类型变量</span></span><br><span class="line"><span class="keyword">var</span> p *myStruct   <span class="comment">// p是指向一个结构体类型变量的指针</span></span><br><span class="line">v.i</span><br><span class="line">p.i</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>&#123;&#125;</code>初始化一个结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ms := &amp;struct1&#123;<span class="number">10</span>, <span class="number">15.5</span>, <span class="string">&quot;Chris&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 此时ms的类型是 *struct1</span></span><br></pre></td></tr></table></figure>

<p>表达式 <code>new(Type)</code> 和 <code>&amp;Type&#123;&#125;</code> 是等价的。</p>
<p>或者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ms struct1</span><br><span class="line">ms = struct1&#123;<span class="number">10</span>, <span class="number">15.5</span>, <span class="string">&quot;Chris&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>或者制定字段key来初始化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intr := Interval&#123;<span class="number">0</span>, <span class="number">3</span>&#125;            (A)</span><br><span class="line">intr := Interval&#123;end:<span class="number">5</span>, start:<span class="number">1</span>&#125;  (B)</span><br><span class="line">intr := Interval&#123;end:<span class="number">5</span>&#125;           (C)</span><br></pre></td></tr></table></figure></li>
<li><p>结构体的内存布局：结构体和它所包含的数据在内存中是以连续快的形式存在的。</p>
</li>
<li><p>递归结构体：可以用来定义链表的节点或者二叉树的节点</p>
</li>
<li><p>make不能用于struct</p>
</li>
<li><p>结构体可以带Tag，通过反射获取</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TagType <span class="keyword">struct</span> &#123; <span class="comment">// tags</span></span><br><span class="line">    field1 <span class="keyword">bool</span>   <span class="string">&quot;An important answer&quot;</span></span><br><span class="line">    field2 <span class="keyword">string</span> <span class="string">&quot;The name of the thing&quot;</span></span><br><span class="line">    field3 <span class="keyword">int</span>    <span class="string">&quot;How much there are&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tt := TagType&#123;<span class="literal">true</span>, <span class="string">&quot;Barak Obama&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        refTag(tt, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">refTag</span><span class="params">(tt TagType, ix <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ttType := reflect.TypeOf(tt)</span><br><span class="line">    ixField := ttType.Field(ix)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, ixField.Tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>匿名字段和内嵌结构体</p>
<ol>
<li>匿名字段：通过<code>结构体名字.字段类型</code>来访问匿名字段，没个结构体针对每一种数据类型只能有一个匿名字段</li>
<li>内嵌结构体:结构体可以通过<code>结构体名字.内嵌结构体字段</code>来访问内嵌匿名结构体的字段，类似于软件工程领域的组合设计模式</li>
<li>命名冲突：外层结构体的相同命名字段会覆盖内层结构体的相同命名字段，访问外层结构体的相同命名字段<code>A.b</code>，访问内层结构体的相同命名字段<code>A.B.b</code></li>
</ol>
</li>
</ol>
</li>
<li><p>方法：</p>
<ol>
<li><p>在 Go 语言中，结构体就像是类的一种简化形式，那么面向对象程序员可能会问：类的方法在哪里呢？在 Go 中有一个概念，它和方法有着同样的名字，并且大体上意思相同：Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。一个类型加上它的方法等价于面向对象中的一个类。一个重要的区别是：在 Go 中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的。</p>
</li>
<li><p>类型 T（或 *T）上的所有方法的集合叫做类型 T（或 *T）的方法集。</p>
<p>因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法。但是如果基于接收者类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收者类型上存在，比如在同一个包里这么做是允许的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *denseMatrix)</span> <span class="title">Add</span><span class="params">(b Matrix)</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *sparseMatrix)</span> <span class="title">Add</span><span class="params">(b Matrix)</span> <span class="title">Matrix</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>定义方法的格式</p>
<p><code>func (recv receiver_type) methodName(parameter_list) (return_value_list) &#123; ... &#125;</code></p>
</li>
<li><p>方法的调用方式：</p>
<p><code>recv.methodName()</code>,recv类似于面向对象语言中的this或者self</p>
</li>
<li><p>一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TwoInts <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    two1 := <span class="built_in">new</span>(TwoInts)</span><br><span class="line">    two1.a = <span class="number">12</span></span><br><span class="line">    two1.b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;The sum is: %d\n&quot;</span>, two1.AddThem())</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Add them to the param: %d\n&quot;</span>, two1.AddToParam(<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">    two2 := TwoInts&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;The sum is: %d\n&quot;</span>, two2.AddThem())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tn *TwoInts)</span> <span class="title">AddThem</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tn.a + tn.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tn *TwoInts)</span> <span class="title">AddToParam</span><span class="params">(param <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tn.a + tn.b + param</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数和方法的区别：</p>
<ol>
<li><p>函数将变量作为参数：<strong>Function1(recv)</strong></p>
<p>方法在变量上被调用：<strong>recv.Method1()</strong></p>
</li>
<li><p><strong>方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。</strong></p>
</li>
</ol>
</li>
<li><p>指针作为接受者：</p>
<ol>
<li>传入指针或者值都是合法的，go会自动解引用</li>
<li>指针方法和值方法都可以在指针或者非指针上被调用</li>
</ol>
</li>
<li><p>获取或者设置对象的值使用getter和setter</p>
</li>
<li><p>多重继承可以通过一个类型内嵌多个匿名类型来实现，匿名类型的方法会被提升为此父类型的方法</p>
</li>
<li><p>总结：</p>
<ol>
<li>在Go中，类型就是类</li>
<li>Go拥有类似面向对象语言的嘞继承的概念以实现代码复用和多态</li>
<li>go中代码复用通过组合和委托实现，多态用接口来实现。</li>
<li>类型可以覆写内嵌匿名类型的方法</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>接口与反射</p>
<ol>
<li><p>接口</p>
<ol>
<li><p>定义：接口提供了一种方式来说明对象的行为：如果谁能搞定这件事，它就可以用在这儿。</p>
</li>
<li><p>接口定义了一组方法，但是这些方法不包含实现，接口内也不能拥有变量</p>
</li>
<li><p>接口定义语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Namer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Method1(param_list) return_type</span><br><span class="line">    Method2(param_list) return_type</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。</p>
<p>实现某个接口的类型（除了实现接口方法外）可以有其他的方法。</p>
<p>一个类型可以实现多个接口。</p>
<p>接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。</p>
</li>
<li><p>例子（go中的多态？）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">    side <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sq1 := <span class="built_in">new</span>(Square)</span><br><span class="line">    sq1.side = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> areaIntf Shaper</span><br><span class="line">    areaIntf = sq1</span><br><span class="line">    <span class="comment">// shorter,without separate declaration:</span></span><br><span class="line">    <span class="comment">// areaIntf := Shaper(sq1)</span></span><br><span class="line">    <span class="comment">// or even:</span></span><br><span class="line">    <span class="comment">// areaIntf := sq1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;The square has area: %f\n&quot;</span>, areaIntf.Area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接口嵌套接口</p>
<ol>
<li><p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b Buffer) <span class="keyword">bool</span></span><br><span class="line">    Write(b Buffer) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>类型断言：如何监测和转换接口变量的类型？</p>
<ol>
<li><p>定义：一个接口类型的变量varI中可以包含任何类型的值，必须有一种方式来检测它的动态类型，即运行时在变量中存储的值的实际类型。在执行过程中动态类型可能会有所不同，但是它总是可以分配给接口变量本身的类型。通常我们可以使用类型断言来测试某个时刻varI是否包含类型T的值：</p>
<p><code>v := varI.(T)</code></p>
<p>varI必须是一个接口类型变量。类型断言可能是无效的，虽然编译器会尽力检查转换是否有效，但是它不可能预见所有的可能性。如果转换在程序运行时失败会导致错误发生。更安全的方式是使用以下形式来进行类型断言：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := varI.(T); ok &#123;  <span class="comment">// checked type assertion</span></span><br><span class="line">    Process(v)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// varI is not of type T</span></span><br></pre></td></tr></table></figure>

<p>如果转换合法，<code>v</code> 是 <code>varI</code> 转换到类型 <code>T</code> 的值，<code>ok</code> 会是 <code>true</code>；否则 <code>v</code> 是类型 <code>T</code> 的零值，<code>ok</code> 是 <code>false</code>，也没有运行时错误发生。</p>
<p>例子：(暂时还不能明白这个的用处2021/12/2)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">    side <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> areaIntf Shaper</span><br><span class="line">    sq1 := <span class="built_in">new</span>(Square)</span><br><span class="line">    sq1.side = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    areaIntf = sq1</span><br><span class="line">    <span class="comment">// Is Square the type of areaIntf?</span></span><br><span class="line">    <span class="keyword">if</span> t, ok := areaIntf.(*Square); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;The type of areaIntf is: %T\n&quot;</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> u, ok := areaIntf.(*Circle); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;The type of areaIntf is: %T\n&quot;</span>, u)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;areaIntf does not contain a variable of type Circle&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *Circle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ci.radius * ci.radius * math.Pi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>类型判断：type-switch</p>
<ol>
<li><p>接口变量的类型也可以使用type-switch结构来判断</p>
</li>
<li><p>接口类型变量可以代表任何类型，所以需要有类型判断</p>
</li>
<li><p>例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">classifier</span><span class="params">(items ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> items &#123;</span><br><span class="line">        <span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is a bool\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is a float64\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">int64</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is a int\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is a nil\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is a string\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Param #%d is unknown\n&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以这样调用此方法：classifier(13, -14.3, “BELGIUM”, complex(1, 2), nil, false) 。</p>
<p>在处理来自于外部的、类型未知的数据时，比如解析诸如 JSON 或 XML 编码的数据，类型测试和转换会非常有用。</p>
</li>
</ol>
</li>
<li><p>测试一个值是否实现了某个接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sv, ok := v.(Stringer); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;v implements String(): %s\n&quot;</span>, sv.String()) <span class="comment">// note: sv, not v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质。</p>
</li>
<li><p>使用方法集与接口（这节有点晦涩）</p>
<ol>
<li><p>总结</p>
<p>在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 P 直接可以辨识的：</p>
<ol>
<li>指针方法可以通过指针调用</li>
<li>值方法可以通过值调用</li>
<li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li>
<li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li>
</ol>
</li>
<li><p>Go 语言规范定义了接口方法集的调用规则：</p>
<ol>
<li>类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集</li>
<li>类型 T 的可调用方法集包含接受者为 T 的所有方法</li>
<li>类型 T 的可调用方法集不包含接受者为 *T 的方法</li>
</ol>
</li>
</ol>
</li>
<li><p>空接口</p>
<ol>
<li><p>概念：不包含任何方法，它对实现不做任何要求（类似于Java中的Object对象）</p>
</li>
<li><p>可以给一个空接口类型的变量<code>var val interface &#123;&#125;</code>赋值任何类型的值</p>
</li>
<li><p>复制数据切片到空接口切片是不允许的，因为内存布局不一致，需要用for-range逐个复制</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSlice []myType = FuncReturnSlice()</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(dataSlice))</span><br><span class="line"><span class="keyword">for</span> i, d := <span class="keyword">range</span> dataSlice &#123;</span><br><span class="line">    interfaceSlice[i] = d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>一个接口的值可以赋值给另一个接口变量，只要底层类型实现了必要的方法</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>反射</p>
<ol>
<li><p>概念：反射是用程序检查气所拥有的的结构，尤其是类型的一种能力；这是元编程的一种形式，反射可以在运行时检查类型和变量，例如大小方法和动态的调用这些方法。</p>
</li>
<li><p>Go中反射包Type用来表示一个Go类型，反射包Value为Go值提供了发射接口</p>
</li>
<li><p>两个函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>通过反射修改或者设置值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    <span class="comment">// setting a value:</span></span><br><span class="line">    <span class="comment">// v.SetFloat(3.1415) // Error: will panic: reflect.Value.SetFloat using unaddressable value</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br><span class="line">    v = reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;type of v:&quot;</span>, v.Type())</span><br><span class="line">    fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br><span class="line">    v = v.Elem()</span><br><span class="line">    fmt.Println(<span class="string">&quot;The Elem of v is: &quot;</span>, v)</span><br><span class="line">    fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br><span class="line">    v.SetFloat(<span class="number">3.1415</span>) <span class="comment">// this works!</span></span><br><span class="line">    fmt.Println(v.Interface())</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">settability of v: <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> of v: *<span class="keyword">float64</span></span><br><span class="line">settability of v: <span class="literal">false</span></span><br><span class="line">The Elem of v is:  &lt;<span class="keyword">float64</span> Value&gt;</span><br><span class="line">settability of v: <span class="literal">true</span></span><br><span class="line"><span class="number">3.1415</span></span><br><span class="line">&lt;<span class="keyword">float64</span> Value&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>反射结构体：</p>
<ol>
<li>``NumField()<code> </code>方法返回结构体内的字段数量</li>
<li>通过for循环用索引取得每个字段的值<code>Field(i)</code></li>
<li>用签名在结构体上的方法，例如，使用索引 n 来调用：<code>Method(n).Call(nil)</code></li>
</ol>
</li>
<li><p>接口与动态类型：</p>
<ol>
<li><p>Go 中的接口跟 Java/C# 类似：都是必须提供一个指定方法集的实现。但是更加灵活通用：任何提供了接口方法实现代码的类型都隐式地实现了该接口，而不用显式地声明。</p>
<p>和其它语言相比，Go 是唯一结合了接口值，静态类型检查（是否该类型实现了某个接口），运行时动态转换的语言，并且不需要显式地声明类型是否满足某个接口。该特性允许我们在不改变已有的代码的情况下定义和使用新接口。</p>
<p>接收一个（或多个）接口类型作为参数的函数，其实参可以是任何实现了该接口的类型。 实现了某个接口的类型可以被传给任何以此接口为参数的函数 。</p>
</li>
<li><p>接口的继承：</p>
<ol>
<li><p>当一个类型包含（内嵌）另一个类型（实现了一个或多个接口）的指针时，这个类型就可以使用（另一个类型）所有的接口方法。类型可以通过继承多个接口来提供像 <code>多重继承</code> 一样的特性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    *io.Reader</span><br><span class="line">    *io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Go中的面相对象总结：</p>
<ol>
<li>Go 没有类，而是松耦合的类型、方法对接口的实现。</li>
<li>封装：<ol>
<li>包范围内的：通过标识符首字母小写，<code>对象</code> 只在它所在的包内可见</li>
<li>可导出的：通过标识符首字母大写，<code>对象</code> 对所在包以外也可见</li>
</ol>
</li>
<li>继承：<ol>
<li>用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现</li>
</ol>
</li>
<li>多态：<ol>
<li>用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。Go 接口不是 Java 和 C# 接口的变体，而且：接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>错误处理与测试：</p>
<ol>
<li><p>Go中预定义的error类型接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义错误：</p>
<p><code>err := errors.New(“math - square root of negative number”)</code></p>
</li>
<li><p>运行时异常和Panic</p>
<ol>
<li><p>当发生像数组下标越界或类型断言失败这样的运行错误时，Go 运行时会触发运行时 panic，伴随着程序的崩溃抛出一个 runtime.Error 接口类型的值。这个错误值有个 RuntimeError() 方法用于区别普通错误。</p>
<p>panic 可以直接从代码初始化：当错误条件（我们所测试的代码）很严苛且不可恢复，程序不能继续运行时，可以使用 panic 函数产生一个中止程序的运行时错误。panic 接收一个做任意类型的参数，通常是字符串，在程序死亡时被打印出来。Go 运行时负责中止程序并给出调试信息。</p>
</li>
<li><p>Panic的调用方式：</p>
<p>在多层嵌套的函数调用中调用 panic，可以马上中止当前函数的执行，所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者。这样向上冒泡直到最顶层，并执行（每层的） defer，在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况：这个终止过程就是 panicking。</p>
</li>
</ol>
</li>
<li><p>从Panic中恢复</p>
<ol>
<li>panic 会导致栈被展开直到 defer 修饰的 recover () 被调用或者程序中止。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="The-Cargo-Book"><a href="#The-Cargo-Book" class="headerlink" title="The Cargo Book"></a>The Cargo Book</h2><ol>
<li><p>Cargo Guide</p>
<ol>
<li><p>What is cargo？</p>
<p><em>Cargo</em> is the Rust package manager. It is a tool that allows Rust <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/appendix/glossary.html#package"><em>packages</em></a> to declare their various dependencies and ensure that you’ll always get a repeatable build.</p>
</li>
<li><p>Creating a new package</p>
<ol>
<li><code>cargo new hello_world --bin</code></li>
<li><code>cargo build</code></li>
<li><code>cargo run</code></li>
<li><code>cargo build --release</code></li>
</ol>
</li>
<li><p>Working on an existing package</p>
<ol>
<li><code>git clone</code></li>
<li><code>cargo build</code>: fetch dependencies and build them</li>
</ol>
</li>
<li><p>Package layout</p>
<ol>
<li><code>Cargo.toml</code> and <code>Cargo.lock</code> are stored in the root of your package</li>
<li><code>src</code> for source code</li>
<li><code>src/lib.rs</code> for default library files</li>
<li>Other executables can be placed in <code>src/bin/</code>.</li>
<li>Benchmarks go in the <code>benches</code> directory.</li>
<li>Examples go in the <code>examples</code> directory.</li>
<li>Integration tests go in the <code>tests</code> directory.</li>
</ol>
</li>
<li><p>toml and lock</p>
<ol>
<li><code>Cargo.toml</code> is about describing your dependencies in a broad sense, and is written by you.</li>
<li><code>Cargo.lock</code> contains exact information about your dependencies. It is maintained by Cargo and should not be manually edited.</li>
<li><code>cargo update</code> will update dependencites to newest version</li>
</ol>
</li>
<li><p>Tests</p>
<ol>
<li>Command <code>cargo test</code></li>
<li>run unit tests in /src/tests dir</li>
<li>run integration-style  tests in /tests dir</li>
</ol>
</li>
</ol>
</li>
<li><p>Cargo Reference</p>
<ol>
<li>Specifying Dependencies<ol>
<li>specifying dependencites from crates.io:default choice</li>
<li>Caret requirements:an update is allowed if the new version number does not modify the lefct-most non-zero digit in the major,minor,patch grouping</li>
<li>Tilde requirements:specify a minimal version with some ability to update(not specified part can be modified)</li>
<li>Wildcard requirements：allow for any version where the wildcard is positioned</li>
<li>comparison requirements: allow manually specifying a version range or an exiact version to depend on</li>
<li>multiple requirements:eperated with comma</li>
<li>specifying dependencies from other registries</li>
<li>specifying depemdencies from git repositories</li>
<li>specifying path dependencies</li>
<li>Mutiple locations</li>
<li>Platform specified dependencies</li>
</ol>
</li>
</ol>
</li>
<li><p>Cargo commands</p>
<ol>
<li>General Commands<ol>
<li>cargo</li>
<li>cargo help</li>
<li>cargo version</li>
</ol>
</li>
<li>Build Commands<ol>
<li><code>cargo bench</code>:execute benchmarks of a package</li>
<li><code>cargo build</code>：Compile the current package</li>
<li><code>cargo check</code>: check a local package and all of its dependencies for errors</li>
<li><code>cargo clean</code>:remove artifacts feom the target directory that Cargo has generated in the past</li>
<li><code>cargo doc</code>:build the documentation for the local pakage and all dependencies.the output is placed in target/doc</li>
<li><code>cargo fetch</code>:fetch dependencies of a pakage from the network</li>
<li><code>cargo fix</code>:automatically fix lint warnings reported by rustc</li>
<li><code>cargo run</code>:run binary or exaple if local package</li>
<li><code>cargo rustc</code>:copile the current package</li>
<li><code>cargo rustdoc</code>:build a pakage’s documentation</li>
<li><code>cargo test</code>: execute unit and integration test of package</li>
</ol>
</li>
<li>Manifest Commands<ol>
<li><code>cargo generate-lockfile</code>：create cargo.lock file for the curren package or workspace.if already exists, rebuild the lastest avaliable version of every package</li>
<li><code>cargo locate-project</code>: print a JSON object to stdout with the full path to the Cargo.toml manifest</li>
<li><code>cargo metadata</code>:output JSON to stdout containning info about the memebers and resolved deoendencies of the current package,–format-version is recommended</li>
<li><code>cargo pkgid</code>: print out the fully qualified package ID specifier  for a package or dependency in the curren workspace</li>
<li><code>cargo tree</code>:display a tree of dependencies to the terminal</li>
<li><code>cargo update</code>:update dependencies as recorded in the local lock file</li>
<li><code>cargo vendor</code>:vendor all crates.io and git dependencies for a project into the specified directory at <code>&lt;path&gt;</code>. After this command completes the vendor directory specified by <code>&lt;path&gt;</code> will contain all remote sources from dependencies specified.</li>
<li><code>cargo verify-project</code>:parse the local manifest and check it’s validity</li>
</ol>
</li>
<li>Package commands<ol>
<li><code>cargo init</code>：create a new cargo manifest in the current directory.</li>
<li><code>cargo install</code>:This command manages Cargo’s local set of installed binary crates. Only packages which have executable <code>[[bin]]</code> or <code>[[example]]</code> targets can be installed, and all executables are installed into the installation root’s <code>bin</code> folder.</li>
<li><code>cargo new</code>:create a new cargo package in the given directory.</li>
<li><code>cargo search</code>:this performs a textual search for crates on cargo repository.The matching crates will be displayed along with their descriptioin in TOML format suitable for copying into a Cargo.html manifest.</li>
<li><code>cargo uninstall</code>:by default all binaries are removed for a crate but –bin and –example flags can be used to only remove particular binaries.</li>
</ol>
</li>
<li>Publishing Commands<ol>
<li><code>cargo login</code>:This command will save the API token to disk so that commands that require authentication, such as <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/commands/cargo-publish.html">cargo-publish(1)</a>, will be automatically authenticated. The token is saved in <code>$CARGO_HOME/credentials.toml</code>. <code>CARGO_HOME</code> defaults to <code>.cargo</code> in your home directory.</li>
<li><code>cargo owner</code>:This command will modify the owners for a crate on the registry. Owners of a crate can upload new versions and yank old versions. Non-team owners can also modify the set of owners, so take care!</li>
<li><code>cargo package</code>:This command will create a distributable, compressed <code>.crate</code> file with the source code of the package in the current directory. The resulting file will be stored in the <code>target/package</code> directory. </li>
<li><code>cargo publish</code>:This command will create a distributable, compressed <code>.crate</code> file with the source code of the package in the current directory and upload it to a registry. </li>
<li><code>cargo yank</code>:The yank command removes a previously published crate’s version from the server’s index. This command does not delete any data, and the crate will still be available for download via the registry’s download link.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="The-Rust-Programming-Language"><a href="#The-Rust-Programming-Language" class="headerlink" title="The Rust Programming Language"></a>The Rust Programming Language</h2><ol>
<li><p>Programming a Guessing Game</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> secret_number = rand::thread_rng().gen_range(<span class="number">1</span>..<span class="number">101</span>);</span><br><span class="line"><span class="comment">//      println!(&quot;The secret number is: &#123;&#125;&quot;, secret_number);</span></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> guess = <span class="built_in">String</span>::new();</span><br><span class="line">                io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line">                <span class="keyword">let</span> guess: <span class="built_in">u32</span> = <span class="keyword">match</span> guess.trim().parse() &#123;</span><br><span class="line">                                                <span class="literal">Ok</span>(num) =&gt; num,</span><br><span class="line">                                                <span class="literal">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">                                        &#125;;</span><br><span class="line">                <span class="keyword">match</span> guess.cmp(&amp;secret_number) &#123;</span><br><span class="line">                 Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">                 Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">                 Ordering::Equal =&gt; &#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You guessed :&#123;&#125;&quot;</span>, guess);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Common Programming Concepts</p>
<ol>
<li><p>Variables and Mutablity</p>
<ol>
<li>by default variables are immutable</li>
<li>if want mutable, use keyword <code>mut</code> before name of viariance</li>
<li>Difference between variables and constants<ol>
<li><code>mut</code> can not be used with constants</li>
<li>declare constants using <code>const</code> instead of <code>let</code></li>
<li>constants can be declared in any scope</li>
<li>constants may be set only to a constant expression</li>
<li>constants naming convention:use all upercase with underscores between words</li>
</ol>
</li>
<li>Shadowing<ol>
<li>we can shadow a variable by using the same variable’s name and repeating the use of <code>let</code> keyword</li>
<li>shadowing allow us using the same name for different types</li>
</ol>
</li>
</ol>
</li>
<li><p>Data types</p>
<ol>
<li><p>Scalar Types</p>
<ol>
<li><p>Integer Types</p>
<table>
<thead>
<tr>
<th>Length</th>
<th>Signed</th>
<th>Unsigned</th>
</tr>
</thead>
<tbody><tr>
<td>8-bit</td>
<td><code>i8</code></td>
<td><code>u8</code></td>
</tr>
<tr>
<td>16-bit</td>
<td><code>i16</code></td>
<td><code>u16</code></td>
</tr>
<tr>
<td>32-bit</td>
<td><code>i32</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>64-bit</td>
<td><code>i64</code></td>
<td><code>u64</code></td>
</tr>
<tr>
<td>128-bit</td>
<td><code>i128</code></td>
<td><code>u128</code></td>
</tr>
<tr>
<td>arch</td>
<td><code>isize</code></td>
<td><code>usize</code></td>
</tr>
</tbody></table>
<p>Range caculation: -(2^n - 1^) to 2^n - 1^ - 1</p>
<p>e.g. 1_000 = 1000, 57u8 = u8 type of value 57</p>
<p>more examples:</p>
<table>
<thead>
<tr>
<th>Number literals</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>Decimal</td>
<td><code>98_222</code></td>
</tr>
<tr>
<td>Hex</td>
<td><code>0xff</code></td>
</tr>
<tr>
<td>Octal</td>
<td><code>0o77</code></td>
</tr>
<tr>
<td>Binary</td>
<td><code>0b1111_0000</code></td>
</tr>
<tr>
<td>Byte (<code>u8</code> only)</td>
<td><code>b&#39;A&#39;</code></td>
</tr>
</tbody></table>
</li>
<li><p>Floating-Point Types</p>
<ol>
<li>single-percision:<code>f32</code></li>
<li>double-percision:<code>f64</code></li>
</ol>
</li>
<li><p>Boolean type</p>
<ol>
<li><code>bool</code></li>
</ol>
</li>
<li><p>Character Type</p>
<ol>
<li>size:4 bytes</li>
<li>Unicode</li>
<li><code>char</code></li>
</ol>
</li>
</ol>
</li>
<li><p>Compound Types</p>
<ol>
<li><p>The Tuple Type</p>
<ol>
<li><p>group together a number of values with a variety of types into one compound type</p>
</li>
<li><p>fix length</p>
</li>
<li><p>e.g.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>visited by index</p>
</li>
</ol>
</li>
<li><p>The Array Type</p>
<ol>
<li><p>every element of an array muse have the same type</p>
</li>
<li><p>fix length</p>
</li>
<li><p>e.g</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">3</span>; <span class="number">5</span>]<span class="comment">// size 5 with initial value 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>visited  by index</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Functions</p>
<ol>
<li>Coding stype: snake case. All letters are lowercase and underscores separate words</li>
<li>start with <code>fn</code></li>
<li>Function Parameters<ol>
<li>type of each parameter must be declared</li>
<li>multiple parameters separated with commas</li>
</ol>
</li>
<li>Function bodies contain statements and expressions<ol>
<li>Expressions do not include ending semicolons, if have, expression turns to statement,which will not return a value</li>
</ol>
</li>
<li>Functions with return values<ol>
<li>Declare return vlaue types after a <code>-&gt;</code></li>
<li> the return value of the function is synonymous with the value of the final expression in the block of the body of a function. </li>
</ol>
</li>
</ol>
</li>
<li><p>Comments</p>
<ol>
<li><code>//</code></li>
</ol>
</li>
<li><p>Control Flow</p>
<ol>
<li><p>If Expressions（if-else if-else）</p>
</li>
<li><p>Loop(loop)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    loop &#123;</span><br><span class="line">        println!(&quot;again!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>break &amp; continue can use lable to apply to the labled loop </p>
</li>
<li><p>you can add the calue you want returned after the <code>break</code> expression</p>
</li>
<li><p>conditional loop with <code>while</code></p>
</li>
<li><p>For loop:<code>for element in collection</code></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Understanding Ownership</p>
<ol>
<li><p>What is ownership?</p>
<ol>
<li>Memory is managed through a system of ownership with a set of rules that the compiler checks at compile time.</li>
<li>Stack and Heap<ol>
<li>stack for known, fixed size data at compile time</li>
<li>heap is less organized, freee space must be serached</li>
<li>hense stack is more efficiency</li>
<li>when code calls a function ,value passed into function and variables get pushed onto the stack , when the function is over, those values get poped off the stack</li>
<li>heap is controlled by ownership</li>
</ol>
</li>
<li>Ownership rules<ol>
<li>Each value in Rust has variable that’s called its owner</li>
<li>There can only be one owner at a time </li>
<li>When the owner goes out of scope,the value will be dropped</li>
</ol>
</li>
<li>Variable Scope<ol>
<li>When varianle comes into scope, it is valid</li>
<li>it remains valid until it goes out of scope</li>
</ol>
</li>
<li>The String type<ol>
<li>string is immutable but String not</li>
</ol>
</li>
<li>Memory and Allocation</li>
<li>Ways Variables and Data interact:Move<ol>
<li>primitive types allocated on stack</li>
<li>Reference allocated on stack</li>
<li>Data allocated on heap</li>
<li>For ptimitive types: s1 = s2 means copy on stack</li>
<li>For non-primitive types: s1 = s2 means referece copied on stack and data on heap did not do anything</li>
</ol>
</li>
<li>Ways Varianles and Data interact:Clone<ol>
<li>if we do want to deeply copy the heap data of the String, not just the stack data, we can use a common method called <code>clone</code></li>
</ol>
</li>
<li>Stack-Only data:copy<ol>
<li>Types such as integers that have a known size at compile time are strored entirely on the stack ,so copies of the actual values are quick to make.</li>
<li>if a type implements the <code>copy</code> trait, an doler variable is still usable after assignment.</li>
</ol>
</li>
<li>Ownership and functions<ol>
<li>The semantics for passing a value to a function are similar to those for assigning a value to a variable.Passing a variable to a funtion will move or Copy.For ptimitive types, after funciton calling, variable is still valid, but for other(e.g. String) types, calling function means ownership moving ,which meams s will be invalid after function call.</li>
</ol>
</li>
<li>Return values and scope<ol>
<li>returning values can also transfer ownership</li>
<li>The ownership of a variable follows the same pattern every time: assigning a vlaue to another variable moves it.When a variable that includes data on the heap goes out of scope,the value will be cleaned by <code>drop</code> unless the data has been moved to be owned by another variable.</li>
</ol>
</li>
</ol>
</li>
<li><p>References and Borrowing</p>
<ol>
<li><p>reference allow you to refer to some value without taking ownership of it.</p>
</li>
<li><p>The <code>&amp;s1</code> syntax lets us create a reference that <em>refers</em> to the value of <code>s1</code> but does not own it. Because it does not own it, the value it points to will not be dropped when the reference stops being used.</p>
</li>
<li><p>When functions have rederences as parameters intead of the actual values, we won’t need to return the values in order to give back ownership, because we never had ownership.We call the action of creating a reference  <em>borrowing</em>.</p>
</li>
<li><p>Modifying something borrowed is not allowed, just as variables are immutable by default, so are references.</p>
</li>
<li><p>Mutable references, e.g.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mutable references have one big restiction:you can have only one mutable reference to a particular piece of data at a time.The restriction preventing multiple mutable references to the same data at the same time allows for mutation but in a very controlled fashion.Rust prevents data races  even in compile time.Samelly, combining mutable and immutable references is also no permitted.(considered it is same as RW lock mechanism).Note that a reference’s scope starts from where it is introduced and continues through the last time that references is used.</p>
</li>
<li><p>Dangling References</p>
<p>In languages with pointers, it’s easy to erroneously create a <em>dangling pointer</em>, a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</p>
</li>
<li><p>The rules of References</p>
<ol>
<li>At any given time, you can have either one mutable references or any number of immutable references.</li>
<li>Referebces must always be valid.</li>
</ol>
</li>
</ol>
</li>
<li><p>The Slice Type</p>
<ol>
<li>A String Slice is a reference to part of a String.</li>
<li>We can create slices using a range within brackets by specifying <code>[starting_index..ending_index]</code>, where <code>starting_index</code> is the first position in the slice and <code>ending_index</code> is one more than the last position in the slice.</li>
<li>if starting_index omitted, which means start from zero, if ending_index omitted, which means end to last byte, if all ommited, which means reference the total string</li>
<li>The type that signifies “string slice” is written as <code>&amp;str</code></li>
<li>The compiler will ensure the references into the String remain valid.</li>
<li>String literals are slices：<code>let s = &quot;Hello, World&quot;</code>， the type of <code>s</code> here is <code>&amp;s</code>, it is a slice poting to that specified piont of the binary, This is also why string literals are immutable, <code>&amp;str</code> is an immutable reference.</li>
</ol>
</li>
</ol>
</li>
<li><p>Using structs to structure  related data</p>
<ol>
<li><p>Defining an instantiating structs</p>
<ol>
<li>Structs are similar to tuples, but unlike with tuple, you will name each piece of data so it is clear what the values mean.Structs are more flexible than tuples:you don’t have to rely on the order of the data so specify or access the value of an instance.</li>
<li>kv pairs visited(read or write) by dot<code>.</code></li>
</ol>
</li>
<li><p>Creating instances from other instances with struct update syntax</p>
<ol>
<li><p>Using struct update syntax, we can achieve the same effect with less code, as shown in Listing 5-7. The syntax <code>..</code> specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Using Tuple Structs Without Named Fields to Create Different Types</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>Unit-Like Structs Without Any Fields</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AlwaysEqual</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subject = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Method Syntax</p>
<ol>
<li><p>Method are similar to functions, but methods are different from functions in that they’re defined within the context of a struct and their first parameter is always <code>self</code>, which represents the instance of the stuct the method is being called on.</p>
</li>
<li><p>Where is the <code>-&gt;</code> Operator?</p>
<ol>
<li>Rust has a featured called automatic referencing and dereferencing.</li>
</ol>
</li>
<li><p>Associated Functions</p>
<ol>
<li><p>All functions defined within an <code>impl</code> block are called associaterd functions because they’re associated with the type name after the <code>impl</code></p>
</li>
<li><p>Associated functions that aren’t methods are often used for constructors that will return a new instance of the struct.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> sq = Rectangle::square(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Multiple imlp Blocks</p>
<ol>
<li>It is valid to seperate methods into multiple impl blocks but not recomended.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Enums and Pattern Matching</p>
<ol>
<li><p>Defining an Enum</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> four = IpAddrKind::V4;</span><br><span class="line">    <span class="keyword">let</span> six = IpAddrKind::V6;</span><br><span class="line"></span><br><span class="line">    route(IpAddrKind::V4);</span><br><span class="line">    route(IpAddrKind::V6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">route</span></span>(ip_kind: IpAddrKind) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Enum Values</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span>&#123;</span><br><span class="line">  v4(<span class="built_in">String</span>),</span><br><span class="line">  v6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="built_in">String</span>::from(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>Any type can be values for Enums.</p>
</li>
<li><p>Enum Methods</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">        Quit,</span><br><span class="line">        Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">        Write(<span class="built_in">String</span>),</span><br><span class="line">        ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Message &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="comment">// method body would be defined here</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> m = Message::Write(<span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    m.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>The <code>Option</code>Enum and it’s advantages over Null values</p>
<ol>
<li>When we have <code>Some</code>value,we know that a value is present and the value is held within the Some</li>
<li>When we have a <code>None</code>value,in some sense, it means the same thing as null</li>
<li>In other words, you have to convert an <code>Option&lt;T&gt;</code> to a <code>T</code> before you can perform <code>T</code> operations with it.Generally, this helps catch one of the most common issues with null: assuming that something isn’t null when it actually is.</li>
<li><code>match</code> expression is a control flow construct that does just this when used with enums.</li>
</ol>
</li>
<li><p>The match control flow operator</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">      <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">      <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">let</span> six = plus_one(five);</span><br><span class="line">  <span class="keyword">let</span> none = plus_one(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Matches Are Exhaustive</p>
<ol>
<li>Matches in Rust are exhaustive, we must exhaust every last possibility in order for the code to be valid.Especially inthe case of <code>Option&lt;T&gt;</code>, when Rust prevent us from forgetting to explicitly handle None case.</li>
</ol>
</li>
<li><p>Catch-all Patterns and the _ Placeholder</p>
<ol>
<li><p>for match default arm, we can use <code>other</code> and <code>_</code>to handle this.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let dice_roll = 9;</span><br><span class="line">    match dice_roll &#123;</span><br><span class="line">        3 =&gt; add_fancy_hat(),</span><br><span class="line">        7 =&gt; remove_fancy_hat(),</span><br><span class="line">        other =&gt; move_player(other),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_fancy_hat() &#123;&#125;</span><br><span class="line">    fn remove_fancy_hat() &#123;&#125;</span><br><span class="line">    fn move_player(num_spaces: u8) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let dice_roll = 9;</span><br><span class="line">    match dice_roll &#123;</span><br><span class="line">        3 =&gt; add_fancy_hat(),</span><br><span class="line">        7 =&gt; remove_fancy_hat(),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_fancy_hat() &#123;&#125;</span><br><span class="line">    fn remove_fancy_hat() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Concise Control Flow with if let</p>
<ol>
<li><p>The <code>if let</code>syntax lets you combine if and let into a less verbose way to handle values that match one pattern while ignoring the rest.</p>
</li>
<li><p>In other words, you can think of <code>if let</code> as syntax sugar for a <code>match</code> that runs code when the value matches one pattern and then ignores all other values.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let config_max = Some(3u8);</span><br><span class="line">    match config_max &#123;</span><br><span class="line">        Some(max) =&gt; println!(&quot;The maximum is configured to be &#123;&#125;&quot;, max),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let config_max = Some(3u8);</span><br><span class="line">    if let Some(max) = config_max &#123;</span><br><span class="line">        println!(&quot;The maximum is configured to be &#123;&#125;&quot;, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> coin = Coin::Penny;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Quarter(state) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state),</span><br><span class="line">        _ =&gt; count += <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> coin = Coin::Penny;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> Coin::Quarter(state) = coin &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>Managing Growing projects with packages,Crates,and Modules</p>
<p>(haven’t read)</p>
</li>
<li><p>Common Collections</p>
<ol>
<li><p>Types:</p>
<ol>
<li>A vector allows you to store a variable number of values next to each other</li>
<li>A string is a collection of characters</li>
<li>A hash map allows you to associate a value with a particular key</li>
</ol>
</li>
<li><p>Storing Lists of Values with Vectors</p>
<ol>
<li><p>Creating a new vector</p>
<p><code>let v: Vec&lt;i32&gt; = Vec::new()</code></p>
<p>Simply</p>
<p><code>let v = vec![1,2,3]</code></p>
</li>
<li><p>Update a vector</p>
<p><code>v.push(1)</code></p>
</li>
<li><p>Drop a vector Drops its elements</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do stuff with v</span></span><br><span class="line">    &#125; <span class="comment">// &lt;- v goes out of scope and is freed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Read elements of vectors</p>
<p>with index syntax or the <code>get</code> method</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> third: &amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="literal">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Iterating over the values in a vector</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">        *i += <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Using am Emum to store multiple Types</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</span><br><span class="line">        Int(<span class="built_in">i32</span>),</span><br><span class="line">        Float(<span class="built_in">f64</span>),</span><br><span class="line">        Text(<span class="built_in">String</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">        SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">        SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">        SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Storing UTF-8 Encoded Text with Strings</p>
<ol>
<li><p>Create a new String</p>
<p><code>let data = &quot;initial contents&quot;.to_string()</code></p>
<p><code>let s = String::from(&quot;initial contents&quot;)</code></p>
</li>
<li><p>Update a String</p>
<p><code>s.push_str(&quot;bar&quot;)</code></p>
<p><code>s.push(&#39;l&#39;)</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = s1 + &amp;s2;</span><br><span class="line"><span class="comment">// + use fn add(self, s: &amp;str) -&gt; String &#123;</span></span><br></pre></td></tr></table></figure>

<p>use <code>format!</code> Macro is recomended</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">String</span>::from(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br></pre></td></tr></table></figure>

<p><code>format!</code> macro works in the same way as <code>ptintln!</code> but instead of printing the output to the screen,it returns a <code>String</code> with the contents. The code generated by the <code>format!</code> macro uses references so that this call doesn’t take ownership of any of its parameters.</p>
</li>
<li><p>Index into Strings</p>
<ol>
<li>index to a String is not valid.</li>
</ol>
</li>
<li><p>Slice Strings</p>
<p><code>s[start..end]</code></p>
</li>
<li><p>Methods for Iterating Over Strings</p>
<p><code>for c in &quot;abcde&quot;.chars()</code></p>
<p><code>for b in &quot;abcde&quot;.bytes()</code></p>
</li>
</ol>
</li>
<li><p>Storing keys with associated values in hash maps</p>
<ol>
<li><p>Creating a hash map</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.inert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.indert(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>),<span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>Another way with two vec</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> teams = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> initial_scores = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores: HashMap&lt;_, _&gt; = teams.into_iter().zip(initial_scores.into_iter()).collect();</span><br></pre></td></tr></table></figure></li>
<li><p>HashMaps and ownership</p>
<ol>
<li>For types that implement the <code>copy</code> trait, the values are copied into the hashmap.For owned values like <code>String</code>, the values will be moved and the hashmao will be the owner of those values.</li>
</ol>
</li>
<li><p>Accessing values in a hashmap</p>
<p><code>let team_name = String::from(&quot;Blue&quot;)</code></p>
<p><code>let score = scores.get(&amp;team_name)</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std:collections::Hashmap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(key, value) int &amp;scores &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Updating a hashmap</p>
<ol>
<li><p>overwitring a value</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">20</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>Only inserting a value if the key has no value</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>)).or_insert(<span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>The <code>or_insert</code> method on <code>Entry</code> is defined to return a mutable reference to the value for the corresponding <code>Entry</code> key if that key exists, and if not ,inserts the parameter as the new value for this key and returns a mutable reference to the new value.</p>
</li>
<li><p>Updating a value based on the old value</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text,split_whitespcae() &#123;</span><br><span class="line">  <span class="keyword">let</span> count = map.entry(word).or_intsert(<span class="number">0</span>);</span><br><span class="line">  *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>or_insert</code> method actually returns a mutable reference(<code>&amp;mut v</code>) to the value for this key.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Error Handling</p>
<ol>
<li><p>Unrecoverable Erros with panic!</p>
</li>
<li><p>Recoverable Errors with Result</p>
<ol>
<li><p>Resuit Enum</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">	<span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">		OK(file) =&gt; file,</span><br><span class="line">		<span class="literal">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Mathcing on different errors</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>).unwrap_or_else(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.kind() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::create(<span class="string">&quot;hello.txt&quot;</span>).unwrap_or_else(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Shortcuts for panic on error:unwrap and expect</p>
<ol>
<li><p><code>unwrap</code> is a shortcut method that is implemented just like the <code>match</code>expression.if the <code>Result</code> value is <code>Ok</code> variant,<code>unwrap</code> will return the value inside the <code>Ok</code>.If the <code>Result</code> is the <code>Err</code> variant,<code>unwrap</code> will call the <code>panic!</code>macro for us.</p>
<p><code>let f = File::open(&quot;hello.txt&quot;).unwrap()</code></p>
</li>
<li><p>We use <code>expect</code> in the same way as <code>unwrap</code>: to return the file handle or call the <code>panic!</code> macro. The error message used by <code>expect</code> in its call to <code>panic!</code> will be the parameter that we pass to <code>expect</code>, rather than the default <code>panic!</code> message that <code>unwrap</code> uses.</p>
<p><code>let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open&quot;)</code></p>
</li>
</ol>
</li>
<li><p>Propagating Errors</p>
<p>A shortcut for prapagating errors:<code>?</code> operator</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">  f.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">  <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the value of the <code>Result</code> is an <code>OK</code>,tge value inside<code>Ok</code> will get returned from this expression, and the program will continue.if the value is an <code>Err</code>, the <code>Err</code> will be returned from the whole function as if we had used return keyword so the error value gets propagated to the calling code.</p>
<p>The <code>?</code> operator can be used in functions that have type of <code>Result</code>.</p>
</li>
</ol>
</li>
<li><p>To panic! Or Not To panic!</p>
<p>So how do you decide when you should call <code>panic!</code> and when you should return <code>Result</code>? When code panics, there’s no way to recover. You could call <code>panic!</code> for any error situation, whether there’s a possible way to recover or not, but then you’re making the decision on behalf of the code calling your code that a situation is unrecoverable. When you choose to return a <code>Result</code> value, you give the calling code options rather than making the decision for it. The calling code could choose to attempt to recover in a way that’s appropriate for its situation, or it could decide that an <code>Err</code> value in this case is unrecoverable, so it can call <code>panic!</code> and turn your recoverable error into an unrecoverable one. Therefore, returning <code>Result</code> is a good default choice when you’re defining a function that might fail.</p>
</li>
</ol>
</li>
<li><p>Generic Types, Traits, and LifeTImes</p>
<ol>
<li><p>Generic Data Types</p>
<ol>
<li><p>In Function Definitions</p>
<p>Before we use a para,eter in the body of the function, we have to declare the parameter name in the signature so the compiller knows what that name means.</p>
<p><code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;...&#125;</code></p>
</li>
<li><p>In Struct Definitions</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">  X: T,</span><br><span class="line">  y: T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T, U&gt; &#123;</span><br><span class="line">  x: T,</span><br><span class="line">  y: U,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>In Enum Definitions</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="literal">Some</span>(T),</span><br><span class="line">  <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">  <span class="literal">Ok</span>(T),</span><br><span class="line">  <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>In Method Definitions</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">  x: T,</span><br><span class="line">  y: T,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">    &amp;<span class="keyword">self</span>.x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Traits:Definning Shared Behavior</p>
<ol>
<li><p>A <em>trait</em> tells the Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior.</p>
</li>
<li><p>Defining a trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Imlementing a trait  on a type</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> </span><br><span class="line">	<span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">	<span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">	<span class="keyword">pub</span> author: <span class="built_in">String</span>,	</span><br><span class="line">	<span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Default Implementations</p>
<p>traits can have default implementations</p>
</li>
<li><p>Traits as parameters</p>
</li>
<li><p>We have implemented the <code>Summary</code> trait on the <code>NewsArticle</code> and <code>Tweet</code> types.We can define a <code>notify</code> function that calls the  summarize method on its <code>item</code> parameter,which is of some type that implements the <code>Summary</code> trait.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item : &amp;<span class="keyword">impl</span> Summary) &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Trait Bound Syntax</p>
<p>Code in item6 is straightforward but it is actually a syntax sugar for a longer form called trait bound.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T : Summary&gt;(item : &amp;T) &#123;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Specifying Multiple Trait Bounds with + Syntax</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item :&amp;(<span class="keyword">impl</span> Summary + Display)) &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T : Summary + Display&gt; (item: &amp;T) &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Clearer Trait bounds with where clauses</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; <span class="built_in">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure></li>
<li><p>Returning types that implement traits</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_summarizable</span></span>() -&gt; <span class="keyword">impl</span> Summary &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>Attention, you can only use <code>impl Trait</code> if you‘re returning a sigle type.</p>
</li>
<li><p>Using Trait Bounds to Conditionally Implement Methods</p>
<p>We can also conditinally implement a trait for any type that implements another trait.Implementations of a trait on any type that satisfies the trait bounds are called <em>blanket implementations</em>.</p>
</li>
</ol>
</li>
<li><p>Validating references with lifetimes</p>
<ol>
<li><p>Preventing dangling references with lifetimes</p>
</li>
<li><p>The Borrow checker</p>
</li>
<li><p>Generic Lifetimes in functions</p>
</li>
<li><p>Lifetime Annotation Syntax</p>
</li>
<li><p>Lifetime Annotations in function signatures</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> longest&lt;’a&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,y: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> x,len() &gt; y.len() &#123;</span><br><span class="line">    x</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The function signature now tells Rust that for some lifetime <code>&#39;a</code>, the function takes two parameters, both of which are string slices that live at least as long as lifetime <code>&#39;a</code>. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime <code>&#39;a</code>. In practice, it means that the lifetime of the reference returned by the <code>longest</code> function is the same as the smaller of the lifetimes of the references passed in. These constraints are what we want Rust to enforce. Remember, when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. Rather, we’re specifying that the borrow checker should reject any values that don’t adhere to these constraints. Note that the <code>longest</code>function doesn’t need to know exactly how long <code>x</code> and <code>y</code> will live, only that some scope can be substituted for <code>&#39;a</code> that will satisfy this signature.</p>
</li>
<li><p>Thinking in terms of lifetimes</p>
</li>
<li><p>Lifetime annotations in struct dedinitions</p>
<p>We have only defined structs to hold owned types.It is possible for structs to hold references, but in that case we would need to add a lifetime annotation on every reference in the struct’s definition.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> novel = <span class="built_in">String</span>::from(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> first_sentence = novel.split(<span class="string">&#x27;.&#x27;</span>).next().expect(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> i = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This annotation means an instance of ImportantExcerpt can not outlive the reference it holds in its part field.</p>
</li>
<li><p>Lifetime Elision</p>
<p>Lifetimes on function or method parameters are called <em>input lifetimes</em>, and lifetimes on return values are called <em>output lifetimes</em>.</p>
<p>Three rules for lifetime:</p>
<ol>
<li>Each parameter that is a reference gets its own lifetime parameter</li>
<li>If there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters</li>
<li>There are multiple input lifetime parameters, but one of them is <code>&amp;selft</code> or <code>&amp;mut self</code> because this is a method, the lifetime of <code>self</code> is assigned to all output lifetime parameters.</li>
</ol>
</li>
<li><p>Lifetime Annotations in Method Definitions</p>
<p>Lifetime names for struct fields always need to be declared after the <code>impl</code> keyword and then used after the struct’s name, because those lifetimes are part of the struct’s type</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">level</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>The static lifetime</p>
<p>Static reference can live for the entire duration of the program</p>
<p><code>let s: &amp;&#39;static str = &quot;I have a static lifetime&quot;&#39;</code></p>
</li>
<li><p>Generic Type parameters, Trait Bounds, and lifetimes Together</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = longest_with_an_announcement(</span><br><span class="line">        string1.as_str(),</span><br><span class="line">        string2,</span><br><span class="line">        <span class="string">&quot;Today is someone&#x27;s birthday!&quot;</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest_with_an_announcement</span></span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">    y: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">    ann: T,</span><br><span class="line">) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>Writing Automated Tests</p>
<ol>
<li><p>How to Write Tests？</p>
<ol>
<li><p>Checking resutls with the <code>assert!</code> Macro</p>
<p>We give the <code>!assert</code> Marco an argument that avaluates to a Boolean,if the value is true, assert! does nothing an the test passes,if the value is false, the assert! Macro calls the panic! macro.</p>
</li>
<li><p>Testing equality with the <code>assert_eq!</code> And <code>assert_ne!</code> marcos</p>
</li>
<li><p>Adding custom failure messages</p>
</li>
<li><p>Checking for panics with <code>should_panic</code></p>
<p>To our test function, this attribute makes a test pass if the code inside the function panics, thet test will fial if the code inside the function doesn’t panic.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Guess</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Guess &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(value: <span class="built_in">i32</span>) -&gt; Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;&#125;.&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greater_than_100</span></span>() &#123;</span><br><span class="line">        Guess::new(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Test orgnization</p>
<p>The <code>#[cfg(test)]</code> annotation on the tests module tells Rust to compile and run the test code only when you run <code>cargo test</code>, not when you run <code>cargo build</code>. </p>
</li>
</ol>
</li>
<li><p>Function Language features:iterators and closures</p>
<ol>
<li><p>Closures:aninymous functions that can capture their environment</p>
<ol>
<li><p>To define a closure, we start with a pair of vertical pipes<code>|</code>，after the parameters,we place curly brackets that hold the body of the closure,which is optinal if the closure body is a sigle expression.</p>
</li>
<li><p>Closures don’t require  you to annotate the types of the parameters or the return value like functions do.The compiler is reliably able to infer the types if the paramaters and the return value, similar to how it’s able to infer types of most variables.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span>  <span class="title">add_one_v1</span>   </span>(x: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> add_one_v2 = |x: <span class="built_in">u32</span>| -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> add_one_v3 = |x|             &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> add_one_v4 = |x|               x + <span class="number">1</span>  ;</span><br></pre></td></tr></table></figure></li>
<li><p>Once user calling a closure, compiler refers the type of closure paramaters, and types are then locked into the closure,and we get a type error if we try to use a difference type with the same closure.</p>
</li>
<li><p>Cloures have an additional capability that functions don’t have: they can capture their environment and access variables from the scope in which they’re defined.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">equal_to_x</span></span>(z: <span class="built_in">i32</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        z == x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(equal_to_x(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Closures can capture value from their environment in three ways,which directly map to the three ways a function can take a parameter:taking ownership, borrowing mutably, and borrowing immutably.These are encoded in three <code>Fn</code> traits as follows:</p>
<ul>
<li><p><code>FnOnce</code>:consumes the variables it captures from its enclosing scope, known as the closure’s environment.To consume the captured variables, the closure must take ownership of these variables and move them into the closure when it is defined.The once part of the name represents the fact that the closure can’t take ownership of the same variables more than once, so it can be called only once.</p>
</li>
<li><p><code>FnMut</code>:can change the environment because it mutably borrows values.</p>
</li>
<li><p><code>Fn</code>:borrows values from the environment immutably</p>
</li>
</ul>
<p>When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement <code>FnOnce</code> because they can all be called at least once. Closures that don’t move the captured variables also implement <code>FnMut</code>, and closures that don’t need mutable access to the captured variables also implement <code>Fn</code>. In Listing 13-12, the <code>equal_to_x</code>closure borrows <code>x</code> immutably (so <code>equal_to_x</code> has the <code>Fn</code> trait) because the body of the closure only needs to read the value in <code>x</code>.</p>
<p>If you want to force the closure to take ownership of the values it uses in the environment, you can use the <code>move</code> keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it’s owned by the new thread.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> equal_to_x = <span class="keyword">move</span> |z| z == x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;can&#x27;t use x here: &#123;:?&#125;&quot;</span>, x);</span><br><span class="line">  <span class="comment">// move this line, the code can be compiled</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(equal_to_x(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Processing a series of items with iterators</p>
<ol>
<li><p>Iterators are lazy</p>
</li>
<li><p>The Iterator trait an next method</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// methods with default implementations elided</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The valuies we get from the calls to <code>next</code> are immutable references to the values in the vector.The <code>iter</code>  method produces an iterator over immutable references.If we want to create an iterator that takes ownership of vector and returns owned values, we can call <code>into_iter</code> instead of <code>iter</code>.Similarly， if we want to iterate over mutable references, we can call <code>iter_mut</code> instead of <code>iter</code>.</p>
</li>
<li><p>Methods that consume the iterator</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">iterator_sum</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">let</span> v1_iter = v1.iter();</span><br><span class="line">  <span class="keyword">let</span> total:<span class="built_in">i32</span> = v1.iter.sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Methods that produce other iterators</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> v2: <span class="built_in">Vec</span>&lt;_&gt; = v1.iter().map(|x| x+<span class="number">1</span>).collect();</span><br></pre></td></tr></table></figure>

<p>We use collect method to consume the iterator because iterators are lazy, we collect the results of iterating over the iterator that’s returned from the call to <code>map</code> into a vector.</p>
</li>
<li><p>Using closures that capture their environment</p>
<p><code>filter</code> iterator adaptor:The <code>filter</code> method on an iterator takes a closure that takes each item from the iterator and returns a boolean.If the closure returns true, the value will be included in the iterator produced by filter, if the closure returns false, the value won’t be included in the resulting iterator.</p>
<p><code>shoes.into_iter().filter(|s| s.size == shoe_size).collect()</code></p>
</li>
<li><p>Comparing performance:Loops and iterators</p>
<p>Closures and iterators are Rust features inspired by functional programming language ideas. They contribute to Rust’s capability to clearly express high-level ideas at low-level performance. The implementations of closures and iterators are such that runtime performance is not affected. This is part of Rust’s goal to strive to provide zero-cost abstractions.</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>More about Cargo and Crates.io (Not covered)</p>
</li>
<li><p>Smart Pointers</p>
<ol>
<li><p>In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that the reference are pointers that only borrow data; in contrast, in many cases, smart pointers own the data they point to.</p>
</li>
<li><p>Using Box<T> to point to data on the heap</p>
<p>Boxes allow you to store data on the heap rather than the stack, what remains on the stack is the pointer to the heap data.</p>
<ol>
<li>Enabling recursive types with boxes</li>
</ol>
</li>
<li><p>Treating smart pointers like regular references with the Deref trait</p>
<p>Implementing the <code>Deref</code> trait allows you to customize the behavior of the <em>dereference operator</em>, <code>*</code>(as opposed to the multiplication or glob operator). By implementing <code>Deref</code> in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</p>
<p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references.The <code>deref</code> method gives the compiller the ability to take value of any type that implements <code>Deref</code> and call the <code>deref</code> method to get a <code>&amp;</code> reference that it knows how to dereference.</p>
</li>
<li><p>Implicit deref coercions with functions and methods</p>
<p><em>Deref coercion</em> is a convenience that Rust performs on arguments to functions and methods. Deref coercion works only on types that implement the <code>Deref</code> trait. Deref coercion converts such a type into a reference to another type. For example, deref coercion can convert <code>&amp;String</code> to <code>&amp;str</code> because <code>String</code> implements the <code>Deref</code> trait such that it returns <code>&amp;str</code>. Deref coercion happens automatically when we pass a reference to a particular type’s value as an argument to a function or method that doesn’t match the parameter type in the function or method definition. A sequence of calls to the <code>deref</code> method converts the type we provided into the type the parameter needs.</p>
<p>Deref coercion was added to Rust so that programmers writing function and method calls don’t need to add as many explicit references and dereferences with <code>&amp;</code> and <code>*</code>. The deref coercion feature also lets us write more code that can work for either references or smart pointers.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(name: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    hello(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>with rust deref coercions, the code is equal to</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    hello(&amp;(*m)[..]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>How deref coercion interacts with mutability</p>
<p>rust does deref coercion when it finds types and trait implementions in three cases:</p>
<ul>
<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
</li>
<li><p>Running code on cleanup with the drop trait</p>
<p>The second trait important to the smart pointer pattern is <code>Drop</code>, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the <code>Drop</code>trait on any type, and the code you specify can be used to release resources like files or network connections. We’re introducing <code>Drop</code> in the context of smart pointers because the functionality of the <code>Drop</code> trait is almost always used when implementing a smart pointer. For example, when a <code>Box&lt;T&gt;</code> is dropped it will deallocate the space on the heap that the box points to.</p>
<p>Programmer do not have to free memory in code when finishing using an instance of a data type.In rust, when a value goes out of scope,the compiler will insert ‘free memory’ code automatically.</p>
<p>Most of time, programmers do not have to drop memory of one instance before the scope ending, if have to, rust provides a method <code>std::mem::drop</code> to do this.</p>
</li>
<li><p>Rc<T>, the reference counted smart pointer</p>
<p>To enable multiple ownership, Rust has a type called <code>Rc&lt;T&gt;</code>, which is an abbreviation for <em>reference counting</em>. The <code>Rc&lt;T&gt;</code> type keeps track of the number of references to a value to determine whether or not the value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</p>
<p>We use the <code>Rc&lt;T&gt;</code> type when we want to allocate some data on the heap for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data’s owner, and the normal ownership rules enforced at compile time would take effect.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RefCell<T> and the interior mutability pattern </p>
<p>……..(TODO)</p>
<p>reference:<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">https://doc.rust-lang.org/book/ch15-05-interior-mutability.html</a></p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/Distributed-protocol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/Distributed-protocol/" class="post-title-link" itemprop="url">Distributed protocol</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-04 10:39:58 / Modified: 10:40:34" itemprop="dateCreated datePublished" datetime="2022-01-04T10:39:58+08:00">2022-01-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="Consensus-Algorithm"><a href="#Consensus-Algorithm" class="headerlink" title="Consensus Algorithm"></a>Consensus Algorithm</h2><p>满足三个条件：</p>
<p>non-triviality:if the value v is decided,then v must have been proposed by a proposer</p>
<p>safety &amp; safe learning:任意两个proposr，得知decided value is a andf b,必有a=b</p>
<h3 id="classic-paxos"><a href="#classic-paxos" class="headerlink" title="classic paxos"></a>classic paxos</h3><p>two phase：</p>
<ol>
<li>reading phase</li>
<li>writing phase</li>
</ol>
<p>properties for proposer</p>
<ol>
<li>epoch</li>
<li>proppser只在收到大部分acceptor的promise后开始提议</li>
<li>proposer只在收到大部分acceptor的accepts后返回最终的决议值</li>
<li>如果之前没有确定value，任何value可以被propose，如果有，则epoch最高的value被propose</li>
<li>被proposer使用的epoch大于之前所有被使用过得epoch</li>
</ol>
<p>properties for acceptor：</p>
<ol>
<li>acceptor只处理收到的的prepare或者propose中epoch&gt;= last promised epoch的消息</li>
<li>For each prepare or propose message received, the acceptor’s last promised epoch is set to the epoch received. This is after Property 6 has been satisfied.</li>
<li>For each prepare message received, the acceptor replies with promise. This is after Properties 6 &amp; 7 have been satisfied.</li>
<li>For each propose message received, the acceptor replies with accept after updating its last accepted proposal. This is after Properties 6 &amp; 7 have been satisfied.</li>
<li>Last promised epoch and last accepted proposal are persistent and only updated by Properties 7 &amp; 9</li>
</ol>
<h2 id="classic-paxos的改进"><a href="#classic-paxos的改进" class="headerlink" title="classic paxos的改进"></a>classic paxos的改进</h2><ol>
<li>对于epoch号比较小的prepare或者proposal，acceptor不会做响应，只能由proposer等待超时并重试，此处可以改进为acceptor发送no—prepare或者no-accept消息。</li>
<li>在prepare阶段，如果proposer收到的大部分ack中的value和第二阶段的proposal value相同，则可以跳过第二阶段，直接返回value？算法如何知道确定的值就是第二阶段需要propose的值呢？</li>
<li>在一个acceptor收到确认消息后，就返回decided给proposer，proposer不必等大多数acceptor返回确认就可以直接返回确认值。（这样做真的没问题吗）Mencius</li>
</ol>
<h2 id="proposal-copying"><a href="#proposal-copying" class="headerlink" title="proposal copying"></a>proposal copying</h2><p>（Unique proposer uses each epoch）一个epoch内只有一个proposal能被接受，若proposer在phase one接受到了NACK中，发现max Epoch等于prepare中发送的epoch且已有了promised的值，则做proposal copying并跳到phase 2（为了更快的收敛？）</p>
<h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><ol>
<li>三种状态<ol>
<li>leader</li>
<li>follower</li>
<li>candidate</li>
</ol>
</li>
<li>每个server存储一个current term number</li>
<li>使用RPC通信：<ol>
<li>RequestVote RPC （initiated by candidates during elections）</li>
<li>Append_entries RPCS(initiated by leaders to replicate log entries and to provide a form of heartbeat</li>
</ol>
</li>
<li>leader election<ol>
<li>时机：只要follower能从leader或者candidate收到rpc，remain 状态，如果在election  timeout时间内没有收到rpc，认为leader死亡，开始leader election</li>
<li>选举流程：follower increments current term(term += 1) 并且转换为candidate状态，vote for self并且并行的发送requestVote RPC给集群中的其他server</li>
<li>candidate保持状态直到：<ol>
<li>赢得选举</li>
<li>其他server赢得选举</li>
<li>一段时间过去了没有胜出者</li>
</ol>
</li>
<li>candidate赢得选举的条件：在 same term的条件下获取集群内大部分server的votes。一个server只能为一个candidate vote，first-come-first-serverd。一旦赢得选举则向其他的节点发送heartbeat to prevent new election</li>
<li>如何解决split votes（每个server同时开始选举并为自己投票）<ol>
<li>random election timeout（150-300ms）</li>
</ol>
</li>
<li>followers只为log entry大于自己的candidate投票</li>
<li>candidate 收到 leader的request，比较其term和自己的term，若大于自己的则变为follower，否则reject request继续保持candidate状态</li>
</ol>
</li>
<li>Term（逻辑时钟）<ol>
<li>特性：连续数字，每个server都会有一个term</li>
<li>term changes whenever servers communitacte</li>
<li>If server a‘s term smaller than b’s, a change it’s term to b’s</li>
<li>candidate of leader founds larger term, trun itself to follower</li>
<li>if server recieved stale term request , reject it</li>
</ol>
</li>
<li>Log replication<ol>
<li>流程<ol>
<li>command come</li>
<li>leader append command to it’s log </li>
<li>Sent log to other servers to replicate the entry</li>
<li>recieved most servers reply, leader apply this comand to it’s state machine</li>
<li>return result to client</li>
<li>(if followers crash or run slowlly, or network issues, leader send rpc infinitely until all followers store all log)</li>
</ol>
</li>
<li>log structure<ol>
<li>state machine command</li>
<li>term number<ol>
<li>to detect inconsistencies between logs</li>
</ol>
</li>
<li>integer index <ol>
<li>to identify its position in the log</li>
</ol>
</li>
</ol>
</li>
<li>commited log entries<ol>
<li>when ont entry has replicated it on a majority of servers</li>
<li>leader includs highest index it knows to be commietted int appedEntries RPCs so other followers learns that and then commite that entry to its state machine</li>
</ol>
</li>
<li>how to handle inconsistencies?<ol>
<li>by forcing the follower’s logs to duplicate it’s own(follower overrited)</li>
<li>leader 存储每个follower的nextIndex array，此array初始值为last one of leader index + 1，然后向follower发送AppendEntries RPC用于指针探测，如果探测失败则以1步距回退，直到找到一个agree point。（Leader Append-Only确保了leader不会删除或者覆盖他自己的log）</li>
</ol>
</li>
<li>log被复制到大多数节点上之后leader crush但是log未commit，仍有可能被覆盖掉</li>
<li>Raft 通过 up-to-date vote 来确保新leader有所有commited logs<ol>
<li>if tyhe logs have last entries with different terms, the the log with the later term is more up-to-date</li>
<li>if the logs end up with the same term ,then whicheve log is longer is more up-to-date</li>
</ol>
</li>
</ol>
</li>
<li>Timing and availability<ol>
<li>broadcastTIme(heartBeat) &lt;&lt; electionTimeOut&lt;&lt;MTBF</li>
</ol>
</li>
<li>Raft 图解<ol>
<li><a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></li>
<li><a target="_blank" rel="noopener" href="https://raft.github.io/">https://raft.github.io</a></li>
</ol>
</li>
</ol>
<h2 id="Chain-replication"><a href="#Chain-replication" class="headerlink" title="Chain replication"></a>Chain replication</h2><ol>
<li>request processing<ol>
<li>reply generation:<ol>
<li>reply is generated and sent by tail</li>
</ol>
</li>
<li>Query processing<ol>
<li>Query processed by tail</li>
</ol>
</li>
<li>Update processing<ol>
<li>update processed by head and delevered on chain</li>
</ol>
</li>
</ol>
</li>
<li>Advantages &amp; disadvantages<ol>
<li>Read:cheap beacause only tail reply the query</li>
<li>Write:more heavy beacause all nodes need to participate, but compution only need once because head compute the value and other nodes only need to do once write.</li>
</ol>
</li>
<li>Coping with server failures<ol>
<li>直接删掉？</li>
</ol>
</li>
<li>……(没看，失去兴趣)</li>
<li>参考：<a target="_blank" rel="noopener" href="https://www.dazhuanlan.com/andyblack/topics/1098082">https://www.dazhuanlan.com/andyblack/topics/1098082</a></li>
</ol>
<h2 id="FaceBook-F4-system"><a href="#FaceBook-F4-system" class="headerlink" title="FaceBook F4 system"></a>FaceBook F4 system</h2><ol>
<li><p>Design details</p>
<ol>
<li><p>Volumes:</p>
<ol>
<li>state：    <ol>
<li>Unlocked: under 100GB, allow read/write/delete</li>
<li>Locked: only read/delete is allowed</li>
</ol>
</li>
<li>类别：<ol>
<li>dataFile: BLOB + metadata(key,size or checksum)</li>
<li>index FIle:aimed to allow rebuild when rebooting</li>
<li>Journal File:tracks BLOBS that have been deleted</li>
</ol>
</li>
</ol>
</li>
<li><p>System overall</p>
<ol>
<li>路由<ol>
<li>Create to Hot storage</li>
<li>delete on hot or warm storage</li>
<li>read on cache or hot or warm storage</li>
</ol>
</li>
<li>controller<ol>
<li>provision new machines</li>
<li>Maintain pool of unlocked volumes</li>
<li>ensure all logical volumes have enough physical volumes backing them</li>
<li>create new physical volumes if necessary</li>
<li>perform compaction and garbage clean</li>
</ol>
</li>
<li>Router tier<ol>
<li>存储了逻辑volume到物理volume的映射</li>
</ol>
</li>
<li>Transformer Tier<ol>
<li>讲计算和存储分离，计算节点用来计算，存储节点仅仅用来存取数据</li>
</ol>
</li>
</ol>
<p>……..(未读完)</p>
</li>
</ol>
</li>
</ol>
<h2 id="可靠性策略"><a href="#可靠性策略" class="headerlink" title="可靠性策略"></a>可靠性策略</h2><ol>
<li>副本策略：不同节点/不同机架/不同DC</li>
<li>一致性hash</li>
<li>CRUSH（Controlled Replication Under Scalable Hashing）：CRUSH 算法的设置目的是使数据能够根<strong>据设备的存储能力和宽带资源加权平均地分布，</strong>并保持一个相对的概率平衡。 副本放置在具有层次结构的存储设备中，这对数据安全也有重要影响。 通过反射系统的物理安装组织，CRUSH算法可以将系统模块化，从而定位潜在的设备故障。</li>
<li>EC(Erasure Code) 纠删码<ol>
<li>特点：<ol>
<li>低冗余，高磁盘利用率</li>
<li>数据恢复代价高</li>
<li>数据更新代价高</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="分布式事务协议"><a href="#分布式事务协议" class="headerlink" title="分布式事务协议"></a>分布式事务协议</h2><ol>
<li>2PC<ol>
<li>阶段：<ol>
<li>Prepare(询问):master发送prepare给参与节点，参与节点执行事务中的操作，并返回yes or no给master</li>
<li>Commit（提交或者Abort):master 收到所有节点的yes信息，则进入commit流程，发送commit给所有的参与节点。若收到任意节点的no，则进行abort流程，参与者返回执行结果给master</li>
</ol>
</li>
<li>存在的问题：<ol>
<li>同步阻塞问题：若参与者共享同步资源，参与者访问临界资源存在阻塞</li>
<li>协调者故障导致参与者长期阻塞</li>
<li>数据不一致：协调者在发送commit阶段故障，部分参与者收到了commit</li>
<li>协调者发送commit的时候宕机，唯一收到此消息的参与者此时也宕机，事务状态未可知</li>
</ol>
</li>
</ol>
</li>
<li>3PC<ol>
<li>阶段：<ol>
<li>can-commit<ol>
<li>协调者询问参与者是否可以commit</li>
<li>参与者回复yes or no</li>
</ol>
</li>
<li>pre-commit<ol>
<li>如果参与者全都是yes，则协调者执行：<ol>
<li>协调者发送预提交请求</li>
<li>参与者预提交，记录undo和redo日志，锁定记录，返回执行响应</li>
</ol>
</li>
<li>如果任意一个参与者发送了no或者等待超时，协调者执行：<ol>
<li>发送abort请求</li>
<li>参与者收到abort或者等待超时执行中断</li>
</ol>
</li>
</ol>
</li>
<li>do-commit<ol>
<li>收到全部回复都是yes：<ol>
<li>发送commit</li>
<li>参与者提交事务，释放资源</li>
<li>参与者回复响应</li>
<li>协调者收到全部响应，事务完成</li>
</ol>
</li>
<li>收到任意no<ol>
<li>发送abort</li>
<li>参与者回滚，释放资源</li>
<li>参与者回复响应</li>
<li>协调者收到所有回复，abort完成</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>如何解决协调者超时？<ol>
<li>超时机制</li>
</ol>
</li>
<li>如何解决同步阻塞？<ol>
<li>无法解决</li>
</ol>
</li>
<li>如何解决不一致？<ol>
<li>无法解决</li>
</ol>
</li>
<li>相较于2pc的优点？<ol>
<li>超时机制一定程度上解决协调者宕机问题</li>
<li>第一阶段一分为二，canCommit阶段尽早可以判断事务是否可以执行，占用资源少，提高了吞吐量。</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/General-storage-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/General-storage-knowledge/" class="post-title-link" itemprop="url">General storage knowledge</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-04 10:38:20 / Modified: 10:39:29" itemprop="dateCreated datePublished" datetime="2022-01-04T10:38:20+08:00">2022-01-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="RAID的分类："><a href="#RAID的分类：" class="headerlink" title="RAID的分类："></a>RAID的分类：</h2><ol>
<li>参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20131784">https://www.zhihu.com/question/20131784</a></li>
</ol>
<h2 id="HDD"><a href="#HDD" class="headerlink" title="HDD"></a>HDD</h2><ol>
<li>全称：<strong>H</strong>ard <strong>D</strong>isk <strong>D</strong>rive，缩写：<strong>HDD</strong></li>
<li>概念：有时为了与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98">固态硬盘</a>相区分称“<strong>机械硬盘</strong>”或“<strong>传统硬盘</strong>”）是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%84%91">电脑</a>上使用坚硬的旋转盘片为基础的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E6%8F%AE%E7%99%BC%E6%80%A7%E8%A8%98%E6%86%B6%E9%AB%94">非易失性存储器</a>，它在平整的磁性表面存储和检索数字数据，数据通过离磁性表面很近的磁头由电磁流来改变极性的方式被写入到磁盘上，数据可以通过盘片被读取，原理是磁头经过盘片的上方时盘片本身的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A3%81%E5%9C%BA">磁场</a>导致读取线圈中电气信号改变。硬盘的读写是采用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%8D%8A%E9%9A%A8%E6%A9%9F%E5%AD%98%E5%8F%96&action=edit&redlink=1">半随机存取</a>的方式，可以以任意顺序读取硬盘中的资料[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98#cite_note-2">2]</a>，但读取不同位置的资料速度不相同。硬盘包括一至数片高速转动的盘片以及放在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%89%A7%E8%A1%8C%E5%99%A8">执行器</a>悬臂上的磁头。早期的硬盘存储介质是可替换的，不过现在硬盘的存储介质一般不能更换，盘片与磁头是一起被密封在硬盘驱动器内。硬盘有一个有着过滤措施的气孔，用来平衡工作时产生的热量导致的硬盘内外的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B0%94%E5%8E%8B">气压差</a>。硬盘是由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IBM">IBM</a>在1956年开始使用[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98#cite_note-IBM350-3">3]</a>，在1960年代初成为通用式电脑中主要的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%BC%94%E5%8A%A9%E5%AD%98%E6%94%BE%E8%A3%9D%E7%BD%AE&action=edit&redlink=1">辅助存放设备</a>，随着技术的进步，硬盘也成为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>及<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%80%8B%E4%BA%BA%E9%9B%BB%E8%85%A6">个人电脑</a>的主要组件。</li>
<li>reference：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98">https://zh.wikipedia.org/wiki/硬盘</a></li>
</ol>
<h2 id="SATA-SSD"><a href="#SATA-SSD" class="headerlink" title="SATA SSD"></a>SATA SSD</h2><ol>
<li>概念：<strong>固态硬盘</strong>或<strong>固态驱动器</strong>（英语：Solid-state drive或Solid-state disk，简称<strong>SSD</strong>）是一种以集成电路制作的电脑存储设备。可以用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E6%8F%AE%E7%99%BC%E6%80%A7%E8%A8%98%E6%86%B6%E9%AB%94">非易失性存储器</a>（主要以<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%97%AA%E5%AD%98">闪存</a>中的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/NAND_Flash">NAND Flash</a>）作为永久性存储设备，也可以用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8F%AE%E7%99%BC%E6%80%A7%E8%A8%98%E6%86%B6%E9%AB%94">易失性存储器</a>（例如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DRAM">DRAM</a>）作为临时性存储设备。固态硬盘常采用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SATA">SATA</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PCI_Express">PCI Express</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MSATA">mSATA</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/M.2">M.2</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ZIF">ZIF</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%8A%80%E8%A1%93%E9%85%8D%E7%BD%AE">IDE</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/U.2">U.2</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CompactFlash">CF</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=CFast&action=edit&redlink=1">CFast</a>等接口。目前由于每单位价格及最大存储容量与机械硬盘有差距，固态硬盘暂时无法完全取代<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98">机械式硬盘</a>。</li>
<li>reference：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98">https://zh.wikipedia.org/wiki/固态硬盘</a></li>
</ol>
<h2 id="NVMe（Non-Volatile-Memory-express）"><a href="#NVMe（Non-Volatile-Memory-express）" class="headerlink" title="NVMe（Non-Volatile Memory express）"></a>NVMe（Non-Volatile Memory express）</h2><ol>
<li>全称：NVMEHCIS:Non-Volatile Memory Host Controller Interface Specification</li>
<li>概念：<strong>NVM Express</strong>（缩写<strong>NVMe</strong>），或称<strong>非易失性内存主机控制器接口规范</strong>（英语：<strong>N</strong>on-<strong>V</strong>olatile <strong>M</strong>emory <strong>H</strong>ost <strong>C</strong>ontroller <strong>I</strong>nterface <strong>S</strong>pecification，缩写：<strong>NVMHCIS</strong>），是一个逻辑设备接口<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%87%E5%87%86">规范</a>。它是基于设备逻辑接口的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8C%AF%E6%B5%81%E6%8E%92">总线</a>传输协议规范（相当于通讯协议中的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a>），用于访问通过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PCI_Express">PCI Express</a>（PCIe）总线附加的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E6%8F%AE%E7%99%BC%E6%80%A7%E8%A8%98%E6%86%B6%E9%AB%94">非易失性存储器</a>介质（例如采用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%96%83%E8%A8%98%E6%86%B6%E9%AB%94">闪存</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98">固态硬盘驱动器</a>），虽然理论上不一定要求PCIe总线协议。NVMe是一种协议，是一组允许SSD使用PCIe总线的软硬件标准；而PCIe是实际的物理连接通道。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/File:Intel_P3608_NVMe_flash_SSD,_PCI-E_add-in_card.jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Intel_P3608_NVMe_flash_SSD%2C_PCI-E_add-in_card.jpg/300px-Intel_P3608_NVMe_flash_SSD%2C_PCI-E_add-in_card.jpg" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/File:Ssd_960.jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ad/Ssd_960.jpg/300px-Ssd_960.jpg" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PCI_Express">PCI Express</a>型、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/M.2">M.2</a>型（下）</p>
<ol start="3">
<li><p>NVM代表非易失性存储器（non-volatile memory）的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A6%96%E5%AD%97%E6%AF%8D%E7%B8%AE%E7%95%A5%E5%AD%97">首字母缩略字</a>，这是固态硬盘（SSD）的常见的闪存形式。此规范主要是为基于闪存的存储设备提供一个低延时、内部并发化的原生界面规范，也为现代<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CPU">CPU</a>、电脑平台及相关应用提供原生存储并发化的支持[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/NVM_Express#cite_note-1">1]</a>，令主机硬件和软件可以充分利用固态存储设备的并行化存储能力。相比此前<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%A2%9F%E6%A9%9F">机械硬盘驱动器</a>（HDD）时代的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/AHCI">AHCI</a>（SATA下的协议），NVMe/NVMHCI降低了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/I/O">I/O</a>操作等待时间、提升同一时间内的操作数、更大容量的操作队列等。依托于PCIe总线，NVMe设备可适用于各种支持PCIe总线的物理插槽上，包括标准尺寸的PCIe<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Expansion_card&action=edit&redlink=1">扩展卡</a>（一般是4个PCIe通道）[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/NVM_Express#cite_note-2">2]</a>、采用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/U.2">U.2</a>物理连接界面（SFF-8639）的2.5英寸/3.5英寸标准尺寸固态硬盘驱动器、[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/NVM_Express#cite_note-3">3]</a>[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/NVM_Express#cite_note-4">4]</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SATA_Express">SATA Express</a>总线（兼容于PCIe）的设备、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/M.2">M.2</a>规格扩展卡等。[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/NVM_Express#cite_note-ahci-nvme-5">5]</a>此规范由NVMHCIS工作组负责管理。</p>
</li>
<li><p>参考：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/NVM_Express">https://zh.wikipedia.org/wiki/NVM_Express</a></p>
</li>
<li><p>参考：<a target="_blank" rel="noopener" href="https://www.chinastor.com/baike/ssd/04103A942017.html">https://www.chinastor.com/baike/ssd/04103A942017.html</a></p>
</li>
</ol>
<h2 id="PMem"><a href="#PMem" class="headerlink" title="PMem"></a>PMem</h2><ol>
<li><p>全称：非易失性存储</p>
</li>
<li><p>概念：英特尔® 傲腾™ 持久内存(PMem) 是一款基于3DXpoint 介质，并具有内存形态的一种全新硬件（黑科技）。通常称为Persistent Memory。</p>
</li>
</ol>
<p>![image-20211203132338916](/Users/chenjiawei/Library/Application Support/typora-user-images/image-20211203132338916.png)</p>
<ol start="3">
<li>参考：<a target="_blank" rel="noopener" href="https://learnku.com/articles/59125">https://learnku.com/articles/59125</a></li>
</ol>
<h2 id="ACID理论"><a href="#ACID理论" class="headerlink" title="ACID理论:"></a>ACID理论:</h2><ol>
<li>全称:Atomic|Consistency|Isolation|Durability</li>
</ol>
<h3 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h3><p>Main article: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Atomicity_(database_systems)">Atomicity (database systems)</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Database_transaction">Transactions</a> are often composed of multiple <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SQL_syntax">statements</a>. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Atomicity_(database_systems)">Atomicity</a> guarantees that each transaction is treated as a single “unit”, which either succeeds completely, or fails completely: if any of the statements constituting a transaction fails to complete, the entire transaction fails and the database is left unchanged. An atomic system must guarantee atomicity in each and every situation, including power failures, errors and crashes.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ACID#cite_note-4">4]</a> A guarantee of atomicity prevents updates to the database occurring only partially, which can cause greater problems than rejecting the whole series outright. As a consequence, the transaction cannot be observed to be in progress by another database client. At one moment in time, it has not yet happened, and at the next it has already occurred in whole (or nothing happened if the transaction was cancelled in progress).</p>
<p>An example of an atomic transaction is a monetary transfer from bank account A to account B. It consists of two operations, withdrawing the money from account A and saving it to account B. Performing these operations in an atomic transaction ensures that the database remains in a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_consistency">consistent state</a>, that is, money is neither debited nor credited if either of those two operations fail.</p>
<h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h3><p>Main article: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Consistency_(database_systems)">Consistency (database systems)</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Consistency_(database_systems)">Consistency</a> ensures that a transaction can only bring the database from one valid state to another, maintaining database <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Invariant_(computer_science)">invariants</a>: any data written to the database must be valid according to all defined rules, including <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Integrity_constraints">constraints</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cascading_rollback">cascades</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Database_trigger">triggers</a>, and any combination thereof. This prevents database corruption by an illegal transaction, but does not guarantee that a transaction is <em>correct</em>. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Referential_integrity">Referential integrity</a> guarantees the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unique_key">primary key</a> – <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Foreign_key">foreign key</a> relationship. </p>
<h3 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h3><p>Main article: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Isolation_(database_systems)">Isolation (database systems)</a></p>
<p>Transactions are often executed <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Concurrent_computing">concurrently</a> (e.g., multiple transactions reading and writing to a table at the same time). <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Isolation_(database_systems)">Isolation</a> ensures that concurrent execution of transactions leaves the database in the same state that would have been obtained if the transactions were executed sequentially. Isolation is the main goal of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Concurrency_control">concurrency control</a>; depending on the method used, the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Race_condition">effects</a> of an incomplete transaction might not even be visible to other transactions. </p>
<h3 id="Durability"><a href="#Durability" class="headerlink" title="Durability"></a>Durability</h3><p>Main article: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Durability_(database_systems)">Durability (database systems)</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Durability_(computer_science)">Durability</a> guarantees that once a transaction has been committed, it will remain committed even in the case of a system failure (e.g., power outage or <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Crash_(computing)">crash</a>). This usually means that completed transactions (or their effects) are recorded in <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Non-volatile_memory">non-volatile memory</a>.[<em><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</p>
<h2 id="CAP理论："><a href="#CAP理论：" class="headerlink" title="CAP理论："></a>CAP理论：</h2><ol>
<li><p>全称：Consistency|Availablility|Partition Tolerance</p>
</li>
<li><p>概念：In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Theoretical_computer_science">theoretical computer science</a>, the <strong>CAP theorem</strong>, also named <strong>Brewer’s theorem</strong> after computer scientist <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Eric_Brewer_(scientist)">Eric Brewer</a>, states that any <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Distributed_data_store">distributed data store</a> can only provide <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Trilemma">two of the following three</a> guarantees:[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CAP_theorem#cite_note-Gilbert_Lynch-1">1]</a>[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CAP_theorem#cite_note-2">2]</a>[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CAP_theorem#cite_note-3">3]</a></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Consistency_model">Consistency</a></p>
<p>Every read receives the most recent write or an error.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Availability">Availability</a></p>
<p>Every request receives a (non-error) response, without the guarantee that it contains the most recent write.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Network_partitioning">Partition tolerance</a></p>
<p>The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodes.</p>
</li>
</ul>
<p>When a network partition failure happens, it must be decided whether to：</p>
<ol>
<li>cancel the operation and thus decrease the availability but ensure consistency or to</li>
<li>proceed with the operation and thus provide availability but risk inconsistency.</li>
</ol>
<p>Thus, if there is a network partition, one has to choose between consistency and availability. Note that consistency as defined in the CAP theorem is quite different from the consistency guaranteed in <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ACID">ACID</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Database_transaction">database transactions</a>.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CAP_theorem#cite_note-4">4]</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Eric_Brewer_(scientist)">Eric Brewer</a> argues that the often-used “two out of three” concept can be somewhat misleading because system designers only need to sacrifice consistency or availability in the presence of partitions, but that in many systems partitions are rare.</p>
</li>
<li><p>选择：</p>
<ol>
<li>AP:分布式NoSql</li>
<li>CP:Oracle RAC</li>
<li>CA:单机关系型数据库</li>
</ol>
</li>
<li><p>参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CAP_theorem">https://en.wikipedia.org/wiki/CAP_theorem</a></p>
</li>
</ol>
<h2 id="BASE理论："><a href="#BASE理论：" class="headerlink" title="BASE理论："></a>BASE理论：</h2><ol>
<li><p>定义：</p>
<ol>
<li>BasicallyAvailable</li>
<li>Soft-state</li>
<li>Eventually Consistent</li>
</ol>
</li>
<li><p>牺牲一致性换取高可用和分区容忍</p>
</li>
<li><p>参考：<a target="_blank" rel="noopener" href="https://www.chinastor.com/baike/ssd/04103A942017.html">https://www.chinastor.com/baike/ssd/04103A942017.html</a></p>
</li>
</ol>
<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS:"></a>SDS:</h2><ol>
<li><p>全称：SoftWare Defined Storage</p>
</li>
<li><p>参考自维基百科：</p>
<ol>
<li><strong>Software-defined storage</strong> (<strong>SDS</strong>) is a marketing term for <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_data_storage">computer data storage</a> software for policy-based provisioning and management of data storage independent of the underlying hardware. Software-defined storage typically includes a form of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Storage_virtualization">storage virtualization</a> to separate the storage hardware from the software that manages it.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software-defined_storage#cite_note-1">1]</a> The software enabling a software-defined storage environment may also provide policy management for features such as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_deduplication">data deduplication</a>, replication, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thin_provisioning">thin provisioning</a>, snapshots and backup.</li>
<li>Software-defined storage (SDS) hardware may or may not also have abstraction, pooling, or automation software of its own. When implemented as software only in conjunction with commodity servers with internal disks, it may suggest software such as a virtual or global <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/File_system">file system</a>. If it is software layered over sophisticated large storage arrays, it suggests software such as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Storage_virtualization">storage virtualization</a> or <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Storage_resource_management">storage resource management</a>, categories of products that address separate and different problems. If the policy and management functions also include a form of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Artificial_intelligence">artificial intelligence</a> to automate protection and recovery, it can be considered as intelligent abstraction.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software-defined_storage#cite_note-2">2]</a> Software-defined storage may be implemented via appliances over a traditional <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Storage_area_network">storage area network</a> (SAN), or implemented as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Network-attached_storage">network-attached storage</a> (NAS), or using <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_storage">object-based storage</a>. In March 2014 the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Storage_Networking_Industry_Association">Storage Networking Industry Association</a> (SNIA) began a report on software-defined storage.</li>
</ol>
</li>
<li><p>参考自百度百科：</p>
<ol>
<li>将存储硬件中典型的存储控制功能抽离出来放到软件上，包括卷管理，Raid，数据保护，快照和复制等。</li>
</ol>
</li>
</ol>
<h2 id="DAS直连式存储："><a href="#DAS直连式存储：" class="headerlink" title="DAS直连式存储："></a>DAS直连式存储：</h2><ol>
<li>定义：直连式存储（DAS）是一种计算机存储，它直接连接到某台计算机且其他计算机无法获取。对于个人计算机用户来说，硬盘驱动器就是直连式存储的常见形式。</li>
<li>参考：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%9B%B4%E8%BF%9E%E5%BC%8F%E5%AD%98%E5%82%A8/10276052?fr=aladdin">https://baike.baidu.com/item/直连式存储/10276052?fr=aladdin</a></li>
</ol>
<h2 id="NAS网络连接存储"><a href="#NAS网络连接存储" class="headerlink" title="NAS网络连接存储"></a>NAS网络连接存储</h2><ol>
<li><p>全称：NetWork Attached Storeage</p>
</li>
<li><p>定义：可以通过以太网方式接入并进行访问的存储形式</p>
<p>NAS（Network Attached Storage：网络附属存储）按字面简单说就是连接在网络上，具备资料存储功能的装置，因此也称为网络存储器。它是一种专用数据存储服务器。它以数据为中心，将存储设备与服务器彻底分离，集中管理数据，从而释放带宽、提高性能、降低总拥有成本、保护投资。其成本远远低于使用服务器存储，而效率却远远高于后者。目前国际著名的NAS企业有Netapp、EMC、OUO等。</p>
</li>
<li><p>参考：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/NAS/3465615">https://baike.baidu.com/item/NAS/3465615</a></p>
</li>
</ol>
<h2 id="SAN存储区域网络"><a href="#SAN存储区域网络" class="headerlink" title="SAN存储区域网络"></a>SAN存储区域网络</h2><ol>
<li><p>全称：Storage Area NetWork</p>
</li>
<li><p>定义：存储区域网络（Storage Area Network，简称<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/SAN">SAN</a>）采用网状通道（Fibre Channel ，简称<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/FC">FC</a>，区别与Fiber Channel光纤通道）技术，通过FC交换机连接<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E9%98%B5%E5%88%97/1496275">存储阵列</a>和服务器<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>，建立专用于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/9827490">数据存储</a>的区域网络。SAN经过十多年历史的发展，已经相当成熟，成为业界的事实标准（但各个厂商的光纤交换技术不完全相同，其服务器和SAN存储有兼容性的要求）。</p>
<p>SAN专注于企业级存储的特有问题。当前企业存储方案所遇到问题的两个根源是：数据与应用系统紧密结合所产生的结构性限制，以及<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B0%8F%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/10638565">小型计算机系统接口</a>(SCSI)标准的限制。大多数分析都认为SAN是未来企业级的存储方案，这是因为SAN便于集成，能改善数据可用性及网络性能，而且还可以减轻管理作业。</p>
</li>
<li><p>参考：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E7%BD%91%E7%BB%9C/6091260?fromtitle=SAN&amp;fromid=10789152">https://baike.baidu.com/item/存储区域网络/6091260?fromtitle=SAN&amp;fromid=10789152</a></p>
</li>
<li><p>和NAS不同的是此类存储用于专用网络，无法和以太网互通：SAN和NAS都是通过网络的方式实现了业务服务器与存储设备的连接和访问，但两者是有别的前者在业务服务器上呈现的是一个磁盘，需要格式化成文件系统后使用；而后者在业务服务器上呈现的是文件系统。</p>
</li>
</ol>
<h2 id="SCSI小型计算机系统接口"><a href="#SCSI小型计算机系统接口" class="headerlink" title="SCSI小型计算机系统接口"></a>SCSI小型计算机系统接口</h2><ol>
<li><p>全称：Small Computer System Interface</p>
</li>
<li><p>定义：<strong>Small Computer System Interface</strong> (<strong>SCSI</strong>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Help:IPA/English">/ˈskʌzi/</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Help:Pronunciation_respelling_key"><em>SKUZ-ee</em></a>)[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SCSI#cite_note-1">1]</a> is a set of standards for physically connecting and transferring data between computers and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Peripheral">peripheral devices</a>. The SCSI standards define <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SCSI_command">commands</a>, protocols, electrical, optical and logical <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Interface_(computing)">interfaces</a>. The SCSI standard defines command sets for specific <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SCSI_Peripheral_Device_Type">peripheral device types</a>; the presence of “unknown” as one of these types means that in theory it can be used as an interface to almost any device, but the standard is highly pragmatic and addressed toward commercial requirements. The initial <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Parallel_SCSI">Parallel SCSI</a> was most commonly used for <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hard_disk_drive">hard disk drives</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tape_drive">tape drives</a>, but it can connect a wide range of other devices, including scanners and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CD-ROM">CD</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Optical_disc_drive">drives</a>, although not all controllers can handle all devices.</p>
<p>The ancestral SCSI standard, X3.131-1986, generally referred to as SCSI-1, was published by the X3T9 technical committee of the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/American_National_Standards_Institute">American National Standards Institute</a> (ANSI) in 1986. SCSI-2 was published in August 1990 as X3.T9.2/86-109, with further revisions in 1994 and subsequent adoption of a multitude of interfaces. Further refinements have resulted in improvements in performance and support for ever-increasing storage data capacity.</p>
</li>
<li><p>参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SCSI">https://en.wikipedia.org/wiki/SCSI</a></p>
</li>
<li><p>SCSI定义命令、通信协议以及实体的电气特性，可并行，读写时不需要CPU时间片</p>
</li>
</ol>
<h2 id="SAS"><a href="#SAS" class="headerlink" title="SAS"></a>SAS</h2><ol>
<li><p>全称：Serial Attached SCSI</p>
</li>
<li><p>定义：In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computing">computing</a>, <strong>Serial Attached SCSI</strong> (<strong>SAS</strong>) is a point-to-point serial <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Communications_protocol">protocol</a> that moves data to and from <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_storage">computer-storage</a> devices such as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hard_disk_drive">hard disk drives</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tape_drive">tape drives</a>. SAS replaces the older <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Parallel_SCSI">Parallel SCSI</a> (Parallel Small Computer System Interface, usually pronounced “scuzzy” or “sexy”[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Serial_Attached_SCSI#cite_note-ThompsonThompson2003-3">3]</a>[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Serial_Attached_SCSI#cite_note-NCR1990-4">4]</a>) bus technology that first appeared in the mid-1980s. SAS, like its predecessor, uses the standard <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SCSI_command">SCSI command set</a>. SAS offers optional compatibility with <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Serial_ATA">Serial ATA</a> (SATA), versions 2 and later. This allows the connection of SATA drives to most SAS <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Backplane">backplanes</a> or controllers. The reverse, connecting SAS drives to SATA backplanes, is not possible.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Serial_Attached_SCSI#cite_note-5">5]</a></p>
<p>The T10 technical committee of the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/International_Committee_for_Information_Technology_Standards">International Committee for Information Technology Standards</a> (INCITS) develops and maintains the SAS protocol; the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SCSI_Trade_Association">SCSI Trade Association</a> (SCSITA) promotes the technology.</p>
</li>
<li><p>参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Serial_Attached_SCSI">https://en.wikipedia.org/wiki/Serial_Attached_SCSI</a></p>
</li>
</ol>
<h2 id="AHCI"><a href="#AHCI" class="headerlink" title="AHCI"></a>AHCI</h2><ol>
<li><p>全称：Serial ATA Advanced Host Controller Interface</p>
</li>
<li><p>定义：The <strong>Advanced Host Controller Interface</strong> (<strong>AHCI</strong>) is a technical standard defined by <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Intel">Intel</a> that specifies the operation of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Serial_ATA">Serial ATA</a> (SATA) <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Host_controller">host controllers</a> in a non-implementation-specific manner in its <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Intel_chips">motherboard chipsets</a>.</p>
<p>The specification describes a system memory structure for computer hardware vendors to exchange data between host system <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_memory">memory</a> and attached <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_storage_device">storage devices</a>. AHCI gives software developers and hardware designers a standard method for detecting, configuring, and programming SATA/AHCI adapters. AHCI is separate from the SATA 3 Gbit/s standard, although it exposes SATA’s advanced capabilities (such as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hot_swapping">hot swapping</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Native_Command_Queuing">native command queuing</a>) such that host systems can utilize them. For modern <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Solid-state_drive">solid state drives</a>, the interface has been superseded by <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NVM_Express">NVMe</a>.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Advanced_Host_Controller_Interface#cite_note-1">1]</a></p>
<p>As of December 2020, the current version of the specification is 1.3.1.</p>
<p>AHCI是通用接口技术标准</p>
</li>
<li><p>参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Advanced_Host_Controller_Interface">https://en.wikipedia.org/wiki/Advanced_Host_Controller_Interface</a></p>
</li>
</ol>
<h2 id="iSCSI"><a href="#iSCSI" class="headerlink" title="iSCSI"></a>iSCSI</h2><ol>
<li><p>iSCSI是一种存储设备远程映射技术。iSCSI则是通过TCP协议对SCSI进行封装的一种协议，也就是通过以太网传输SCSI协议的内容。</p>
</li>
<li><p>In computing, **iSCSI **is an acronym for <strong>Internet Small Computer Systems Interface</strong>, an <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_Protocol">Internet Protocol</a> (IP)-based storage networking standard for linking data storage facilities. It provides <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Block-level_storage">block-level access</a> to <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_data_storage">storage devices</a> by carrying <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SCSI">SCSI</a> commands over a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/TCP/IP">TCP/IP</a> network. iSCSI is used to facilitate data transfers over <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Intranet">intranets</a> and to manage storage over long distances. It can be used to transmit data over <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Local_area_network">local area networks</a> (LANs), <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Wide_area_network">wide area networks</a> (WANs), or the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet">Internet</a> and can enable location-independent data storage and retrieval.</p>
<p>The <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Protocol_(computing)">protocol</a> allows clients (called <em>initiators</em>) to send SCSI commands (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SCSI_CDB"><em>CDBs</em></a>) to storage devices (<em>targets</em>) on remote servers. It is a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Storage_area_network">storage area network</a> (SAN) protocol, allowing organizations to consolidate storage into <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Storage_array">storage arrays</a> while providing clients (such as database and web servers) with the illusion of locally attached SCSI disks.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ISCSI#cite_note-1">1]</a> It mainly competes with <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fibre_Channel">Fibre Channel</a>, but unlike traditional Fibre Channel which usually requires dedicated cabling,[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ISCSI#cite_note-2">a]</a> iSCSI can be run over long distances using existing network infrastructure.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ISCSI#cite_note-3">2]</a> iSCSI was pioneered by IBM and Cisco in 1998 and submitted as a draft standard in March 2000.</p>
</li>
<li><p>参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ISCSI">https://en.wikipedia.org/wiki/ISCSI</a></p>
</li>
</ol>
<h2 id="NVME-OF"><a href="#NVME-OF" class="headerlink" title="NVME-OF"></a>NVME-OF</h2><ol>
<li><p>全称：NVME over Fabric</p>
</li>
<li><p>解释：SSD硬件性能提高，软件成为了瓶颈。</p>
<ol>
<li>减少软件开销，出现了SPDK</li>
<li>把固态盘放到单独设备里面，存储独立出来供很多主机共享</li>
</ol>
<p>NVMe-oF在NVMe协议中的NVMe Transport部分进行了扩展，来支持In Band，以太网光纤通道等。</p>
<p>NMMe-oF分为两种：使用RDMA的和使用FC-NVMe的</p>
<p>前者：“nfiniBand、RoCE（RDMA over Converged Ethernet）和iWARP（internet Wide Area RDMA Protocol），RDMA支持在不涉及处理器的情况下将数据传输到两台计算机的内存，并提供低延迟和快速的数据传输。”</p>
<p>摘录来自: 英特尔亚太研发有限公司. “Linux开源存储全栈详解从Ceph 到容器存储。” Apple Books. </p>
</li>
<li><p><strong>NVM Express over Fabrics</strong> (NVMe-oF) is the concept of using a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transport_layer">transport protocol</a> over a network to connect remote NVMe devices, contrary to regular NVMe where physical NVMe devices are connected to a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/PCI_Express#Serial_bus">PCIe bus</a> either directly or over a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/PCI_Express#SWITCH">PCIe switch</a> to a PCIe bus. In August 2017, a standard for using NVMe over <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fibre_Channel">Fibre Channel</a> (FC) was submitted by the standards organization <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/International_Committee_for_Information_Technology_Standards">International Committee for Information Technology Standards</a> (ICITS), and this combination is often referred to as FC-NVMe or sometimes NVMe/FC.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NVM_Express#cite_note-tech1-35">35]</a></p>
<p>As of May 2021, supported NVMe transport protocols are:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fibre_Channel">FC</a>, FC-NVMe[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NVM_Express#cite_note-tech1-35">35]</a>[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NVM_Express#cite_note-36">36]</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>, NVMe/TCP[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NVM_Express#cite_note-37">37]</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ethernet">Ethernet</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/RDMA_over_Converged_Ethernet">RoCE</a> v1/v2 (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Remote_direct_memory_access">RDMA</a> over <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_center_bridging">converged Ethernet</a>)[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NVM_Express#cite_note-38">38]</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/InfiniBand">InfiniBand</a>, NVMe over InfiniBand or NVMe/IB[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NVM_Express#cite_note-39">39]</a></li>
</ul>
<p>The standard for NVMe over Fabrics was published by NVM Express, Inc. in 2016.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NVM_Express#cite_note-40">40]</a>[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NVM_Express#cite_note-41">41]</a></p>
<p>The following software implements the NVMe-oF protocol:</p>
<ul>
<li>Linux NVMe-oF <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SCSI_initiator_and_target">initiator and target</a>.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NVM_Express#cite_note-42">42]</a> RoCE transport was supported initially, and with Linux kernel 5.x, native support for TCP was added.</li>
<li>Storage Performance Development Kit (SPDK) NVMe-oF initiator and target drivers.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NVM_Express#cite_note-44">44]</a> Both RoCE and TCP transports are supported.</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/StarWind_Software">Starwind</a> NVMe-oF initiator and target for <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Microsoft_Windows">Microsoft Windows</a>, supporting both RoCE and TCP transports.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NVM_Express#cite_note-hyper2-47">47]</a></li>
</ul>
</li>
<li><p>参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NVM_Express">https://en.wikipedia.org/wiki/NVM_Express</a></p>
</li>
</ol>
<h2 id="RDMA"><a href="#RDMA" class="headerlink" title="RDMA"></a>RDMA</h2><ol>
<li><p>全称：Remote Direct Memory Access</p>
</li>
<li><p>用途：解决网络传输中服务器端数据处理的延迟产生，它讲数据直接从一台计算机的内存传输到另外一台计算机，无需双方的操作系统的介入。</p>
</li>
<li><p>特性：low latency，low cpu overhead， high bandwidth</p>
</li>
<li><p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1420687">https://cloud.tencent.com/developer/article/1420687</a></p>
</li>
<li><p>In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computing">computing</a>, <strong>remote direct memory access</strong> (<strong>RDMA</strong>) is a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Direct_memory_access">direct memory access</a> from the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Main_memory">memory</a> of one computer into that of another without involving either one’s <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Operating_system">operating system</a>. This permits high-throughput, low-<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Latency_(engineering)">latency</a> networking, which is especially useful in massively parallel <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_cluster">computer clusters</a>.</p>
<p>RDMA supports <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Zero-copy">zero-copy</a> networking by enabling the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Network_adapter">network adapter</a> to transfer data from the wire directly to application memory or from application memory directly to the wire, eliminating the need to copy data between application memory and the data buffers in the operating system. Such transfers require no work to be done by <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Central_processing_unit">CPUs</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CPU_cache">caches</a>, or <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Context_switch">context switches</a>, and transfers continue in parallel with other system operations. This reduces latency in message transfer.</p>
<p>However, this strategy presents several problems related to the fact that the target node is not notified of the completion of the request (single-sided communications).</p>
</li>
<li><p>参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Remote_direct_memory_access">https://en.wikipedia.org/wiki/Remote_direct_memory_access</a></p>
</li>
</ol>
<h2 id="TOE"><a href="#TOE" class="headerlink" title="TOE"></a>TOE</h2><ol>
<li>全称：TCP offload engine</li>
<li><strong>TCP offload engine</strong> (<strong>TOE</strong>) is a technology used in <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Network_interface_card">network interface cards</a> (NIC) to offload processing of the entire <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/TCP/IP">TCP/IP</a> stack to the network controller. It is primarily used with high-speed network interfaces, such as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Gigabit_Ethernet">gigabit Ethernet</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/10_Gigabit_Ethernet">10 Gigabit Ethernet</a>, where processing overhead of the network stack becomes significant.将CPU耗费大量资源进行多层网络协议的数据包处理工作转移到网卡上，需要网卡支持，常见于高速以太网接口上。</li>
<li>参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/TCP_offload_engine">https://en.wikipedia.org/wiki/TCP_offload_engine</a></li>
</ol>
<h2 id="U-Net"><a href="#U-Net" class="headerlink" title="U-Net"></a>U-Net</h2><ol>
<li>全称：User-Net networking</li>
<li>避免了数据从用户空间向内核空间的拷贝</li>
</ol>
<h2 id="Linux内核IO栈"><a href="#Linux内核IO栈" class="headerlink" title="Linux内核IO栈"></a>Linux内核IO栈</h2><p><img src="https://www.thomas-krenn.com/de/wikiDE/images/e/e0/Linux-storage-stack-diagram_v4.10.png" alt="img"></p>
<ol>
<li><p>用户空间和内核空间：32位系统的寻址空间为4G，操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。操作系统讲虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。以Linux为例，较高的1g字节供内核使用，较低的3g字节供用户进程使用。</p>
</li>
<li><p>page cache缓存IO：在Linux的缓存IO机制中，操作系统会将IO的数据缓存在文件系统的页缓存中（page cache），数据会被先拷贝到操作系统的系统内核缓冲区中，然后才会从操作系统内核莪缓冲区拷贝到应用程序的地址空间。</p>
</li>
<li><p>网络IO模型的类别：</p>
<ol>
<li>同步（synchronous IO）</li>
<li>阻塞(blocking IO)</li>
<li>非阻塞(non-blocking IO)</li>
<li>多路复用(multiplexing IO)</li>
<li>信号驱动式(signal-dirven IO)</li>
<li>异步(asynchronous IO)</li>
</ol>
</li>
<li><p>Linux IO模型：（参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/486b0965c296%EF%BC%89">https://www.jianshu.com/p/486b0965c296）</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-a630f1d47b7ba148.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p>
<ol>
<li>同步阻塞：线程等kernal把数据从内核缓存拷贝到应用程序空间再处理</li>
<li>同步非阻塞：线程等数据的过程中去做其他事，但是会不断轮询（操作系统立刻返回，但是不一定会有数据）</li>
<li>IO多路复用：I/O多路复用技术<code>通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求</code>。与传统的多线程/多进程模型比，<code>I/O多路复用的最大优势是系统开销小</code>，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源</li>
</ol>
</li>
</ol>
<h2 id="Linux开源存储全栈详解从Ceph-到容器存储（读书摘录）"><a href="#Linux开源存储全栈详解从Ceph-到容器存储（读书摘录）" class="headerlink" title="Linux开源存储全栈详解从Ceph 到容器存储（读书摘录）"></a>Linux开源存储全栈详解从Ceph 到容器存储（读书摘录）</h2><p>SPDK:Storage Performance Development Kit：</p>
<p>利用用户态的NVMe SSD，加速应用，如iSCSITarget或者NVMe-oF Target</p>
<ol>
<li>Linux远程存储服务</li>
</ol>
<p>“1）块设备服务<br>Linux常用的块设备服务主要基于iSCSI（Internet Small Computer System Interface）和NVMe over Fabrics。<br>iSCSI协议是SCSI（Small Computer System Interface）协议在以太网上的扩展，一台机器通过iSCSI协议即可通过传输控制协议/网际协议（Transmission Control Protocol / Internet Protocol，TCP/IP）为其他客户提供共享的存储设备。通过iSCSI协议被访问的设备称为Target，而访问Target的客户（Client）端称为Initiator。目前Linux主流的iSCSI Target软件是基于Kernel的Linux-IO，在用户态可以使用targetcli工具进行管理。当然还有其他开源的iSCSI Target，如STGT、SCST等。iSCSI常用的iSCSI Initiator工具包括iscsiadm命令和libiscsi、open-iscsi等软件开发包。<br>“NVMe over Fabrics则是NVMe协议在Fabrics上的延伸，主要的设计目的是让客户端能够更高效地访问远端的服务器上的NVMe盘。相对iSCSI协议，NVMe over Fabrics则完全是为高效访问基于NVMe协议的快速存储设备设计的，往往和带有RDMA（Remote Direct Memory Access）功能的以太网卡，或者光纤通道、Infiniband一起工作。”</p>
<p>摘录来自: 英特尔亚太研发有限公司. “Linux开源存储全栈详解从Ceph 到容器存储。” Apple Books. </p>
<p>“2）文件存储服务<br>基于不同的协议，在Linux中可以提供很多文件粒度的服务。例如，基于网络文件系统（Network File System，NFS）协议的服务，服务器端可以直接加载支持网络文件系统协议的daemon。网络文件系统协议最早是由Sun公司在1984年开发的，目前已经发展到了NFSv4。<br>另外还有基于CIFS（Common Internet File System）的samba服务，使用这个服务可以向Windows客户端共享文件。这样Windows客户端可以把一个网络地址挂载成本地一块磁盘。例如，一个地址为192.168.1.8的Linux服务器导出一个名为XYZ的目录，实际指“向/home/XYZ，那么客户端就可以使用\192.168.1.8\XYZ，但是需要通过samba服务器的用户验证。<br>此外，Linux还有其他文件服务，如基于文件传输协议（File Transfer Protocol，FTP）的服务，这里不再赘述。另外在Linux系统中，如果用户熟悉SSH（Secure Shell）的一些命令，可以使用scp命令在不同Linux客户端进行文件的复制，或使用wget命令进行文件的下载。这是普通用户常用的功能，但需要服务器端的支持，不过这些服务器端程序的实现一般都比较简单。”</p>
<p>摘录来自: 英特尔亚太研发有限公司. “Linux开源存储全栈详解从Ceph 到容器存储。” Apple Books. </p>
<ol start="2">
<li>存储服务的分类：（p61）<ol>
<li>块存储</li>
<li>文件存储</li>
<li>对象存储</li>
</ol>
</li>
<li>压缩方式：（比特级别的去重）<ol>
<li>霍夫曼编码（不太记得了</li>
<li>算数编码（没看明白</li>
</ol>
</li>
<li>重复数据删除（块级别的去重，8K）</li>
</ol>
<h2 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h2><ol>
<li>物理接口的演变：SATA, mSATA, SATAExpress, M.2,U.2</li>
<li>![image-20211130102958080](/Users/chenjiawei/Library/Application Support/typora-user-images/image-20211130102958080.png)</li>
</ol>
<h2 id="网络存储技术"><a href="#网络存储技术" class="headerlink" title="网络存储技术"></a>网络存储技术</h2><p>DAS，NAS，SAN, iSCSI </p>
<p>![image-20211130104641972](/Users/chenjiawei/Library/Application Support/typora-user-images/image-20211130104641972.png)</p>
<p>![image-20211130104951269](/Users/chenjiawei/Library/Application Support/typora-user-images/image-20211130104951269.png)</p>
<p>参考：p174</p>
<h3 id="内核提供的有关存储的系统调用"><a href="#内核提供的有关存储的系统调用" class="headerlink" title="内核提供的有关存储的系统调用"></a>内核提供的有关存储的系统调用</h3><p>read</p>
<p>write</p>
<p>open</p>
<p>进程地址范围分类：代码段，数据段，未初始化的全局变量段，堆栈</p>
<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>“与read/write相比，使用mmap的方式对文件进行访问，带来的一个显著好处就是可以减少一次用户空间到内核空间的复制”</p>
<p>摘录来自: 英特尔亚太研发有限公司. “Linux开源存储全栈详解从Ceph 到容器存储。” Apple Books. </p>
<h4 id="虚拟文件系统主要有以下4个对象类型："><a href="#虚拟文件系统主要有以下4个对象类型：" class="headerlink" title="虚拟文件系统主要有以下4个对象类型："></a>虚拟文件系统主要有以下4个对象类型：</h4><ol>
<li>超级块：呆逼爱一个已安装的文件系统</li>
<li>索引节点：代表村塾社保上的一个实际物理文件，即“元数据”</li>
<li>目录项：描述了文件系统的层次结构</li>
<li>文件：代表已经被进程打开的文件，主要用于建立进程和文件之间的对应的关系</li>
</ol>
<h4 id="Btrfs文件系统的优点："><a href="#Btrfs文件系统的优点：" class="headerlink" title="Btrfs文件系统的优点："></a>Btrfs文件系统的优点：</h4><ol>
<li>B-Tree存储索引，提升查找效率，减少磁盘IO</li>
<li>基于extent的文件存储</li>
<li>动态索引节点分配</li>
<li>针对固态银盘优化</li>
<li>支持元数据和数据的校验</li>
<li>支持copy on write</li>
<li>子分区</li>
<li>软件磁盘阵列</li>
<li>压缩</li>
</ol>
<h4 id="Direct-IO"><a href="#Direct-IO" class="headerlink" title="Direct IO"></a>Direct IO</h4><p>省略使用Buffered UI中的内核缓冲区的使用，数据可以直接在用户空间好磁盘进行传输。</p>
<p>“Direct I/O最主要的优点就是通过减少内核缓冲区和用户空间的数据复制次数，降低文件读/写时所带来的CPU负载能力及内存带宽的占用率。”</p>
<p>摘录来自: 英特尔亚太研发有限公司. “Linux开源存储全栈详解从Ceph 到容器存储。” Apple Books. </p>
<h4 id="IO调度算法"><a href="#IO调度算法" class="headerlink" title="IO调度算法"></a>IO调度算法</h4><ol>
<li>noop：什么都不做，顺序调度</li>
<li>deadLine：电梯+避免饥饿（时间到了立马给它调度</li>
<li>CFQ（Completely Fair Queueing）：固定时间片内调度，超时重新排队</li>
</ol>
<h4 id="IO合并"><a href="#IO合并" class="headerlink" title="IO合并"></a>IO合并</h4><p>进行IO调度之前，每个线程都有私有的Plug队列蓄流，蓄流过程中会尝试合并Bio request。</p>
<p>“泄流的时候，进程本地Plug队列的request，会被加入电梯调度算法的队列中。当各个进程本地Plug队列里面的request被泄流时，进入的不是最终的设备驱动，而是一个电梯调度算法，request将进行再一次的排队。这个电梯调度算法的主要目的就是进一步合并request，把request对硬盘的访问顺序化，以及执行一定的QoS（Quality of Service）。”</p>
<p>摘录来自: 英特尔亚太研发有限公司. “Linux开源存储全栈详解从Ceph 到容器存储。” Apple Books. </p>
<h4 id="DRBD"><a href="#DRBD" class="headerlink" title="DRBD"></a>DRBD</h4><p>Distributed Relicated Block Device,主从复制，依靠tcpip协议</p>
<h2 id="存储加速"><a href="#存储加速" class="headerlink" title="存储加速"></a>存储加速</h2><h3 id="基于cpu"><a href="#基于cpu" class="headerlink" title="基于cpu"></a>基于cpu</h3><ol>
<li>超线程</li>
<li>SIMD（Single Instruction Multiple Data）一条指令同时处理多个数据集</li>
</ol>
<h3 id="基于协处理器或其他硬件"><a href="#基于协处理器或其他硬件" class="headerlink" title="基于协处理器或其他硬件"></a>基于协处理器或其他硬件</h3><ol>
<li>FPGA</li>
<li>存储协议转换加速</li>
<li>特殊存储接口加速</li>
</ol>
<h3 id="智能网卡加速"><a href="#智能网卡加速" class="headerlink" title="智能网卡加速"></a>智能网卡加速</h3><p>把一部分cpu的工作放到网卡上来完成</p>
<h2 id="数据保护"><a href="#数据保护" class="headerlink" title="数据保护"></a>数据保护</h2><ol>
<li><p>RAID 冗余磁盘阵列</p>
</li>
<li><p>纠删码：</p>
<ol>
<li><p>“纠删码可以看作RAID5和RAID6的超集，k +m 纠删码如图4-8所示，其基本思想是将k 块原始的数据元素通过一定的计算，得到m 块冗余元素（校验块）。对于这k +m 块的元素，当其中任意m 块元素出错（包括原始数据和冗余数据）时，均可以通过对应的重构算法恢复出原来的k 块数据。生成校验的过程被称为编码，恢复丢失数据块的过程被称为解码。”</p>
<p>摘录来自: 英特尔亚太研发有限公司. “Linux开源存储全栈详解从Ceph 到容器存储。” Apple Books. </p>
</li>
</ol>
</li>
</ol>
<h2 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h2><p>hash用于去重，加密和数据一致性验证</p>
<ol>
<li>MD5</li>
<li>SHA1</li>
<li>SHA2</li>
<li>SHA3</li>
</ol>
<h2 id="数据完整性："><a href="#数据完整性：" class="headerlink" title="数据完整性："></a>数据完整性：</h2><p>循环冗余校验</p>
<h2 id="存储新能软件加速库"><a href="#存储新能软件加速库" class="headerlink" title="存储新能软件加速库"></a>存储新能软件加速库</h2><p>SPDK：用户态、异步、轮询</p>
<p>P291</p>
<h2 id="一致性HASH"><a href="#一致性HASH" class="headerlink" title="一致性HASH"></a>一致性HASH</h2><p>“而一致性哈希算法的出现解决了扩容带来的数据迁移问题，甚至能够接近理论上的最优解。即在存有k 个数据块的n 个节点存储系统中，再增加m 个节点只会导致平均k ×m /（n + m ）个数据块从n 个节点向m 个节点迁移，而非所有k 个数据块全部重新分布。这似乎已经非常理想了，但一致性哈希算法的模型仍然过于简单，不足以应对存储系统中出现的各种可能的情况。最突出的就是数据失效问题，因为所有用户数据都是均匀分布在系统中的，所以一个设备的失效将会影响所有用户数据的完整性。而且由于一致性哈希算法没有感知存储节点的实际物理分布的能力，如何合理地控制数据的失效域更是无从谈起。”</p>
<p>摘录来自: 英特尔亚太研发有限公司. “Linux开源存储全栈详解从Ceph 到容器存储。” Apple Books. </p>
<h2 id="CRUSH算法"><a href="#CRUSH算法" class="headerlink" title="CRUSH算法"></a>CRUSH算法</h2><ol>
<li>元数据：<ol>
<li>CRUSH Map：保存了汲取中所有设备活OSF存储节点的位置信息和权重设置</li>
<li>OSDMap：保存了各个OSD的运行时状态，让CRUSH感知存储节点的实效、删除和加入情况</li>
<li>CRUSH Rule</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/31/How-to-fix-lib-so-file-not-found-problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/31/How-to-fix-lib-so-file-not-found-problem/" class="post-title-link" itemprop="url">How to fix lib.so file not found problem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-12-31 11:28:41 / Modified: 11:29:26" itemprop="dateCreated datePublished" datetime="2021-12-31T11:28:41+08:00">2021-12-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在debug DAOS的过程中，gdb在执行可执行文件时，未能正确的加载libdaos的动态链接库。</p>
<h2 id="什么是动态链接库"><a href="#什么是动态链接库" class="headerlink" title="什么是动态链接库"></a>什么是动态链接库</h2><p>Linux中的共享库为程序提供了各种可重用函数。</p>
<p>假设我们想编写一个以压缩文件为输入的程序。为此，我们可以使用zlib等现有库，而不是自己实现解压缩函数。</p>
<p>程序在启动时加载共享库。</p>
<h2 id="查看可执行文件使用了哪些动态链接库"><a href="#查看可执行文件使用了哪些动态链接库" class="headerlink" title="查看可执行文件使用了哪些动态链接库"></a>查看可执行文件使用了哪些动态链接库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ldd /usr/bin/clang</span></span><br><span class="line">/usr/bin/clang:</span><br><span class="line">	linux-vdso.so.1 (0x00007ffd34a90000)</span><br><span class="line">	libclang-cpp.so.13 =&gt; /usr/bin/../lib/libclang-cpp.so.13 (0x00007f24c5a94000)</span><br><span class="line">	libLLVM-13.so =&gt; /usr/bin/../lib/libLLVM-13.so (0x00007f24c1548000)</span><br><span class="line">	libstdc++.so.6 =&gt; /usr/bin/../lib/libstdc++.so.6 (0x00007f24c12d6000)</span><br><span class="line">	libm.so.6 =&gt; /usr/bin/../lib/libm.so.6 (0x00007f24c11f8000)</span><br><span class="line">	libgcc_s.so.1 =&gt; /usr/bin/../lib/libgcc_s.so.1 (0x00007f24c11dd000)</span><br><span class="line">	libc.so.6 =&gt; /usr/bin/../lib/libc.so.6 (0x00007f24c0fc4000)</span><br><span class="line">	/lib/ld-linux-x86-64.so.2 =&gt; /usr/lib/ld-linux-x86-64.so.2 (0x00007f24c95d4000)</span><br><span class="line">	libz.so.1 =&gt; /usr/bin/../lib/../lib/libz.so.1 (0x00007f24c0fad000)</span><br></pre></td></tr></table></figure>

<h2 id="查找未能找到的库"><a href="#查找未能找到的库" class="headerlink" title="查找未能找到的库"></a>查找未能找到的库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt search zstd</span></span><br><span class="line">Sorting... Done</span><br><span class="line">Full Text Search... Done</span><br><span class="line">zstd/stable 1.5.0 aarch64</span><br><span class="line">  Zstandard compression.</span><br></pre></td></tr></table></figure>

<h2 id="LD-LIBRARY-PATH-环境变量"><a href="#LD-LIBRARY-PATH-环境变量" class="headerlink" title="LD_LIBRARY_PATH 环境变量"></a><em>LD_LIBRARY_PATH</em> 环境变量</h2><p>我们可以指定在LD_LIBRARY_PATH环境变量中搜索共享库的目录。</p>
<p>LD_LIBRARY_PATH是一个冒号分隔的目录列表，就像PATH变量一样。</p>
<p>默认搜索路径通常仅限于/usr/lib和/usr/local/lib。</p>
<p>假设我们有一个链接到libfoo.so的程序，位于/home/baeldung/libs/libfoo.so，位于默认搜索路径之外。然后，我们可以使用此变量附加到搜索路径并解决问题。</p>
<p>首先，让我们使用ldd命令确认程序链接到的确切库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./program</span></span><br><span class="line">./program: error while loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory</span><br><span class="line"><span class="meta">$</span><span class="bash"> ldd ./program</span></span><br><span class="line">./program:</span><br><span class="line">	linux-vdso.so.1 (0x00007ffce871b000)</span><br><span class="line">	libfoo.so =&gt; not found</span><br><span class="line">	libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007fdceadaf000)</span><br><span class="line">	/lib/ld-linux-x86-64.so.2 =&gt; /usr/lib/ld-linux-x86-64.so.2 (0x00007fdceafd3000)</span><br></pre></td></tr></table></figure>

<p>现在，让我们将目录添加到LD_LIBRARY_PATH，并使我们的程序正常工作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> LD_LIBRARY_PATH=/home/baeldung/libs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ldd ./program</span></span><br><span class="line">./program:</span><br><span class="line">	linux-vdso.so.1 (0x00007ffe28dfd000)</span><br><span class="line">	libfoo.so =&gt; /home/baeldung/libs/libfoo.so (0x00007f8f0f7ba000)</span><br><span class="line">	libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f8f0f59d000)</span><br><span class="line">	/lib/ld-linux-x86-64.so.2 =&gt; /usr/lib/ld-linux-x86-64.so.2 (0x00007f8f0f7c6000)</span><br></pre></td></tr></table></figure>



<h2 id="永久生效的配置"><a href="#永久生效的配置" class="headerlink" title="永久生效的配置"></a>永久生效的配置</h2><p>我们可以使用/etc/ld.so.conf文件永久设置库搜索路径。在这个文件中，我们指定了一个以换行符分隔的目录列表。</p>
<p>让我们再次修复libfoo.so错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./program</span></span><br><span class="line">./program: error while loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;/home/baeldung/libs&quot;</span> | sudo tee /etc/ld.so.conf</span></span><br><span class="line">/home/baeldung/libs</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ldconfig</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ldd ./program</span></span><br><span class="line">./program:</span><br><span class="line">	linux-vdso.so.1 (0x00007ffefc3db000)</span><br><span class="line">	libfoo.so =&gt; /home/baeldung/libs/libfoo.so (0x00007f021e88d000)</span><br><span class="line">	libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f021e674000)</span><br><span class="line">	/lib/ld-linux-x86-64.so.2 =&gt; /usr/lib/ld-linux-x86-64.so.2 (0x00007f021e89e000)</span><br></pre></td></tr></table></figure>

<p>我们必须运行一次ldconfig命令，以使系统意识到新路径。</p>
<h2 id="ldconfig-指令"><a href="#ldconfig-指令" class="headerlink" title="ldconfig 指令"></a>ldconfig 指令</h2><p>我们可能最近安装了新的共享库或修改了共享库搜索路径。因此，我们需要运行ldconfig命令。</p>
<p>它更新链接器的缓存，使其了解新的共享库。</p>
<p>链接器称为ld.so，加载程序的共享库。</p>
<p>我们可以使用-p标志调用ldconfig来检查当前缓存：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ldconfig -p</span></span><br><span class="line">347 libs found in cache `/etc/ld.so.cache&#x27;</span><br><span class="line">	libzstd.so.1 (libc6,x86-64) =&gt; /usr/lib/libzstd.so.1</span><br><span class="line">	libzstd.so (libc6,x86-64) =&gt; /usr/lib/libzstd.so</span><br><span class="line">	libz.so.1 (libc6,x86-64) =&gt; /usr/lib/libz.so.1</span><br><span class="line">	libz.so (libc6,x86-64) =&gt; /usr/lib/libz.so</span><br><span class="line">	libx265.so.199 (libc6,x86-64) =&gt; /usr/lib/libx265.so.199</span><br><span class="line">	libx265.so (libc6,x86-64) =&gt; /usr/lib/libx265.so</span><br><span class="line">	libx264.so.157 (libc6,x86-64) =&gt; /usr/lib/libx264.so.157</span><br><span class="line">	libx264.so (libc6,x86-64) =&gt; /usr/lib/libx264.so</span><br></pre></td></tr></table></figure>



<h2 id="在编译时设置库路径"><a href="#在编译时设置库路径" class="headerlink" title="在编译时设置库路径"></a>在编译时设置库路径</h2><p>如果我们可以访问程序的源代码，我们可以在链接过程中使用特殊标志编译它，以便找到共享库。</p>
<p>我们可以在运行时使用ld’s-rpath标志将库路径传递给动态链接器。</p>
<p>让我们编译一个基本程序并将其链接到我们的库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/home/baeldung/libs</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">libfoo.so</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;int main() &#123;&#125;&quot;</span> &gt; program.c <span class="comment"># Dummy program</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cc program.c libfoo.so <span class="comment"># Link to our library</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./a.out</span> </span><br><span class="line">./a.out: error while loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory</span><br><span class="line"><span class="meta">$</span><span class="bash"> ldd ./a.out</span> </span><br><span class="line">./a.out:</span><br><span class="line">	linux-vdso.so.1 (0x00007ffcbc1f8000)</span><br><span class="line">	libfoo.so =&gt; not found</span><br><span class="line">	libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007feb0ee04000)</span><br><span class="line">	/lib/ld-linux-x86-64.so.2 =&gt; /usr/lib/ld-linux-x86-64.so.2 (0x00007feb0f029000)</span><br></pre></td></tr></table></figure>

<p>我们可以看到程序无法加载我们的共享库。</p>
<p>现在，让我们尝试使用-rpath标志编译它，将/home/baeldung/libs添加到库搜索路径中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc program.c libfoo.so -Wl,-rpath=/home/baeldung/libs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ldd ./a.out</span> </span><br><span class="line">./a.out:</span><br><span class="line">	linux-vdso.so.1 (0x00007ffd0fbad000)</span><br><span class="line">	libfoo.so =&gt; /home/baeldung/libs/libfoo.so (0x00007fba09d99000)</span><br><span class="line">	libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007fba09b7b000)</span><br><span class="line">	/lib/ld-linux-x86-64.so.2 =&gt; /usr/lib/ld-linux-x86-64.so.2 (0x00007fba09da5000)</span><br></pre></td></tr></table></figure>

<p>在这里，我们使用gcc的-Wl标志将参数传递给ld。</p>
<h2 id="libdaos未找到的解决方案"><a href="#libdaos未找到的解决方案" class="headerlink" title="libdaos未找到的解决方案"></a>libdaos未找到的解决方案</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;/home/kuhan/daos/build/release/gcc/src/client/api/&quot; | sudo tee /etc/ld.so.conf</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.baeldung.com/linux/solve-shared-object-error">https://www.baeldung.com/linux/solve-shared-object-error</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/30/How-to-debug-daos-engine-via-vscode-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Javie Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/30/How-to-debug-daos-engine-via-vscode-md/" class="post-title-link" itemprop="url">How_to_debug_daos_engine_via_vscode.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-12-30 13:40:26 / Modified: 13:40:56" itemprop="dateCreated datePublished" datetime="2021-12-30T13:40:26+08:00">2021-12-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h1><p>daos代码干读的话不是很好理解，如果能单步跟踪，那么对于理解daos的控制流程和数据读写是比较有利的。</p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul>
<li>vscode</li>
<li>一台虚拟机</li>
</ul>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><h2 id="在虚拟机中编译daos-code"><a href="#在虚拟机中编译daos-code" class="headerlink" title="在虚拟机中编译daos code"></a>在虚拟机中编译daos code</h2><p>此步骤省略，参见官网的文档。</p>
<h2 id="在虚拟机中启动Daos"><a href="#在虚拟机中启动Daos" class="headerlink" title="在虚拟机中启动Daos"></a>在虚拟机中启动Daos</h2><p>此步骤省略，参见官网文档：</p>
<ol>
<li>启动daos_server</li>
<li>启动daos_engine</li>
<li>启动daos_agent</li>
</ol>
<h2 id="配置local和remote的ssh免密连接"><a href="#配置local和remote的ssh免密连接" class="headerlink" title="配置local和remote的ssh免密连接"></a>配置local和remote的ssh免密连接</h2><ol>
<li><p>ssh-copy-id <a href="mailto:&#x72;&#111;&#111;&#116;&#64;&#49;&#x37;&#x32;&#46;&#x31;&#x38;&#46;&#x32;&#48;&#46;&#49;&#49;">&#x72;&#111;&#111;&#116;&#64;&#49;&#x37;&#x32;&#46;&#x31;&#x38;&#46;&#x32;&#48;&#46;&#49;&#49;</a></p>
<ul>
<li>输入remote虚拟机root账户的密码</li>
</ul>
</li>
<li><p>配置VSCode和虚拟机的连接：</p>
<p>vscode支持三种模式的remote debug：</p>
<ul>
<li>Docker</li>
<li>WSL</li>
<li>SSH</li>
</ul>
<p>这里我们把Daos相关进程启动在了物理机（虚机）上，因此我们选择第三种SSH模式。</p>
<ol>
<li><p>点击VSCode边栏“远程资源管理”<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxvp3k38l6j301200x0kd.jpg" alt="image-20211230112046773"></p>
</li>
<li><p>点击加号<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxvp4g3s2ij307000pmwx.jpg" alt="image-20211230112516147"></p>
</li>
<li><p>在跳转出来的textbox中输入ssh的连接指令：</p>
<p><code>ssh root@1123.1212.2121.121</code></p>
</li>
<li><p>配置成功</p>
</li>
</ol>
</li>
</ol>
<h2 id="Attach-code-base目录："><a href="#Attach-code-base目录：" class="headerlink" title="Attach code base目录："></a>Attach code base目录：</h2><ol>
<li>点击文件夹+<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxvp8s9vltj307801wgli.jpg" alt="image-20211230112927129"></li>
<li>选择目标代码目录</li>
</ol>
<h2 id="安装remote-C-C-扩展"><a href="#安装remote-C-C-扩展" class="headerlink" title="安装remote C/C++扩展"></a>安装remote C/C++扩展</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxvsihwmztj306v03hweh.jpg" alt="image-20211230132234853"></p>
<h2 id="配置Debug-config"><a href="#配置Debug-config" class="headerlink" title="配置Debug config"></a>配置Debug config</h2><ol>
<li><p>点击VScode边栏“运行和调试”</p>
</li>
<li><p>点击<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxvsjvwgmpj307000t0si.jpg" alt="image-20211230132355728"></p>
</li>
<li><p>添加配置<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxvskbljawj304301iq2q.jpg" alt="image-20211230132424770"></p>
</li>
<li><p>点击<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxvsl3mi8cj307600uq2q.jpg" alt="image-20211230132505233"></p>
</li>
<li><p>在<code>launch.json</code>中写入以下配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;(gdb) 附加&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;attach&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;/home/kuhan/daos/install/bin/daos_engine&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;processId&quot;</span>: <span class="string">&quot;$&#123;command:pickProcess&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>按F5或者点击“开始调试”，debugger会尝试attach到daos_engine上。</p>
</li>
<li><p>在本地shell中<code>ssh root@123.123.123.123</code>登入到远程，查看daos相关进程<code>ps -ef | grep daos</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@kuhan-server:/home/kuhan/daos/src/tests# ps -efww |grep daos</span><br><span class="line">root       13401   10440  0 Dec29 pts/1    00:01:07 daos_server -o daos_server.yml start</span><br><span class="line">root       14457   13401 99 Dec29 pts/1    19:05:20 /home/kuhan/daos/install/bin/daos_engine -t 1 -x 0 -g daos_server -d /var/run/daos_server -T 2 -n /mnt/daos/daos_nvme.conf -I 0 -r 8192 -H 2 -s /mnt/daos</span><br><span class="line">root       14470   10440  0 Dec29 pts/1    00:00:02 daos_agent -i start</span><br><span class="line">root       31974   10440  0 03:12 pts/1    00:00:00 grep --color=auto daos</span><br></pre></td></tr></table></figure></li>
<li><p>可知daos_engine的进程号为14457</p>
</li>
<li><p>在VScode中填入对应的进程号：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxvsuw29e6j30gw031aa6.jpg" alt="image-20211230133433545"></p>
</li>
<li><p>出现以下画面表示attach成功</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxvsvvtzmfj306y06at8r.jpg" alt="image-20211230133530702"></p>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://lightrun.com/debugging/how-to-debug-remotely-in-vs-code/">https://lightrun.com/debugging/how-to-debug-remotely-in-vs-code/</a></li>
<li><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/debugging#_launch-configurations">https://code.visualstudio.com/docs/editor/debugging#_launch-configurations</a></li>
<li><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/debugging">https://code.visualstudio.com/docs/editor/debugging</a></li>
</ol>
<h1 id="More"><a href="#More" class="headerlink" title="More"></a>More</h1><ol>
<li>how to debug daos_server: TBD</li>
<li>how to debug daos_agent: TBD</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Javie Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Javie Chen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
